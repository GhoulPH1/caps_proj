{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js", "../../../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js", "../../../../node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js", "../../../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/util/longbits.js", "../../../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/util/minimal.js", "../../../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/writer.js", "../../../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/writer_buffer.js", "../../../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/reader.js", "../../../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/reader_buffer.js", "../../../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/rpc/service.js", "../../../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/rpc.js", "../../../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/roots.js", "../../../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/src/index-minimal.js", "../../../../node_modules/.pnpm/protobufjs@7.4.0/node_modules/protobufjs/minimal.js", "../../../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js", "../../../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/index.js", "../../../../node_modules/.pnpm/@web3-storage+data-segment@5.3.0/node_modules/@web3-storage/data-segment/src/multihash.js", "../../../../node_modules/.pnpm/@web3-storage+data-segment@5.3.0/node_modules/@web3-storage/data-segment/src/constant.js", "../../../../node_modules/.pnpm/@web3-storage+data-segment@5.3.0/node_modules/@web3-storage/data-segment/src/node.js", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bytes.ts", "../../../../node_modules/.pnpm/@web3-storage+data-segment@5.3.0/node_modules/@web3-storage/data-segment/src/ipld/sha256.js", "../../../../node_modules/.pnpm/sync-multihash-sha2@1.0.0/node_modules/sync-multihash-sha2/src/sha256/web.js", "../../../../node_modules/.pnpm/sync-multihash-sha2@1.0.0/node_modules/sync-multihash-sha2/src/sha256/digest.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/is.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/token.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/byte-utils.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/bl.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/common.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/0uint.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/1negint.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/2bytes.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/3string.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/4array.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/5map.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/6tag.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/7float.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/jump.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/encode.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/decode.js", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base32.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/vendor/base-x.js", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base36.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base58.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/varint.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/vendor/varint.js", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/hashes/digest.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/cid.ts", "../../../../node_modules/.pnpm/@ipld+dag-cbor@9.2.1/node_modules/@ipld/dag-cbor/src/index.js", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/link.ts", "../../../../node_modules/.pnpm/@web3-storage+data-segment@5.3.0/node_modules/@web3-storage/data-segment/src/proof.js", "../../../../node_modules/.pnpm/@web3-storage+data-segment@5.3.0/node_modules/@web3-storage/data-segment/src/zero-comm.js", "../../../../node_modules/.pnpm/@web3-storage+data-segment@5.3.0/node_modules/@web3-storage/data-segment/src/piece/tree.js", "../../../../node_modules/.pnpm/@web3-storage+data-segment@5.3.0/node_modules/@web3-storage/data-segment/src/fr32.js", "../../../../node_modules/.pnpm/@web3-storage+data-segment@5.3.0/node_modules/@web3-storage/data-segment/src/uint64.js", "../../../../node_modules/.pnpm/@web3-storage+data-segment@5.3.0/node_modules/@web3-storage/data-segment/src/piece/size/padded.js", "../../../../node_modules/.pnpm/@web3-storage+data-segment@5.3.0/node_modules/@web3-storage/data-segment/src/piece/size/unpadded.js", "../../../../node_modules/.pnpm/@web3-storage+data-segment@5.3.0/node_modules/@web3-storage/data-segment/src/piece/size/expanded.js", "../../../../node_modules/.pnpm/@web3-storage+data-segment@5.3.0/node_modules/@web3-storage/data-segment/src/digest.js", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/hashes/hasher.ts", "../../../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.4/node_modules/@web3-storage/filecoin-client/src/storefront.js", "../../../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/delegation.js", "../../../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/utf8.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/varint.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/vendor/varint.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bytes.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/digest.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/vendor/base-x.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base58.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base32.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/cid.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/link.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/identity.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/hasher.js", "../../../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/did.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/codecs/raw.js", "../../../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/signature.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base64.js", "../../../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/schema.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/json/encode.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/json/decode.js", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base64.ts", "../../../../node_modules/.pnpm/@ipld+dag-json@10.2.2/node_modules/@ipld/dag-json/src/index.js", "../../../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/formatter.js", "../../../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/view.js", "../../../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/codec/cbor.js", "../../../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/parser.js", "../../../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/codec/jwt.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/sha2-browser.js", "../../../../node_modules/.pnpm/@ipld+dag-ucan@3.4.0/node_modules/@ipld/dag-ucan/src/lib.js", "../../../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/cbor.js", "../../../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/dag.js", "../../../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/car.js", "../../../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/decoder-common.js", "../../../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/header-validator.js", "../../../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-decoder.js", "../../../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-reader-browser.js", "../../../../node_modules/.pnpm/cborg@4.2.4/node_modules/cborg/lib/length.js", "../../../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/buffer-writer.js", "../../../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema.js", "../../../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/uri.js", "../../../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/result.js", "../../../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/schema.js", "../../../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/link.js", "../../../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/did.js", "../../../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/schema/text.js", "../../../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/invocation.js", "../../../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/message.js", "../../../../node_modules/.pnpm/@ucanto+core@10.0.1/node_modules/@ucanto/core/src/receipt.js", "../../../../node_modules/.pnpm/@ucanto+client@9.0.1/node_modules/@ucanto/client/src/connection.js", "../../../../node_modules/.pnpm/@ucanto+client@9.0.1/node_modules/@ucanto/client/src/lib.js", "../../../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/car.js", "../../../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/car/request.js", "../../../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/car/response.js", "../../../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/codec.js", "../../../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/http.js", "../../../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/utf8.js", "../../../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/legacy/response.js", "../../../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/legacy/request.js", "../../../../node_modules/.pnpm/@ucanto+transport@9.1.1/node_modules/@ucanto/transport/src/legacy.js", "../../../../node_modules/.pnpm/@ucanto+validator@9.0.2/node_modules/@ucanto/validator/src/util.js", "../../../../node_modules/.pnpm/@ucanto+validator@9.0.2/node_modules/@ucanto/validator/src/error.js", "../../../../node_modules/.pnpm/@ucanto+validator@9.0.2/node_modules/@ucanto/validator/src/capability.js", "../../../../node_modules/.pnpm/@web3-storage+capabilities@17.3.0/node_modules/@web3-storage/capabilities/src/filecoin/lib.js", "../../../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/src/equals.ts", "../../../../node_modules/.pnpm/@web3-storage+capabilities@17.3.0/node_modules/@web3-storage/capabilities/src/utils.js", "../../../../node_modules/.pnpm/@web3-storage+capabilities@17.3.0/node_modules/@web3-storage/capabilities/src/filecoin/storefront.js", "../../../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.4/node_modules/@web3-storage/filecoin-client/src/service.js", "../../../../node_modules/.pnpm/@web3-storage+capabilities@17.3.0/node_modules/@web3-storage/capabilities/src/filecoin/aggregator.js", "../../../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.4/node_modules/@web3-storage/filecoin-client/src/aggregator.js", "../../../../node_modules/.pnpm/@web3-storage+capabilities@17.3.0/node_modules/@web3-storage/capabilities/src/filecoin/dealer.js", "../../../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.4/node_modules/@web3-storage/filecoin-client/src/dealer.js", "../../../../node_modules/.pnpm/@web3-storage+capabilities@17.3.0/node_modules/@web3-storage/capabilities/src/filecoin/deal-tracker.js", "../../../../node_modules/.pnpm/@web3-storage+filecoin-client@3.3.4/node_modules/@web3-storage/filecoin-client/src/deal-tracker.js", "../../../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/vendor/base-x.js", "../../../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bytes.js", "../../../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base.js", "../../../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base32.js", "../../../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/bases/base58.js", "../../../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/vendor/varint.js", "../../../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/varint.js", "../../../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/digest.js", "../../../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/cid.js", "../../../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/link.js", "../../../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/codecs/raw.js", "../../../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/hasher.js", "../../../../node_modules/.pnpm/multiformats@12.1.3/node_modules/multiformats/src/hashes/sha2-browser.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/store.js", "../../../../node_modules/.pnpm/@web3-storage+capabilities@17.3.0/node_modules/@web3-storage/capabilities/src/store.js", "../../../../node_modules/.pnpm/p-retry@5.1.2/node_modules/p-retry/index.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/service.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/blob/index.js", "../../../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/ed25519.js", "../../../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/ed25519/signer.js", "../../../../node_modules/.pnpm/@noble+ed25519@1.7.3/node_modules/@noble/ed25519/lib/esm/index.js", "../../../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/ed25519/verifier.js", "../../../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/verifier.js", "../../../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/signer.js", "../../../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa.js", "../../../../node_modules/.pnpm/one-webcrypto@1.0.3/node_modules/one-webcrypto/browser.mjs", "../../../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/multiformat.js", "../../../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/asn1.js", "../../../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/spki.js", "../../../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/pkcs8.js", "../../../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/public-key.js", "../../../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/rsa/private-key.js", "../../../../node_modules/.pnpm/@ucanto+principal@9.0.0/node_modules/@ucanto/principal/src/lib.js", "../../../../node_modules/.pnpm/@web3-storage+capabilities@17.3.0/node_modules/@web3-storage/capabilities/src/ucan.js", "../../../../node_modules/.pnpm/@web3-storage+capabilities@17.3.0/node_modules/@web3-storage/capabilities/src/blob.js", "../../../../node_modules/.pnpm/@web3-storage+capabilities@17.3.0/node_modules/@web3-storage/capabilities/src/web3.storage/blob.js", "../../../../node_modules/.pnpm/@web3-storage+capabilities@17.3.0/node_modules/@web3-storage/capabilities/src/http.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/receipts.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/blob/add.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/blob/get.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/blob/list.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/blob/remove.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/index/index.js", "../../../../node_modules/.pnpm/@web3-storage+capabilities@17.3.0/node_modules/@web3-storage/capabilities/src/index/index.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/index/add.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/upload/index.js", "../../../../node_modules/.pnpm/@web3-storage+capabilities@17.3.0/node_modules/@web3-storage/capabilities/src/upload.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/upload/add.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/upload/get.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/upload/list.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/upload/remove.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/unixfs.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/codec.js", "../../../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/pb-decode.js", "../../../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/pb-encode.js", "../../../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/util.js", "../../../../node_modules/.pnpm/@ipld+dag-pb@4.1.2/node_modules/@ipld/dag-pb/src/index.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/gen/unixfs.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/unixfs.js", "../../../../node_modules/.pnpm/actor@2.3.1/node_modules/actor/src/lib.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/chunker/indexed.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/chunker/buffer.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/writer/util.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/chunker.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/layout/queue.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/writer.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/chunker/fixed.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file/layout/balanced.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/file.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/directory.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/Uint32.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/api.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/Uint32.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/node.js", "../../../../node_modules/.pnpm/@multiformats+murmur3@2.1.8/node_modules/@multiformats/murmur3/src/index.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/Uint8Array.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/Uint8Array.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/lib.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/InfiniteUint8Array.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/unixfs.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/block.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/sharded-directory.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.2.0/node_modules/@ipld/unixfs/src/lib.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/car.js", "../../../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/indexed-reader.js", "../../../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/decoder.js", "../../../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/iterator.js", "../../../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/encoder.js", "../../../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/iterator-channel.js", "../../../../node_modules/.pnpm/@ipld+car@5.3.2/node_modules/@ipld/car/src/writer-browser.js", "../../../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/src/alloc.ts", "../../../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/src/compare.ts", "../../../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/src/concat.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base10.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base16.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base2.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base256emoji.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/base8.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/bases/identity.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/codecs/json.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/hashes/identity.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/hashes/sha2-browser.ts", "../../../../node_modules/.pnpm/multiformats@13.3.0/node_modules/multiformats/src/basics.ts", "../../../../node_modules/.pnpm/uint8arrays@5.1.0/node_modules/uint8arrays/src/util/bases.ts", "../../../../node_modules/.pnpm/@web3-storage+blob-index@1.0.4/node_modules/@web3-storage/blob-index/src/digest-map.js", "../../../../node_modules/.pnpm/@web3-storage+blob-index@1.0.4/node_modules/@web3-storage/blob-index/src/sharded-dag-index.js", "../../../../node_modules/.pnpm/uint8arraylist@2.4.8/node_modules/uint8arraylist/src/index.ts", "../../../../node_modules/.pnpm/carstream@2.2.0/node_modules/carstream/src/varint.js", "../../../../node_modules/.pnpm/carstream@2.2.0/node_modules/carstream/src/reader.js", "../../../../node_modules/.pnpm/carstream@2.2.0/node_modules/carstream/src/writer.js", "../../../../node_modules/.pnpm/@web3-storage+blob-index@1.0.4/node_modules/@web3-storage/blob-index/src/util.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/sharding.js", "../../../../node_modules/.pnpm/@web3-storage+upload-client@17.0.1/node_modules/@web3-storage/upload-client/src/index.js"],
  "sourcesContent": ["function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n", "var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n", "module.exports = require('./lib/retry');", "\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n", "\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n", "\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n", "\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n", "\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n", "\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n", "\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n", "\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n", "\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n", "\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n", "// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n", "/* jshint -W086: true */\n// +----------------------------------------------------------------------+\n// | murmurHash3js.js v3.0.1 // https://github.com/pid/murmurHash3js\n// | A javascript implementation of MurmurHash3's x86 hashing algorithms. |\n// |----------------------------------------------------------------------|\n// | Copyright (c) 2012-2015 Karan Lyons                                       |\n// | https://github.com/karanlyons/murmurHash3.js/blob/c1778f75792abef7bdd74bc85d2d4e1a3d25cfe9/murmurHash3.js |\n// | Freely distributable under the MIT license.                          |\n// +----------------------------------------------------------------------+\n\n;(function (root, undefined) {\n    'use strict';\n\n    // Create a local object that'll be exported or referenced globally.\n    var library = {\n        'version': '3.0.0',\n        'x86': {},\n        'x64': {},\n        'inputValidation': true\n    };\n\n    // PRIVATE FUNCTIONS\n    // -----------------\n\n    function _validBytes(bytes) {\n        // check the input is an array or a typed array\n        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {\n            return false;\n        }\n\n        // check all bytes are actually bytes\n        for (var i = 0; i < bytes.length; i++) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _x86Multiply(m, n) {\n        //\n        // Given two 32bit ints, returns the two multiplied together as a\n        // 32bit int.\n        //\n\n        return ((m & 0xffff) * n) + ((((m >>> 16) * n) & 0xffff) << 16);\n    }\n\n    function _x86Rotl(m, n) {\n        //\n        // Given a 32bit int and an int representing a number of bit positions,\n        // returns the 32bit int rotated left by that number of positions.\n        //\n\n        return (m << n) | (m >>> (32 - n));\n    }\n\n    function _x86Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x86 mix of that block.\n        //\n\n        h ^= h >>> 16;\n        h = _x86Multiply(h, 0x85ebca6b);\n        h ^= h >>> 13;\n        h = _x86Multiply(h, 0xc2b2ae35);\n        h ^= h >>> 16;\n\n        return h;\n    }\n\n    function _x64Add(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // added together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] + n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] + n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] + n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += m[0] + n[0];\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Multiply(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // multiplied together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] * n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] * n[3];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[2] += m[3] * n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] * n[3];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[2] * n[2];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[3] * n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += (m[0] * n[3]) + (m[1] * n[2]) + (m[2] * n[1]) + (m[3] * n[0]);\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Rotl(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) rotated left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 32) {\n            return [m[1], m[0]];\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), (m[1] << n) | (m[0] >>> (32 - n))];\n        } else {\n            n -= 32;\n            return [(m[1] << n) | (m[0] >>> (32 - n)), (m[0] << n) | (m[1] >>> (32 - n))];\n        }\n    }\n\n    function _x64LeftShift(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) shifted left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 0) {\n            return m;\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), m[1] << n];\n        } else {\n            return [m[1] << (n - 32), 0];\n        }\n    }\n\n    function _x64Xor(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // xored together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        return [m[0] ^ n[0], m[1] ^ n[1]];\n    }\n\n    function _x64Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x64 mix of that block.\n        // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the\n        // only place where we need to right shift 64bit ints.)\n        //\n\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xff51afd7, 0xed558ccd]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xc4ceb9fe, 0x1a85ec53]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n\n        return h;\n    }\n\n    // PUBLIC FUNCTIONS\n    // ----------------\n\n    library.x86.hash32 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 32 bit hash\n        // using the x86 flavor of MurmurHash3, as an unsigned int.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 4;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n\n        var k1 = 0;\n\n        var c1 = 0xcc9e2d51;\n        var c2 = 0x1b873593;\n\n        for (var i = 0; i < blocks; i = i + 4) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n\n            h1 ^= k1;\n            h1 = _x86Rotl(h1, 13);\n            h1 = _x86Multiply(h1, 5) + 0xe6546b64;\n        }\n\n        k1 = 0;\n\n        switch (remainder) {\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h1 = _x86Fmix(h1);\n\n        return h1 >>> 0;\n    };\n\n    library.x86.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x86 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n\n        seed = seed || 0;\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n        var h2 = seed;\n        var h3 = seed;\n        var h4 = seed;\n\n        var k1 = 0;\n        var k2 = 0;\n        var k3 = 0;\n        var k4 = 0;\n\n        var c1 = 0x239b961b;\n        var c2 = 0xab0e9789;\n        var c3 = 0x38b34ae5;\n        var c4 = 0xa1e38b93;\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n            k2 = (bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24);\n            k3 = (bytes[i + 8]) | (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24);\n            k4 = (bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n            h1 ^= k1;\n\n            h1 = _x86Rotl(h1, 19);\n            h1 += h2;\n            h1 = _x86Multiply(h1, 5) + 0x561ccd1b;\n\n            k2 = _x86Multiply(k2, c2);\n            k2 = _x86Rotl(k2, 16);\n            k2 = _x86Multiply(k2, c3);\n            h2 ^= k2;\n\n            h2 = _x86Rotl(h2, 17);\n            h2 += h3;\n            h2 = _x86Multiply(h2, 5) + 0x0bcaa747;\n\n            k3 = _x86Multiply(k3, c3);\n            k3 = _x86Rotl(k3, 17);\n            k3 = _x86Multiply(k3, c4);\n            h3 ^= k3;\n\n            h3 = _x86Rotl(h3, 15);\n            h3 += h4;\n            h3 = _x86Multiply(h3, 5) + 0x96cd1c35;\n\n            k4 = _x86Multiply(k4, c4);\n            k4 = _x86Rotl(k4, 18);\n            k4 = _x86Multiply(k4, c1);\n            h4 ^= k4;\n\n            h4 = _x86Rotl(h4, 13);\n            h4 += h1;\n            h4 = _x86Multiply(h4, 5) + 0x32ac3b17;\n        }\n\n        k1 = 0;\n        k2 = 0;\n        k3 = 0;\n        k4 = 0;\n\n        switch (remainder) {\n            case 15:\n                k4 ^= bytes[i + 14] << 16;\n\n            case 14:\n                k4 ^= bytes[i + 13] << 8;\n\n            case 13:\n                k4 ^= bytes[i + 12];\n                k4 = _x86Multiply(k4, c4);\n                k4 = _x86Rotl(k4, 18);\n                k4 = _x86Multiply(k4, c1);\n                h4 ^= k4;\n\n            case 12:\n                k3 ^= bytes[i + 11] << 24;\n\n            case 11:\n                k3 ^= bytes[i + 10] << 16;\n\n            case 10:\n                k3 ^= bytes[i + 9] << 8;\n\n            case 9:\n                k3 ^= bytes[i + 8];\n                k3 = _x86Multiply(k3, c3);\n                k3 = _x86Rotl(k3, 17);\n                k3 = _x86Multiply(k3, c4);\n                h3 ^= k3;\n\n            case 8:\n                k2 ^= bytes[i + 7] << 24;\n\n            case 7:\n                k2 ^= bytes[i + 6] << 16;\n\n            case 6:\n                k2 ^= bytes[i + 5] << 8;\n\n            case 5:\n                k2 ^= bytes[i + 4];\n                k2 = _x86Multiply(k2, c2);\n                k2 = _x86Rotl(k2, 16);\n                k2 = _x86Multiply(k2, c3);\n                h2 ^= k2;\n\n            case 4:\n                k1 ^= bytes[i + 3] << 24;\n\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h2 ^= bytes.length;\n        h3 ^= bytes.length;\n        h4 ^= bytes.length;\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        h1 = _x86Fmix(h1);\n        h2 = _x86Fmix(h2);\n        h3 = _x86Fmix(h3);\n        h4 = _x86Fmix(h4);\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        return (\"00000000\" + (h1 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h3 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h4 >>> 0).toString(16)).slice(-8);\n    };\n\n    library.x64.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x64 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = [0, seed];\n        var h2 = [0, seed];\n\n        var k1 = [0, 0];\n        var k2 = [0, 0];\n\n        var c1 = [0x87c37b91, 0x114253d5];\n        var c2 = [0x4cf5ad43, 0x2745937f];\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = [(bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24), (bytes[i]) |\n                (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24)];\n            k2 = [(bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24), (bytes[i + 8]) |\n                (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24)];\n\n            k1 = _x64Multiply(k1, c1);\n            k1 = _x64Rotl(k1, 31);\n            k1 = _x64Multiply(k1, c2);\n            h1 = _x64Xor(h1, k1);\n\n            h1 = _x64Rotl(h1, 27);\n            h1 = _x64Add(h1, h2);\n            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 0x52dce729]);\n\n            k2 = _x64Multiply(k2, c2);\n            k2 = _x64Rotl(k2, 33);\n            k2 = _x64Multiply(k2, c1);\n            h2 = _x64Xor(h2, k2);\n\n            h2 = _x64Rotl(h2, 31);\n            h2 = _x64Add(h2, h1);\n            h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 0x38495ab5]);\n        }\n\n        k1 = [0, 0];\n        k2 = [0, 0];\n\n        switch (remainder) {\n            case 15:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 14]], 48));\n\n            case 14:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 13]], 40));\n\n            case 13:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 12]], 32));\n\n            case 12:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 11]], 24));\n\n            case 11:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 10]], 16));\n\n            case 10:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 9]], 8));\n\n            case 9:\n                k2 = _x64Xor(k2, [0, bytes[i + 8]]);\n                k2 = _x64Multiply(k2, c2);\n                k2 = _x64Rotl(k2, 33);\n                k2 = _x64Multiply(k2, c1);\n                h2 = _x64Xor(h2, k2);\n\n            case 8:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 7]], 56));\n\n            case 7:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 6]], 48));\n\n            case 6:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 5]], 40));\n\n            case 5:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 4]], 32));\n\n            case 4:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 3]], 24));\n\n            case 3:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 2]], 16));\n\n            case 2:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 1]], 8));\n\n            case 1:\n                k1 = _x64Xor(k1, [0, bytes[i]]);\n                k1 = _x64Multiply(k1, c1);\n                k1 = _x64Rotl(k1, 31);\n                k1 = _x64Multiply(k1, c2);\n                h1 = _x64Xor(h1, k1);\n        }\n\n        h1 = _x64Xor(h1, [0, bytes.length]);\n        h2 = _x64Xor(h2, [0, bytes.length]);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        h1 = _x64Fmix(h1);\n        h2 = _x64Fmix(h2);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        return (\"00000000\" + (h1[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h1[1] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[1] >>> 0).toString(16)).slice(-8);\n    };\n\n    // INITIALIZATION\n    // --------------\n\n    // Export murmurHash3 for CommonJS, either as an AMD module or just as part\n    // of the global object.\n    if (typeof exports !== 'undefined') {\n\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = library;\n        }\n\n        exports.murmurHash3 = library;\n\n    } else if (typeof define === 'function' && define.amd) {\n\n        define([], function () {\n            return library;\n        });\n    } else {\n\n        // Use murmurHash3.noConflict to restore `murmurHash3` back to its\n        // original value. Returns a reference to the library object, to allow\n        // it to be used under a different name.\n        library._murmurHash3 = root.murmurHash3;\n\n        library.noConflict = function () {\n            root.murmurHash3 = library._murmurHash3;\n            library._murmurHash3 = undefined;\n            library.noConflict = undefined;\n\n            return library;\n        };\n\n        root.murmurHash3 = library;\n    }\n})(this);\n", "module.exports = require('./lib/murmurHash3js');\n", "import * as API from './api.js'\nimport {\n  IN_BYTES_PER_QUAD,\n  IN_BITS_FR,\n  OUT_BITS_FR,\n  MIN_PAYLOAD_SIZE,\n} from './constant.js'\nimport * as ZeroPad from './zero-comm.js'\nimport { computeNode } from './proof.js'\nimport { split } from './piece/tree.js'\nimport { pad } from './fr32.js'\nimport { fromHeight as piceSizeFromHeight } from './piece/size/expanded.js'\nimport { Unpadded } from './piece/size.js'\nimport * as Digest from './digest.js'\nimport { varint } from 'multiformats'\n\nexport { Digest }\n\n/**\n * @see https://github.com/multiformats/multicodec/pull/331/files\n */\nexport const name = /** @type {const} */ (\n  'fr32-sha2-256-trunc254-padded-binary-tree'\n)\n\n/**\n * @type {API.MulticodecCode<0x1011, typeof name>}\n * @see https://github.com/multiformats/multicodec/pull/331/files\n */\nexport const code = 0x1011\n\n/**\n * Since first byte in the digest is the tree height, the maximum height is 255.\n *\n * @type {255}\n */\nexport const MAX_HEIGHT = 255\n\n/**\n * Max payload is determined by the maximum height of the tree, which is limited\n * by the int we could store in one byte. We calculate the max piece size\n * and derive max payload size that can would produce it after FR32 padding.\n */\nexport const MAX_PAYLOAD_SIZE =\n  (piceSizeFromHeight(MAX_HEIGHT) * BigInt(IN_BITS_FR)) / BigInt(OUT_BITS_FR)\n\n/**\n * Computes the digest of the given payload.\n *\n * @param {Uint8Array} payload\n * @returns {API.PieceDigest}\n */\nexport const digest = (payload) => {\n  const hasher = new Hasher()\n  hasher.write(payload)\n  return hasher.digest()\n}\n\n/**\n * Creates a streaming hasher that can be used to consumer larger streams\n * of data than it would be practical to load into memory all at once.\n *\n * @returns {API.StreamingHasher<typeof code, number, API.PieceDigest>}\n */\nexport const create = () => new Hasher()\n\n/**\n * @typedef {[API.MerkleTreeNode[], ...API.MerkleTreeNode[][]]} Layers\n *\n * @implements {API.StreamingHasher<typeof code, number, API.PieceDigest>}\n */\nclass Hasher {\n  constructor() {\n    /**\n     * The number of bytes consumed by the hasher.\n     *\n     * @private\n     */\n    this.bytesWritten = 0n\n\n    /**\n     * This buffer is used to accumulate bytes until we have enough to fill a\n     * quad.\n     *\n     * \u26A0\uFE0F Note that you should never read bytes past {@link offset} as those\n     * are considered dirty and may contain garbage.\n     *\n     * @protected\n     */\n    this.buffer = new Uint8Array(IN_BYTES_PER_QUAD)\n\n    /**\n     * Offset is the number of bytes in we have written into the buffer. If\n     * offset is 0 it means that the buffer is effectively empty. When `offset`\n     * is equal to `this.buffer.length` we have a quad that can be processed.\n     *\n     * @protected\n     */\n    this.offset = 0\n\n    /**\n     * The layers of the tree. Each layer will contain either 0 or 1 nodes\n     * between writes. When we write into a hasher, if we have enough nodes\n     * leaves will be created and pushed into the `layers[0]` array, after\n     * which we flush and combine every two leafs into a node which is moved\n     * to the next layer. This process is repeated until we reach the top\n     * layer, leaving each layer either empty or with a single node.\n     *\n     * @type {Layers}\n     */\n    this.layers = [[]]\n  }\n\n  /**\n   * Return the total number of bytes written into the hasher. Calling\n   * {@link reset} will reset the hasher and the count will be reset to 0.\n   *\n   * @returns {bigint}\n   */\n  count() {\n    return this.bytesWritten\n  }\n\n  /**\n   * Computes the digest of all the data that has been written into this hasher.\n   * This method does not have side-effects, meaning that you can continue\n   * writing and call this method again to compute digest of all the data\n   * written from the very beginning.\n   */\n  digest() {\n    const bytes = new Uint8Array(Digest.MAX_SIZE)\n    const count = this.digestInto(bytes, 0, true)\n    return Digest.fromBytes(bytes.subarray(0, count))\n  }\n\n  /**\n   * Computes the digest and writes into the given buffer. You can provide\n   * optional `byteOffset` to write digest at that offset in the buffer. By\n   * default the multihash prefix will be written into the buffer, but you can\n   * opt-out by passing `false` as the `asMultihash` argument.\n   *\n   * @param {Uint8Array} output\n   * @param {number} [byteOffset]\n   * @param {boolean} asMultihash\n   */\n  digestInto(output, byteOffset = 0, asMultihash = true) {\n    const { buffer, layers, offset, bytesWritten } = this\n\n    // We do not want to mutate the layers, so we create a shallow copy of it\n    // which we will use to compute the root.\n    let [leaves, ...nodes] = layers\n\n    // If we have some bytes in the buffer we fill rest with zeros and compute\n    // leaves from it. Note that it is safe to mutate the buffer here as bytes\n    // past `offset` are considered dirty and should not be read.\n    if (offset > 0 || bytesWritten === 0n) {\n      leaves = [...leaves, ...split(pad(buffer.fill(0, offset)))]\n    }\n\n    const tree = build([leaves, ...nodes])\n    const height = tree.length - 1\n    const [root] = tree[height]\n    const padding = Number(Unpadded.toPadding(this.bytesWritten))\n\n    const paddingLength = varint.encodingLength(\n      /** @type {number & bigint} */ (padding)\n    )\n\n    let endOffset = byteOffset\n    // Write the multihash prefix if requested\n    if (asMultihash) {\n      varint.encodeTo(code, output, endOffset)\n      endOffset += Digest.TAG_SIZE\n\n      const size = paddingLength + Digest.HEIGHT_SIZE + Digest.ROOT_SIZE\n      const sizeLength = varint.encodingLength(size)\n      varint.encodeTo(size, output, endOffset)\n      endOffset += sizeLength\n    }\n\n    varint.encodeTo(padding, output, endOffset)\n    endOffset += paddingLength\n\n    // Write the tree height as the first byte of the digest\n    output[endOffset] = height\n    endOffset += 1\n\n    // Write the root as the remaining 32 bytes of the digest\n    output.set(root, endOffset)\n    endOffset += root.length\n\n    // Return number of bytes written\n    return endOffset - byteOffset\n  }\n  /**\n   * @param {Uint8Array} bytes\n   */\n  write(bytes) {\n    const { buffer, offset, layers } = this\n    const leaves = layers[0]\n    const { length } = bytes\n    // If we got no bytes there is nothing to do here\n    if (length === 0) {\n      return this\n      /* c8 ignore next 5 */\n    } else if (this.bytesWritten + BigInt(length) > MAX_PAYLOAD_SIZE) {\n      throw new RangeError(\n        `Writing ${length} bytes exceeds max payload size of ${MAX_PAYLOAD_SIZE}`\n      )\n    }\n    // If we do not have enough bytes to form a quad, just add append new bytes\n    // to the buffer and return.\n    else if (offset + length < buffer.length) {\n      buffer.set(bytes, offset)\n      this.offset += length\n      this.bytesWritten += BigInt(length)\n      return this\n    }\n    // Otherwise we first fill the buffer to form a quad and create some leaves.\n    // Then we slice remaining bytes into quads sized chunks and create leaves\n    // from them. If we have some bytes left we copy them into the buffer and\n    // flush to combining node pairs and propagate them up the tree.\n    else {\n      // Number of bytes required to fill the quad buffer\n      const bytesRequired = buffer.length - offset\n      // copy required bytes into the buffer and turn them into leaves\n      // which we push into the leaf layer.\n      buffer.set(bytes.subarray(0, bytesRequired), offset)\n      leaves.push(...split(pad(buffer)))\n\n      // Now we slice remaining bytes into quads, create leaves from them\n      // and push them into the leaf layer.\n      let readOffset = bytesRequired\n      while (readOffset + IN_BYTES_PER_QUAD < length) {\n        const quad = bytes.subarray(readOffset, readOffset + IN_BYTES_PER_QUAD)\n        leaves.push(...split(pad(quad)))\n        readOffset += IN_BYTES_PER_QUAD\n      }\n\n      // Whatever byte were left are copied into the buffer and we update\n      // the offset to reflect that.\n      this.buffer.set(bytes.subarray(readOffset), 0)\n      this.offset = length - readOffset\n\n      // We also update the total number of bytes written.\n      this.bytesWritten += BigInt(length)\n\n      // Now prune the layers to propagate all the new leaves up the tree.\n      prune(this.layers)\n\n      return this\n    }\n  }\n\n  /**\n   * Resets this hasher to its initial state so it could be recycled as new\n   * instance.\n   */\n  reset() {\n    this.offset = 0\n    this.bytesWritten = 0n\n    this.layers.length = 1\n    this.layers[0].length = 0\n    return this\n  }\n\n  /* c8 ignore next 3 */\n  dispose() {\n    this.reset()\n  }\n  get code() {\n    return code\n  }\n  get name() {\n    return name\n  }\n}\n\n/**\n * Prunes layers by combining node pairs into nodes in the next layer and\n * removing them from the layer that they were in. After pruning each layer\n * will end up with at most one node. New layers may be created in the process\n * when nodes from the top layer are combined.\n *\n * @param {Layers} layers\n */\nconst prune = (layers) => flush(layers, false)\n\n/**\n * Flushes all the nodes in layers by combining node pairs into nodes in the\n * next layer. Layers with only one node are combined with zero padded nodes\n * (corresponding to the level of the layer). Unlike {@link prune} combined\n * nodes are not removed and layers are copied instead of been mutated.\n *\n * @param {Layers} layers\n */\nconst build = (layers) => flush([...layers], true)\n\n/**\n * @param {Layers} layers\n * @param {boolean} build\n * @returns {Layers}\n */\nconst flush = (layers, build) => {\n  // Note it is important that we do not mutate any of the layers otherwise\n  // writing more data into the hasher and computing the digest will produce\n  // wrong results.\n  let level = 0\n  // We will walk up the tree until we reach the top layer. However, we may end\n  // up with creating new layers in the process, so we will keep track of the\n  while (level < layers.length) {\n    let next = layers[level + 1]\n    const layer = layers[level]\n\n    // If we have the odd number of nodes and we have not reached the top\n    // layer, we push a zero padding node corresponding to the current level.\n    if (build && layer.length % 2 > 0 && next) {\n      layer.push(ZeroPad.fromLevel(level))\n    }\n\n    level += 1\n\n    // If we have 0 nodes in the current layer we just move to the next one.\n\n    // If we have a next layer and we are building  will combine nodes from the current layer\n    next = next ? (build ? [...next] : next) : []\n    let index = 0\n    // Note that we have checked that we have an even number of nodes so\n    // we will never end up with an extra node when consuming two at a time.\n    while (index + 1 < layer.length) {\n      const node = computeNode(layer[index], layer[index + 1])\n\n      // we proactively delete nodes in order to free up a memory used.\n      delete layer[index]\n      delete layer[index + 1]\n\n      next.push(node)\n      index += 2\n    }\n\n    if (next.length) {\n      layers[level] = next\n    }\n\n    // we remove nodes that we have combined from the current layer to reduce\n    // memory overhead and move to the next layer.\n    layer.splice(0, index)\n  }\n\n  return layers\n}\n", "/**\n * Number of bits per byte\n */\nconst BITS_PER_BYTE = 8\n\n/**\n * The number of Frs per Block.\n */\nexport const FRS_PER_QUAD = 4\n\nexport const LEAFS_PER_QUAD = /** @type {4n} */ (BigInt(FRS_PER_QUAD))\n\n/**\n * The amount of bits in an Fr when not padded.\n */\nexport const IN_BITS_FR = 254\n/**\n * The amount of bits in an Fr when padded.\n */\nexport const OUT_BITS_FR = 256\n\nexport const IN_BYTES_PER_QUAD =\n  /** @type {127} */\n  ((FRS_PER_QUAD * IN_BITS_FR) / BITS_PER_BYTE)\n\nexport const OUT_BYTES_PER_QUAD =\n  /** @type {128} */\n  ((FRS_PER_QUAD * OUT_BITS_FR) / BITS_PER_BYTE)\n\nexport const PADDED_BYTES_PER_QUAD = /** @type {127n} */ (\n  BigInt(IN_BYTES_PER_QUAD)\n)\n\nexport const EXPANDED_BYTES_PER_QUAD = /** @type {128n} */ (\n  BigInt(OUT_BYTES_PER_QUAD)\n)\n\nexport const BYTES_PER_FR =\n  /** @type {32} */\n  OUT_BYTES_PER_QUAD / FRS_PER_QUAD\n\nexport const FR_RATIO = IN_BITS_FR / OUT_BITS_FR\n\n/**\n * Size of a node in the merkle tree.\n */\nexport const NODE_SIZE =\n  /** @type {32} */\n  (OUT_BYTES_PER_QUAD / FRS_PER_QUAD)\n\nexport const EXPANDED_BYTES_PER_NODE = /** @type {32n} */ (BigInt(NODE_SIZE))\n\n/**\n * The smallest amount of data for which FR32 padding has a defined result.\n * Silently upgrading 2 leaves to 4 would break the symmetry so we require\n * an extra byte and the rest can be 0 padded to expand to 4 leaves.\n */\nexport const MIN_PAYLOAD_SIZE = 2 * NODE_SIZE + 1\n", "import * as API from './api.js'\nimport { NODE_SIZE as Size } from './constant.js'\n\nexport { Size }\n\n/**\n * @param {number[]} bytes\n */\nexport const of = (...bytes) => from(bytes)\n\n/**\n * @param {Iterable<number>} bytes\n * @returns {API.MerkleTreeNode}\n */\nexport const from = (bytes) => {\n  /* c8 ignore next 7 */\n  if (bytes instanceof Uint8Array) {\n    if (bytes.length > Size) {\n      return bytes.subarray(0, Size)\n    } else if (bytes.length == Size) {\n      return bytes\n    }\n  }\n\n  const node = new Uint8Array(Size)\n  node.set([...bytes])\n  return node\n}\n\nexport const empty = () => EMPTY\n\nconst EMPTY = from(new Uint8Array(Size).fill(0))\nObject.freeze(EMPTY.buffer)\n", "export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n", "import * as API from '../api.js'\nimport * as SHA256 from 'sync-multihash-sha2/sha256'\nexport * from 'sync-multihash-sha2/sha256'\n\n/**\n * @type {API.MulticodecCode<typeof SHA256.code, typeof SHA256.name>}\n */\nexport const code = SHA256.code\n", "/* c8 ignore next */\nimport { sha256 } from '@noble/hashes/sha256'\nimport { name, size, code, prefix, Digest } from './digest.js'\nexport { name, size, code }\n\n/**\n * @param {Uint8Array} payload\n * @returns {import('multiformats').MultihashDigest<typeof code>}\n */\nexport const digest = (payload) => {\n  const digest = new Uint8Array(prefix.length + size)\n  digest.set(prefix, 0)\n  digest.set(sha256(payload), prefix.length)\n\n  return new Digest(digest)\n}\n", "export const name = 'sha2-256'\nexport const code = 0x12\nexport const size = 32\n\nexport const prefix = new Uint8Array([18, 32])\n\nexport class Digest {\n  /**\n   * @param {Uint8Array} bytes\n   */\n  constructor(bytes) {\n    /** @type {typeof code} */\n    this.code = code\n    /** @type {typeof name} */\n    this.name = name\n    this.bytes = bytes\n    /** @type {typeof size} */\n    this.size = size\n    this.digest = bytes.subarray(2)\n  }\n}\n", "// This is an unfortunate replacement for @sindresorhus/is that we need to\n// re-implement for performance purposes. In particular the is.observable()\n// check is expensive, and unnecessary for our purposes. The values returned\n// are compatible with @sindresorhus/is, however.\n\nconst typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n]\n\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n]\n\n/**\n * @param {any} value\n * @returns {string}\n */\nexport function is (value) {\n  if (value === null) {\n    return 'null'\n  }\n  if (value === undefined) {\n    return 'undefined'\n  }\n  if (value === true || value === false) {\n    return 'boolean'\n  }\n  const typeOf = typeof value\n  if (typeofs.includes(typeOf)) {\n    return typeOf\n  }\n  /* c8 ignore next 4 */\n  // not going to bother testing this, it's not going to be valid anyway\n  if (typeOf === 'function') {\n    return 'Function'\n  }\n  if (Array.isArray(value)) {\n    return 'Array'\n  }\n  if (isBuffer(value)) {\n    return 'Buffer'\n  }\n  const objectType = getObjectType(value)\n  if (objectType) {\n    return objectType\n  }\n  /* c8 ignore next */\n  return 'Object'\n}\n\n/**\n * @param {any} value\n * @returns {boolean}\n */\nfunction isBuffer (value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value)\n}\n\n/**\n * @param {any} value\n * @returns {string|undefined}\n */\nfunction getObjectType (value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1)\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName\n  }\n  /* c8 ignore next */\n  return undefined\n}\n", "class Type {\n  /**\n   * @param {number} major\n   * @param {string} name\n   * @param {boolean} terminal\n   */\n  constructor (major, name, terminal) {\n    this.major = major\n    this.majorEncoded = major << 5\n    this.name = name\n    this.terminal = terminal\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Type[${this.major}].${this.name}`\n  }\n\n  /**\n   * @param {Type} typ\n   * @returns {number}\n   */\n  compare (typ) {\n    /* c8 ignore next 1 */\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0\n  }\n}\n\n// convert to static fields when better supported\nType.uint = new Type(0, 'uint', true)\nType.negint = new Type(1, 'negint', true)\nType.bytes = new Type(2, 'bytes', true)\nType.string = new Type(3, 'string', true)\nType.array = new Type(4, 'array', false)\nType.map = new Type(5, 'map', false)\nType.tag = new Type(6, 'tag', false) // terminal?\nType.float = new Type(7, 'float', true)\nType.false = new Type(7, 'false', true)\nType.true = new Type(7, 'true', true)\nType.null = new Type(7, 'null', true)\nType.undefined = new Type(7, 'undefined', true)\nType.break = new Type(7, 'break', true)\n// Type.indefiniteLength = new Type(0, 'indefiniteLength', true)\n\nclass Token {\n  /**\n   * @param {Type} type\n   * @param {any} [value]\n   * @param {number} [encodedLength]\n   */\n  constructor (type, value, encodedLength) {\n    this.type = type\n    this.value = value\n    this.encodedLength = encodedLength\n    /** @type {Uint8Array|undefined} */\n    this.encodedBytes = undefined\n    /** @type {Uint8Array|undefined} */\n    this.byteValue = undefined\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Token[${this.type}].${this.value}`\n  }\n}\n\nexport { Type, Token }\n", "// Use Uint8Array directly in the browser, use Buffer in Node.js but don't\n// speak its name directly to avoid bundlers pulling in the `Buffer` polyfill\n\n// @ts-ignore\nexport const useBuffer = globalThis.process &&\n  // @ts-ignore\n  !globalThis.process.browser &&\n  // @ts-ignore\n  globalThis.Buffer &&\n  // @ts-ignore\n  typeof globalThis.Buffer.isBuffer === 'function'\n\nconst textDecoder = new TextDecoder()\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isBuffer (buf) {\n  // @ts-ignore\n  return useBuffer && globalThis.Buffer.isBuffer(buf)\n}\n\n/**\n * @param {Uint8Array|number[]} buf\n * @returns {Uint8Array}\n */\nexport function asU8A (buf) {\n  /* c8 ignore next */\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf)\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf\n}\n\nexport const toString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8')\n        : utf8Slice(bytes, start, end)\n    }\n  /* c8 ignore next 11 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? textDecoder.decode(bytes.subarray(start, end))\n        : utf8Slice(bytes, start, end)\n    }\n\nexport const fromString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(string)\n        : utf8ToBytes(string)\n    }\n  /* c8 ignore next 7 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string)\n    }\n\n/**\n * Buffer variant not fast enough for what we need\n * @param {number[]} arr\n * @returns {Uint8Array}\n */\nexport const fromArray = (arr) => {\n  return Uint8Array.from(arr)\n}\n\nexport const slice = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      if (isBuffer(bytes)) {\n        return new Uint8Array(bytes.subarray(start, end))\n      }\n      return bytes.slice(start, end)\n    }\n  /* c8 ignore next 9 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return bytes.slice(start, end)\n    }\n\nexport const concat = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      // might get a stray plain Array here\n      /* c8 ignore next 1 */\n      chunks = chunks.map((c) => c instanceof Uint8Array\n        ? c\n        // this case is occasionally missed during test runs so becomes coverage-flaky\n        /* c8 ignore next 4 */\n        : // eslint-disable-line operator-linebreak\n        // @ts-ignore\n        globalThis.Buffer.from(c))\n      // @ts-ignore\n      return asU8A(globalThis.Buffer.concat(chunks, length))\n    }\n  /* c8 ignore next 19 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      const out = new Uint8Array(length)\n      let off = 0\n      for (let b of chunks) {\n        if (off + b.length > out.length) {\n          // final chunk that's bigger than we need\n          b = b.subarray(0, out.length - off)\n        }\n        out.set(b, off)\n        off += b.length\n      }\n      return out\n    }\n\nexport const alloc = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      // we always write over the contents we expose so this should be safe\n      // @ts-ignore\n      return globalThis.Buffer.allocUnsafe(size)\n    }\n  /* c8 ignore next 8 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      return new Uint8Array(size)\n    }\n\nexport const toHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(toBytes(d)).toString('hex')\n    }\n  /* c8 ignore next 12 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore not smart enough to figure this out\n      return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '')\n    }\n\nexport const fromHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(hex, 'hex')\n    }\n  /* c8 ignore next 17 */\n  : // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      if (!hex.length) {\n        return new Uint8Array(0)\n      }\n      return new Uint8Array(hex.split('')\n        .map((/** @type {string} */ c, /** @type {number} */ i, /** @type {string[]} */ d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '')\n        .filter(Boolean)\n        .map((/** @type {string} */ e) => parseInt(e, 16)))\n    }\n\n/**\n * @param {Uint8Array|ArrayBuffer|ArrayBufferView} obj\n * @returns {Uint8Array}\n */\nfunction toBytes (obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj)\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength)\n  }\n  /* c8 ignore next */\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compare (b1, b2) {\n  /* c8 ignore next 5 */\n  if (isBuffer(b1) && isBuffer(b2)) {\n    // probably not possible to get here in the current API\n    // @ts-ignore Buffer\n    return b1.compare(b2)\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue\n    }\n    return b1[i] < b2[i] ? -1 : 1\n  } /* c8 ignore next 3 */\n  return 0\n}\n\n// The below code is taken from https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n// Licensed Apache-2.0.\n\n/**\n * @param {string} str\n * @returns {number[]}\n */\nfunction utf8ToBytes (str) {\n  const out = []\n  let p = 0\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i)\n    if (c < 128) {\n      out[p++] = c\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192\n      out[p++] = (c & 63) | 128\n    } else if (\n      ((c & 0xFC00) === 0xD800) && (i + 1) < str.length &&\n      ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF)\n      out[p++] = (c >> 18) | 240\n      out[p++] = ((c >> 12) & 63) | 128\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    } else {\n      out[p++] = (c >> 12) | 224\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    }\n  }\n  return out\n}\n\n// The below code is mostly taken from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n\n/**\n * @param {Uint8Array} buf\n * @param {number} offset\n * @param {number} end\n * @returns {string}\n */\nfunction utf8Slice (buf, offset, end) {\n  const res = []\n\n  while (offset < end) {\n    const firstByte = buf[offset]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[offset + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          fourthByte = buf[offset + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    /* c8 ignore next 5 */\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xfffd\n      bytesPerSequence = 1\n    } else if (codePoint > 0xffff) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3ff | 0xd800)\n      codePoint = 0xdc00 | codePoint & 0x3ff\n    }\n\n    res.push(codePoint)\n    offset += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\n/**\n * @param {number[]} codePoints\n * @returns {string}\n */\nexport function decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n  /* c8 ignore next 10 */\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n", "/**\n * Bl is a list of byte chunks, similar to https://github.com/rvagg/bl but for\n * writing rather than reading.\n * A Bl object accepts set() operations for individual bytes and copyTo() for\n * inserting byte arrays. These write operations don't automatically increment\n * the internal cursor so its \"length\" won't be changed. Instead, increment()\n * must be called to extend its length to cover the inserted data.\n * The toBytes() call will convert all internal memory to a single Uint8Array of\n * the correct length, truncating any data that is stored but hasn't been\n * included by an increment().\n * get() can retrieve a single byte.\n * All operations (except toBytes()) take an \"offset\" argument that will perform\n * the write at the offset _from the current cursor_. For most operations this\n * will be `0` to write at the current cursor position but it can be ahead of\n * the current cursor. Negative offsets probably work but are untested.\n */\n\n// TODO: ipjs doesn't support this, only for test files: https://github.com/mikeal/ipjs/blob/master/src/package/testFile.js#L39\nimport { alloc, concat, slice } from './byte-utils.js'\n\n// the ts-ignores in this file are almost all for the `Uint8Array|number[]` duality that exists\n// for perf reasons. Consider better approaches to this or removing it entirely, it is quite\n// risky because of some assumptions about small chunks === number[] and everything else === Uint8Array.\n\nconst defaultChunkSize = 256\n\nexport class Bl {\n  /**\n   * @param {number} [chunkSize]\n   */\n  constructor (chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize\n    /** @type {number} */\n    this.cursor = 0\n    /** @type {number} */\n    this.maxCursor = -1\n    /** @type {(Uint8Array|number[])[]} */\n    this.chunks = []\n    // keep the first chunk around if we can to save allocations for future encodes\n    /** @type {Uint8Array|number[]|null} */\n    this._initReuseChunk = null\n  }\n\n  reset () {\n    this.cursor = 0\n    this.maxCursor = -1\n    if (this.chunks.length) {\n      this.chunks = []\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk)\n      this.maxCursor = this._initReuseChunk.length - 1\n    }\n  }\n\n  /**\n   * @param {Uint8Array|number[]} bytes\n   */\n  push (bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1]\n    const newMax = this.cursor + bytes.length\n    if (newMax <= this.maxCursor + 1) {\n      // we have at least one chunk and we can fit these bytes into that chunk\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n      // @ts-ignore\n      topChunk.set(bytes, chunkPos)\n    } else {\n      // can't fit it in\n      if (topChunk) {\n        // trip the last chunk to `cursor` if we need to\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n        if (chunkPos < topChunk.length) {\n          // @ts-ignore\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos)\n          this.maxCursor = this.cursor - 1\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        // make a new chunk and copy the new one into it\n        topChunk = alloc(this.chunkSize)\n        this.chunks.push(topChunk)\n        this.maxCursor += topChunk.length\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk\n        }\n        // @ts-ignore\n        topChunk.set(bytes, 0)\n      } else {\n        // push the new bytes in as its own chunk\n        this.chunks.push(bytes)\n        this.maxCursor += bytes.length\n      }\n    }\n    this.cursor += bytes.length\n  }\n\n  /**\n   * @param {boolean} [reset]\n   * @returns {Uint8Array}\n   */\n  toBytes (reset = false) {\n    let byts\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0]\n      if (reset && this.cursor > chunk.length / 2) {\n        /* c8 ignore next 2 */\n        // @ts-ignore\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor)\n        this._initReuseChunk = null\n        this.chunks = []\n      } else {\n        // @ts-ignore\n        byts = slice(chunk, 0, this.cursor)\n      }\n    } else {\n      // @ts-ignore\n      byts = concat(this.chunks, this.cursor)\n    }\n    if (reset) {\n      this.reset()\n    }\n    return byts\n  }\n}\n", "const decodeErrPrefix = 'CBOR decode error:'\nconst encodeErrPrefix = 'CBOR encode error:'\n\nconst uintMinorPrefixBytes = []\nuintMinorPrefixBytes[23] = 1\nuintMinorPrefixBytes[24] = 2\nuintMinorPrefixBytes[25] = 3\nuintMinorPrefixBytes[26] = 5\nuintMinorPrefixBytes[27] = 9\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} need\n */\nfunction assertEnoughData (data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${decodeErrPrefix} not enough data for type`)\n  }\n}\n\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n}\n", "/* globals BigInt */\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix, assertEnoughData } from './common.js'\n\nexport const uintBoundaries = [24, 256, 65536, 4294967296, BigInt('18446744073709551616')]\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint8 (data, offset, options) {\n  assertEnoughData(data, offset, 1)\n  const value = data[offset]\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint16 (data, offset, options) {\n  assertEnoughData(data, offset, 2)\n  const value = (data[offset] << 8) | data[offset + 1]\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint32 (data, offset, options) {\n  assertEnoughData(data, offset, 4)\n  const value = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number|bigint}\n */\nexport function readUint64 (data, offset, options) {\n  // assume BigInt, convert back to Number if within safe range\n  assertEnoughData(data, offset, 8)\n  const hi = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  const lo = (data[offset + 4] * 16777216 /* 2 ** 24 */) + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7]\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo)\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value)\n  }\n  if (options.allowBigInt === true) {\n    return value\n  }\n  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n}\n\n/* not required thanks to quick[] list\nconst oneByteTokens = new Array(24).fill(0).map((v, i) => new Token(Type.uint, i, 1))\nexport function decodeUintCompact (data, pos, minor, options) {\n  return oneByteTokens[minor]\n}\n*/\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint8 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint16 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint32 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint64 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeUint (buf, token) {\n  return encodeUintValue(buf, 0, token.value)\n}\n\n/**\n * @param {Bl} buf\n * @param {number} major\n * @param {number|bigint} uint\n */\nexport function encodeUintValue (buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint)\n    // pack into one byte, minor=0, additional=value\n    buf.push([major | nuint])\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint)\n    // pack into two byte, minor=0, additional=24\n    buf.push([major | 24, nuint])\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint)\n    // pack into three byte, minor=0, additional=25\n    buf.push([major | 25, nuint >>> 8, nuint & 0xff])\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint)\n    // pack into five byte, minor=0, additional=26\n    buf.push([major | 26, (nuint >>> 24) & 0xff, (nuint >>> 16) & 0xff, (nuint >>> 8) & 0xff, nuint & 0xff])\n  } else {\n    const buint = BigInt(uint)\n    if (buint < uintBoundaries[4]) {\n      // pack into nine byte, minor=0, additional=27\n      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0]\n      // simulate bitwise above 32 bits\n      let lo = Number(buint & BigInt(0xffffffff))\n      let hi = Number(buint >> BigInt(32) & BigInt(0xffffffff))\n      set[8] = lo & 0xff\n      lo = lo >> 8\n      set[7] = lo & 0xff\n      lo = lo >> 8\n      set[6] = lo & 0xff\n      lo = lo >> 8\n      set[5] = lo & 0xff\n      set[4] = hi & 0xff\n      hi = hi >> 8\n      set[3] = hi & 0xff\n      hi = hi >> 8\n      set[2] = hi & 0xff\n      hi = hi >> 8\n      set[1] = hi & 0xff\n      buf.push(set)\n    } else {\n      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeUint.encodedSize = function encodedSize (token) {\n  return encodeUintValue.encodedSize(token.value)\n}\n\n/**\n * @param {number} uint\n * @returns {number}\n */\nencodeUintValue.encodedSize = function encodedSize (uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeUint.compareTokens = function compareTokens (tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : /* c8 ignore next */ 0\n}\n", "/* eslint-env es2020 */\n\nimport { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint8 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint16 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint32 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5)\n}\n\nconst neg1b = BigInt(-1)\nconst pos1b = BigInt(1)\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint64 (data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options)\n  if (typeof int !== 'bigint') {\n    const value = -1 - int\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9)\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeNegint (buf, token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeNegint.encodedSize = function encodedSize (token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  /* c8 ignore next 4 */\n  // handled by quickEncode, we shouldn't get here but it's included for completeness\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeNegint.compareTokens = function compareTokens (tok1, tok2) {\n  // opposite of the uint comparison since we store the uint version in bytes\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : /* c8 ignore next */ 0\n}\n", "import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { compare, fromString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length)\n  const buf = slice(data, pos + prefix, pos + prefix + length)\n  return new Token(Type.bytes, buf, prefix + length)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeBytesCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * `encodedBytes` allows for caching when we do a byte version of a string\n * for key sorting purposes\n * @param {Token} token\n * @returns {Uint8Array}\n */\nfunction tokenBytes (token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value\n  }\n  // @ts-ignore c'mon\n  return token.encodedBytes\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeBytes (buf, token) {\n  const bytes = tokenBytes(token)\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length)\n  buf.push(bytes)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeBytes.encodedSize = function encodedSize (token) {\n  const bytes = tokenBytes(token)\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeBytes.compareTokens = function compareTokens (tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2))\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compareBytes (b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2)\n}\n", "import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { toString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length, options) {\n  const totLength = prefix + length\n  assertEnoughData(data, pos, totLength)\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength)\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength)\n  }\n  return tok\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeStringCompact (data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options)\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`)\n  }\n  return toToken(data, pos, 9, l, options)\n}\n\nexport const encodeString = encodeBytes\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeArrayCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArrayIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeArray (buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value)\n}\n\n// using an array as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeArray.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeArray.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeMapCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMapIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeMap (buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value)\n}\n\n// using a map as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeMap.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeMap.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeTagCompact (_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag8 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag16 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag32 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag64 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeTag (buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value)\n}\n\nencodeTag.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeTag.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "// TODO: shift some of the bytes logic to bytes-utils so we can use Buffer\n// where possible\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix } from './common.js'\nimport { encodeUint } from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n */\n\nconst MINOR_FALSE = 20\nconst MINOR_TRUE = 21\nconst MINOR_NULL = 22\nconst MINOR_UNDEFINED = 23\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUndefined (_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${decodeErrPrefix} undefined values are not supported`)\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1)\n  }\n  return new Token(Type.undefined, undefined, 1)\n}\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBreak (_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return new Token(Type.break, undefined, 1)\n}\n\n/**\n * @param {number} value\n * @param {number} bytes\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction createToken (value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${decodeErrPrefix} NaN values are not supported`)\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${decodeErrPrefix} Infinity values are not supported`)\n    }\n  }\n  return new Token(Type.float, value, bytes)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat16 (data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat32 (data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat64 (data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n * @param {EncodeOptions} options\n */\nexport function encodeFloat (buf, token, options) {\n  const float = token.value\n\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE])\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE])\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL])\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED])\n  } else {\n    let decoded\n    let success = false\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float)\n      decoded = readFloat16(ui8a, 1)\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 0xf9\n        buf.push(ui8a.slice(0, 3))\n        success = true\n      } else {\n        encodeFloat32(float)\n        decoded = readFloat32(ui8a, 1)\n        if (float === decoded) {\n          ui8a[0] = 0xfa\n          buf.push(ui8a.slice(0, 5))\n          success = true\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float)\n      decoded = readFloat64(ui8a, 1)\n      ui8a[0] = 0xfb\n      buf.push(ui8a.slice(0, 9))\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @param {EncodeOptions} options\n * @returns {number}\n */\nencodeFloat.encodedSize = function encodedSize (token, options) {\n  const float = token.value\n\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1\n  }\n\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float)\n    let decoded = readFloat16(ui8a, 1)\n    if (float === decoded || Number.isNaN(float)) {\n      return 3\n    }\n    encodeFloat32(float)\n    decoded = readFloat32(ui8a, 1)\n    if (float === decoded) {\n      return 5\n    }\n  }\n  return 9\n}\n\nconst buffer = new ArrayBuffer(9)\nconst dataView = new DataView(buffer, 1)\nconst ui8a = new Uint8Array(buffer, 0)\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat16 (inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 0x7c00, false)\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 0xfc00, false)\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 0x7e00, false)\n  } else {\n    dataView.setFloat32(0, inp)\n    const valu32 = dataView.getUint32(0)\n    const exponent = (valu32 & 0x7f800000) >> 23\n    const mantissa = valu32 & 0x7fffff\n\n    /* c8 ignore next 6 */\n    if (exponent === 0xff) {\n      // too big, Infinity, but this should be hard (impossible?) to trigger\n      dataView.setUint16(0, 0x7c00, false)\n    } else if (exponent === 0x00) {\n      // 0.0, -0.0 and subnormals, shouldn't be possible to get here because 0.0 should be counted as an int\n      dataView.setUint16(0, ((inp & 0x80000000) >> 16) | (mantissa >> 13), false)\n    } else { // standard numbers\n      // chunks of logic here borrowed from https://github.com/PJK/libcbor/blob/c78f437182533e3efa8d963ff4b945bb635c2284/src/cbor/encoding.c#L127\n      const logicalExponent = exponent - 127\n      // Now we know that 2^exponent <= 0 logically\n      /* c8 ignore next 6 */\n      if (logicalExponent < -24) {\n        /* No unambiguous representation exists, this float is not a half float\n          and is too small to be represented using a half, round off to zero.\n          Consistent with the reference implementation. */\n        // should be difficult (impossible?) to get here in JS\n        dataView.setUint16(0, 0)\n      } else if (logicalExponent < -14) {\n        /* Offset the remaining decimal places by shifting the significand, the\n          value is lost. This is an implementation decision that works around the\n          absence of standard half-float in the language. */\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | /* sign bit */ (1 << (24 + logicalExponent)), false)\n      } else {\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | ((logicalExponent + 15) << 10) | (mantissa >> 13), false)\n      }\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat16 (ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${decodeErrPrefix} not enough data for float16`)\n  }\n\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1]\n  if (half === 0x7c00) {\n    return Infinity\n  }\n  if (half === 0xfc00) {\n    return -Infinity\n  }\n  if (half === 0x7e00) {\n    return NaN\n  }\n  const exp = (half >> 10) & 0x1f\n  const mant = half & 0x3ff\n  let val\n  if (exp === 0) {\n    val = mant * (2 ** -24)\n  } else if (exp !== 31) {\n    val = (mant + 1024) * (2 ** (exp - 25))\n  /* c8 ignore next 4 */\n  } else {\n    // may not be possible to get here\n    val = mant === 0 ? Infinity : NaN\n  }\n  return (half & 0x8000) ? -val : val\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat32 (inp) {\n  dataView.setFloat32(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat32 (ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${decodeErrPrefix} not enough data for float32`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false)\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat64 (inp) {\n  dataView.setFloat64(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat64 (ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${decodeErrPrefix} not enough data for float64`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false)\n}\n\n/**\n * @param {Token} _tok1\n * @param {Token} _tok2\n * @returns {number}\n */\nencodeFloat.compareTokens = encodeUint.compareTokens\n/*\nencodeFloat.compareTokens = function compareTokens (_tok1, _tok2) {\n  return _tok1\n  throw new Error(`${encodeErrPrefix} cannot use floats as map keys`)\n}\n*/\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport * as negint from './1negint.js'\nimport * as bytes from './2bytes.js'\nimport * as string from './3string.js'\nimport * as array from './4array.js'\nimport * as map from './5map.js'\nimport * as tag from './6tag.js'\nimport * as float from './7float.js'\nimport { decodeErrPrefix } from './common.js'\nimport { fromArray } from './byte-utils.js'\n\n/**\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n */\nfunction invalidMinor (data, pos, minor) {\n  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`)\n}\n\n/**\n * @param {string} msg\n * @returns {()=>any}\n */\nfunction errorer (msg) {\n  return () => { throw new Error(`${decodeErrPrefix} ${msg}`) }\n}\n\n/** @type {((data:Uint8Array, pos:number, minor:number, options?:DecodeOptions) => any)[]} */\nexport const jump = []\n\n// unsigned integer, 0x00..0x17 (0..23)\nfor (let i = 0; i <= 0x17; i++) {\n  jump[i] = invalidMinor // uint.decodeUintCompact, handled by quick[]\n}\njump[0x18] = uint.decodeUint8 // unsigned integer, one-byte uint8_t follows\njump[0x19] = uint.decodeUint16 // unsigned integer, two-byte uint16_t follows\njump[0x1a] = uint.decodeUint32 // unsigned integer, four-byte uint32_t follows\njump[0x1b] = uint.decodeUint64 // unsigned integer, eight-byte uint64_t follows\njump[0x1c] = invalidMinor\njump[0x1d] = invalidMinor\njump[0x1e] = invalidMinor\njump[0x1f] = invalidMinor\n// negative integer, -1-0x00..-1-0x17 (-1..-24)\nfor (let i = 0x20; i <= 0x37; i++) {\n  jump[i] = invalidMinor // negintDecode, handled by quick[]\n}\njump[0x38] = negint.decodeNegint8 // negative integer, -1-n one-byte uint8_t for n follows\njump[0x39] = negint.decodeNegint16 // negative integer, -1-n two-byte uint16_t for n follows\njump[0x3a] = negint.decodeNegint32 // negative integer, -1-n four-byte uint32_t for follows\njump[0x3b] = negint.decodeNegint64 // negative integer, -1-n eight-byte uint64_t for follows\njump[0x3c] = invalidMinor\njump[0x3d] = invalidMinor\njump[0x3e] = invalidMinor\njump[0x3f] = invalidMinor\n// byte string, 0x00..0x17 bytes follow\nfor (let i = 0x40; i <= 0x57; i++) {\n  jump[i] = bytes.decodeBytesCompact\n}\njump[0x58] = bytes.decodeBytes8 // byte string, one-byte uint8_t for n, and then n bytes follow\njump[0x59] = bytes.decodeBytes16 // byte string, two-byte uint16_t for n, and then n bytes follow\njump[0x5a] = bytes.decodeBytes32 // byte string, four-byte uint32_t for n, and then n bytes follow\njump[0x5b] = bytes.decodeBytes64 // byte string, eight-byte uint64_t for n, and then n bytes follow\njump[0x5c] = invalidMinor\njump[0x5d] = invalidMinor\njump[0x5e] = invalidMinor\njump[0x5f] = errorer('indefinite length bytes/strings are not supported') // byte string, byte strings follow, terminated by \"break\"\n// UTF-8 string 0x00..0x17 bytes follow\nfor (let i = 0x60; i <= 0x77; i++) {\n  jump[i] = string.decodeStringCompact\n}\njump[0x78] = string.decodeString8 // UTF-8 string, one-byte uint8_t for n, and then n bytes follow\njump[0x79] = string.decodeString16 // UTF-8 string, two-byte uint16_t for n, and then n bytes follow\njump[0x7a] = string.decodeString32 // UTF-8 string, four-byte uint32_t for n, and then n bytes follow\njump[0x7b] = string.decodeString64 // UTF-8 string, eight-byte uint64_t for n, and then n bytes follow\njump[0x7c] = invalidMinor\njump[0x7d] = invalidMinor\njump[0x7e] = invalidMinor\njump[0x7f] = errorer('indefinite length bytes/strings are not supported') // UTF-8 strings follow, terminated by \"break\"\n// array, 0x00..0x17 data items follow\nfor (let i = 0x80; i <= 0x97; i++) {\n  jump[i] = array.decodeArrayCompact\n}\njump[0x98] = array.decodeArray8 // array, one-byte uint8_t for n, and then n data items follow\njump[0x99] = array.decodeArray16 // array, two-byte uint16_t for n, and then n data items follow\njump[0x9a] = array.decodeArray32 // array, four-byte uint32_t for n, and then n data items follow\njump[0x9b] = array.decodeArray64 // array, eight-byte uint64_t for n, and then n data items follow\njump[0x9c] = invalidMinor\njump[0x9d] = invalidMinor\njump[0x9e] = invalidMinor\njump[0x9f] = array.decodeArrayIndefinite // array, data items follow, terminated by \"break\"\n// map, 0x00..0x17 pairs of data items follow\nfor (let i = 0xa0; i <= 0xb7; i++) {\n  jump[i] = map.decodeMapCompact\n}\njump[0xb8] = map.decodeMap8 // map, one-byte uint8_t for n, and then n pairs of data items follow\njump[0xb9] = map.decodeMap16 // map, two-byte uint16_t for n, and then n pairs of data items follow\njump[0xba] = map.decodeMap32 // map, four-byte uint32_t for n, and then n pairs of data items follow\njump[0xbb] = map.decodeMap64 // map, eight-byte uint64_t for n, and then n pairs of data items follow\njump[0xbc] = invalidMinor\njump[0xbd] = invalidMinor\njump[0xbe] = invalidMinor\njump[0xbf] = map.decodeMapIndefinite // map, pairs of data items follow, terminated by \"break\"\n// tags\nfor (let i = 0xc0; i <= 0xd7; i++) {\n  jump[i] = tag.decodeTagCompact\n}\njump[0xd8] = tag.decodeTag8\njump[0xd9] = tag.decodeTag16\njump[0xda] = tag.decodeTag32\njump[0xdb] = tag.decodeTag64\njump[0xdc] = invalidMinor\njump[0xdd] = invalidMinor\njump[0xde] = invalidMinor\njump[0xdf] = invalidMinor\n// 0xe0..0xf3 simple values, unsupported\nfor (let i = 0xe0; i <= 0xf3; i++) {\n  jump[i] = errorer('simple values are not supported')\n}\njump[0xf4] = invalidMinor // false, handled by quick[]\njump[0xf5] = invalidMinor // true, handled by quick[]\njump[0xf6] = invalidMinor // null, handled by quick[]\njump[0xf7] = float.decodeUndefined // undefined\njump[0xf8] = errorer('simple values are not supported') // simple value, one byte follows, unsupported\njump[0xf9] = float.decodeFloat16 // half-precision float (two-byte IEEE 754)\njump[0xfa] = float.decodeFloat32 // single-precision float (four-byte IEEE 754)\njump[0xfb] = float.decodeFloat64 // double-precision float (eight-byte IEEE 754)\njump[0xfc] = invalidMinor\njump[0xfd] = invalidMinor\njump[0xfe] = invalidMinor\njump[0xff] = float.decodeBreak // \"break\" stop code\n\n/** @type {Token[]} */\nexport const quick = []\n// ints <24\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1)\n}\n// negints >= -24\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1)\n}\n// empty bytes\nquick[0x40] = new Token(Type.bytes, new Uint8Array(0), 1)\n// empty string\nquick[0x60] = new Token(Type.string, '', 1)\n// empty list\nquick[0x80] = new Token(Type.array, 0, 1)\n// empty map\nquick[0xa0] = new Token(Type.map, 0, 1)\n// false\nquick[0xf4] = new Token(Type.false, false, 1)\n// true\nquick[0xf5] = new Token(Type.true, true, 1)\n// null\nquick[0xf6] = new Token(Type.null, null, 1)\n\n/**\n * @param {Token} token\n * @returns {Uint8Array|undefined}\n */\nexport function quickEncodeToken (token) {\n  switch (token.type) {\n    case Type.false:\n      return fromArray([0xf4])\n    case Type.true:\n      return fromArray([0xf5])\n    case Type.null:\n      return fromArray([0xf6])\n    case Type.bytes:\n      if (!token.value.length) {\n        return fromArray([0x40])\n      }\n      return\n    case Type.string:\n      if (token.value === '') {\n        return fromArray([0x60])\n      }\n      return\n    case Type.array:\n      if (token.value === 0) {\n        return fromArray([0x80])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.map:\n      if (token.value === 0) {\n        return fromArray([0xa0])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.uint:\n      if (token.value < 24) {\n        return fromArray([Number(token.value)])\n      }\n      return\n    case Type.negint:\n      if (token.value >= -24) {\n        return fromArray([31 - Number(token.value)])\n      }\n  }\n}\n", "import { is } from './is.js'\nimport { Token, Type } from './token.js'\nimport { Bl } from './bl.js'\nimport { encodeErrPrefix } from './common.js'\nimport { quickEncodeToken } from './jump.js'\nimport { asU8A } from './byte-utils.js'\n\nimport { encodeUint } from './0uint.js'\nimport { encodeNegint } from './1negint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { encodeString } from './3string.js'\nimport { encodeArray } from './4array.js'\nimport { encodeMap } from './5map.js'\nimport { encodeTag } from './6tag.js'\nimport { encodeFloat } from './7float.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').OptionalTypeEncoder} OptionalTypeEncoder\n * @typedef {import('../interface').Reference} Reference\n * @typedef {import('../interface').StrictTypeEncoder} StrictTypeEncoder\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n}\n\n/** @returns {TokenTypeEncoder[]} */\nexport function makeCborEncoders () {\n  const encoders = []\n  encoders[Type.uint.major] = encodeUint\n  encoders[Type.negint.major] = encodeNegint\n  encoders[Type.bytes.major] = encodeBytes\n  encoders[Type.string.major] = encodeString\n  encoders[Type.array.major] = encodeArray\n  encoders[Type.map.major] = encodeMap\n  encoders[Type.tag.major] = encodeTag\n  encoders[Type.float.major] = encodeFloat\n  return encoders\n}\n\nconst cborEncoders = makeCborEncoders()\n\nconst buf = new Bl()\n\n/** @implements {Reference} */\nclass Ref {\n  /**\n   * @param {object|any[]} obj\n   * @param {Reference|undefined} parent\n   */\n  constructor (obj, parent) {\n    this.obj = obj\n    this.parent = parent\n  }\n\n  /**\n   * @param {object|any[]} obj\n   * @returns {boolean}\n   */\n  includes (obj) {\n    /** @type {Reference|undefined} */\n    let p = this\n    do {\n      if (p.obj === obj) {\n        return true\n      }\n    } while (p = p.parent) // eslint-disable-line\n    return false\n  }\n\n  /**\n   * @param {Reference|undefined} stack\n   * @param {object|any[]} obj\n   * @returns {Reference}\n   */\n  static createCheck (stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`)\n    }\n    return new Ref(obj, stack)\n  }\n}\n\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n}\n\n/** @type {{[typeName: string]: StrictTypeEncoder}} */\nconst typeEncoders = {\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  number (obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj)\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  bigint (obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Uint8Array (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  string (obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  boolean (obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  null (_obj, _typ, _options, _refStack) {\n    return simpleTokens.null\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  undefined (_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  ArrayBuffer (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  DataView (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Array (obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)]\n      }\n      return simpleTokens.emptyArray\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    const entries = []\n    let i = 0\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack)\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.array, obj.length), entries]\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Object (obj, typ, options, refStack) {\n    // could be an Object or a Map\n    const isMap = typ !== 'Object'\n    // it's slightly quicker to use Object.keys() than Object.entries()\n    const keys = isMap ? obj.keys() : Object.keys(obj)\n    const length = isMap ? obj.size : keys.length\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)]\n      }\n      return simpleTokens.emptyMap\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    /** @type {TokenOrNestedTokens[]} */\n    const entries = []\n    let i = 0\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ]\n    }\n    sortMapEntries(entries, options)\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.map, length), entries]\n  }\n}\n\ntypeEncoders.Map = typeEncoders.Object\ntypeEncoders.Buffer = typeEncoders.Uint8Array\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView\n}\n\n/**\n * @param {any} obj\n * @param {EncodeOptions} [options]\n * @param {Reference} [refStack]\n * @returns {TokenOrNestedTokens}\n */\nfunction objectToTokens (obj, options = {}, refStack) {\n  const typ = is(obj)\n  const customTypeEncoder = (options && options.typeEncoders && /** @type {OptionalTypeEncoder} */ options.typeEncoders[typ]) || typeEncoders[typ]\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack)\n    if (tokens != null) {\n      return tokens\n    }\n  }\n  const typeEncoder = typeEncoders[typ]\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`)\n  }\n  return typeEncoder(obj, typ, options, refStack)\n}\n\n/*\nCBOR key sorting is a mess.\n\nThe canonicalisation recommendation from https://tools.ietf.org/html/rfc7049#section-3.9\nincludes the wording:\n\n> The keys in every map must be sorted lowest value to highest.\n> Sorting is performed on the bytes of the representation of the key\n> data items without paying attention to the 3/5 bit splitting for\n> major types.\n> ...\n>  *  If two keys have different lengths, the shorter one sorts\n      earlier;\n>  *  If two keys have the same length, the one with the lower value\n      in (byte-wise) lexical order sorts earlier.\n\n1. It is not clear what \"bytes of the representation of the key\" means: is it\n   the CBOR representation, or the binary representation of the object itself?\n   Consider the int and uint difference here.\n2. It is not clear what \"without paying attention to\" means: do we include it\n   and compare on that? Or do we omit the special prefix byte, (mostly) treating\n   the key in its plain binary representation form.\n\nThe FIDO 2.0: Client To Authenticator Protocol spec takes the original CBOR\nwording and clarifies it according to their understanding.\nhttps://fidoalliance.org/specs/fido-v2.0-rd-20170927/fido-client-to-authenticator-protocol-v2.0-rd-20170927.html#message-encoding\n\n> The keys in every map must be sorted lowest value to highest. Sorting is\n> performed on the bytes of the representation of the key data items without\n> paying attention to the 3/5 bit splitting for major types. The sorting rules\n> are:\n>  * If the major types are different, the one with the lower value in numerical\n>    order sorts earlier.\n>  * If two keys have different lengths, the shorter one sorts earlier;\n>  * If two keys have the same length, the one with the lower value in\n>    (byte-wise) lexical order sorts earlier.\n\nSome other implementations, such as borc, do a full encode then do a\nlength-first, byte-wise-second comparison:\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/encoder.js#L358\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/utils.js#L143-L151\n\nThis has the benefit of being able to easily handle arbitrary keys, including\ncomplex types (maps and arrays).\n\nWe'll opt for the FIDO approach, since it affords some efficies since we don't\nneed a full encode of each key to determine order and can defer to the types\nto determine how to most efficiently order their values (i.e. int and uint\nordering can be done on the numbers, no need for byte-wise, for example).\n\nRecommendation: stick to single key types or you'll get into trouble, and prefer\nstring keys because it's much simpler that way.\n*/\n\n/*\n(UPDATE, Dec 2020)\nhttps://tools.ietf.org/html/rfc8949 is the updated CBOR spec and clarifies some\nof the questions above with a new recommendation for sorting order being much\ncloser to what would be expected in other environments (i.e. no length-first\nweirdness).\nThis new sorting order is not yet implemented here but could be added as an\noption. \"Determinism\" (canonicity) is system dependent and it's difficult to\nchange existing systems that are built with existing expectations. So if a new\nordering is introduced here, the old needs to be kept as well with the user\nhaving the option.\n*/\n\n/**\n * @param {TokenOrNestedTokens[]} entries\n * @param {EncodeOptions} options\n */\nfunction sortMapEntries (entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter)\n  }\n}\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  // the key position ([0]) could have a single token or an array\n  // almost always it'll be a single token but complex key might get involved\n  /* c8 ignore next 2 */\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0]\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0]\n\n  // different key types\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type)\n  }\n\n  const major = keyToken1.type.major\n  // TODO: handle case where cmp === 0 but there are more keyToken e. complex type)\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2)\n  /* c8 ignore next 5 */\n  if (tcmp === 0) {\n    // duplicate key or complex type where the first token matched,\n    // i.e. a map or array and we're only comparing the opening token\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone')\n  }\n  return tcmp\n}\n\n/**\n * @param {Bl} buf\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n */\nfunction tokensToEncoded (buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options)\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options)\n  }\n}\n\n/**\n * @param {any} data\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n * @returns {Uint8Array}\n */\nfunction encodeCustom (data, encoders, options) {\n  const tokens = objectToTokens(data, options)\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens)\n    if (quickBytes) {\n      return quickBytes\n    }\n    const encoder = encoders[tokens.type.major]\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options)\n      const buf = new Bl(size)\n      encoder(buf, tokens, options)\n      /* c8 ignore next 4 */\n      // this would be a problem with encodedSize() functions\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`)\n      }\n      return asU8A(buf.chunks[0])\n    }\n  }\n  buf.reset()\n  tokensToEncoded(buf, tokens, encoders, options)\n  return buf.toBytes(true)\n}\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, cborEncoders, options)\n}\n\nexport { objectToTokens, encode, encodeCustom, Ref }\n", "import { decodeErrPrefix } from './common.js'\nimport { Type } from './token.js'\nimport { jump, quick } from './jump.js'\n\n/**\n * @typedef {import('./token.js').Token} Token\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').DecodeTokenizer} DecodeTokenizer\n */\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokeniser {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  next () {\n    const byt = this.data[this._pos]\n    let token = quick[byt]\n    if (token === undefined) {\n      const decoder = jump[byt]\n      /* c8 ignore next 4 */\n      // if we're here then there's something wrong with our jump or quick lists!\n      if (!decoder) {\n        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, '0')})`)\n      }\n      const minor = byt & 31\n      token = decoder(this.data, this._pos, minor, this.options)\n    }\n    // @ts-ignore we get to assume encodedLength is set (crossing fingers slightly)\n    this._pos += token.encodedLength\n    return token\n  }\n}\n\nconst DONE = Symbol.for('DONE')\nconst BREAK = Symbol.for('BREAK')\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToArray (token, tokeniser, options) {\n  const arr = []\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options)\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length array\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)\n    }\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`)\n    }\n    arr[i] = value\n  }\n  return arr\n}\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToMap (token, tokeniser, options) {\n  const useMaps = options.useMaps === true\n  const obj = useMaps ? undefined : {}\n  const m = useMaps ? new Map() : undefined\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options)\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length map\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)\n    }\n    if (key === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`)\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`)\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      // @ts-ignore\n      if ((useMaps && m.has(key)) || (!useMaps && (key in obj))) {\n        throw new Error(`${decodeErrPrefix} found repeat map key \"${key}\"`)\n      }\n    }\n    const value = tokensToObject(tokeniser, options)\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`)\n    }\n    if (useMaps) {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      m.set(key, value)\n    } else {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      obj[key] = value\n    }\n  }\n  // @ts-ignore c'mon man\n  return useMaps ? m : obj\n}\n\n/**\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokensToObject (tokeniser, options) {\n  // should we support array as an argument?\n  // check for tokenIter[Symbol.iterator] and replace tokenIter with what that returns?\n  if (tokeniser.done()) {\n    return DONE\n  }\n\n  const token = tokeniser.next()\n\n  if (token.type === Type.break) {\n    return BREAK\n  }\n\n  if (token.type.terminal) {\n    return token.value\n  }\n\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options)\n  }\n\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options)\n  }\n\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options)\n      return options.tags[token.value](tagged)\n    }\n    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`)\n  }\n  /* c8 ignore next */\n  throw new Error('unsupported')\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`)\n  }\n  options = Object.assign({}, defaultDecodeOptions, options)\n  const tokeniser = options.tokenizer || new Tokeniser(data, options)\n  const decoded = tokensToObject(tokeniser, options)\n  if (decoded === DONE) {\n    throw new Error(`${decodeErrPrefix} did not find any content to decode`)\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${decodeErrPrefix} got unexpected break`)\n  }\n  return [decoded, data.subarray(tokeniser.pos())]\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  const [decoded, remainder] = decodeFirst(data, options)\n  if (remainder.length > 0) {\n    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`)\n  }\n  return decoded\n}\n\nexport { Tokeniser, tokensToObject, decode, decodeFirst }\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabet: string, bitsPerChar: number, name: string): Uint8Array {\n  // Build the character lookup table:\n  const codes: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n", "/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n", "import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "import * as cborg from 'cborg'\nimport { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1)\n  bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null\n}\n\nconst _encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\nexport const encodeOptions = {\n  ..._encodeOptions,\n  typeEncoders: {\n    ..._encodeOptions.typeEncoders\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder (bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00')\n  }\n  return CID.decode(bytes.subarray(1)) // ignore leading 0x00\n}\n\nconst _decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder\n\nexport const decodeOptions = {\n  ..._decodeOptions,\n  tags: _decodeOptions.tags.slice()\n}\n\nexport const name = 'dag-cbor'\nexport const code = 0x71\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborg.encode(node, _encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => cborg.decode(toByteView(data), _decodeOptions)\n", "import { CID, format, toJSON, fromJSON } from './cid.js'\nimport type * as API from './link/interface.js'\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nconst DAG_PB_CODE = 0x70\n// eslint-disable-next-line\nconst SHA_256_CODE = 0x12\n\n/**\n * Simplified version of `create` for CIDv0.\n */\nexport function createLegacy (digest: API.MultihashDigest<typeof SHA_256_CODE>): API.LegacyLink {\n  return CID.create(0, DAG_PB_CODE, digest)\n}\n\n/**\n * Simplified version of `create` for CIDv1.\n *\n * @param code - Content encoding format code.\n * @param digest - Miltihash of the content.\n */\nexport function create <Data, Code extends number, Alg extends number> (code: Code, digest: API.MultihashDigest<Alg>): API.Link<Data, Code, Alg> {\n  return CID.create(1, code, digest)\n}\n\n/**\n * Type predicate returns true if value is the link.\n */\nexport function isLink <L extends API.Link<unknown, number, number, 0 | 1>> (value: unknown | L): value is L & CID {\n  if (value == null) {\n    return false\n  }\n\n  const withSlash = value as { '/'?: Uint8Array, bytes: Uint8Array }\n\n  if (withSlash['/'] != null && withSlash['/'] === withSlash.bytes) {\n    return true\n  }\n\n  const withAsCID = value as { 'asCID'?: unknown }\n\n  if (withAsCID.asCID === value) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Takes cid in a string representation and creates an instance. If `base`\n * decoder is not provided will use a default from the configuration. It will\n * throw an error if encoding of the CID is not compatible with supplied (or\n * a default decoder).\n */\nexport function parse <Prefix extends string, Data, Code extends number, Alg extends number, Ver extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>, base?: API.MultibaseDecoder<Prefix>): API.Link<Data, Code, Alg, Ver> {\n  return CID.parse(source, base)\n}\n\nexport { format, toJSON, fromJSON }\n\n/**\n * Decoded a CID from its binary representation. The byte array must contain\n * only the CID with no additional bytes.\n *\n * An error will be thrown if the bytes provided do not contain a valid\n * binary representation of a CID.\n */\nexport function decode <Data, Code extends number, Alg extends number, Ver extends API.Version> (bytes: API.ByteView<API.Link<Data, Code, Alg, Ver>>): API.Link<Data, Code, Alg, Ver> {\n  return CID.decode(bytes)\n}\n", "import * as API from './api.js'\n\nimport * as Bytes from 'multiformats/bytes'\nimport { Size as NodeSize } from './node.js'\nimport { CBOR, SHA256 } from './ipld.js'\n\n/**\n * @param {API.ProofData} proof\n * @returns {API.MerkleTreePath}\n */\nexport const path = ([, path]) => path\n\n/**\n * @param {API.ProofData} proof\n * @returns {API.uint64}\n */\nexport const offset = ([offset]) => offset\n\n/**\n * @param {API.ProofData} proof\n * @returns {number}\n */\nexport const depth = (proof) => path(proof).length\n\n/**\n * Verifies that `proof` proves that `claim.node` is contained by\n * the `claim.tree` merkle tree.\n *\n * @param {API.ProofData} proof\n * @param {object} claim\n * @param {API.MerkleTreeNode} claim.tree\n * @param {API.MerkleTreeNode} claim.node\n * @returns {API.Result<{}, Error>}\n */\nexport const verify = (proof, { tree, node }) => {\n  const computedRoot = resolveRoot(proof, node)\n  if (computedRoot.error) {\n    return { error: new Error(`computing root: ${computedRoot.error.message}`) }\n  }\n\n  if (!Bytes.equals(computedRoot.ok, tree)) {\n    return {\n      error: new Error('inclusion proof does not lead to the same root'),\n    }\n  }\n  return { ok: {} }\n}\n\nconst MAX_DEPTH = 63\n\n/**\n * Resolves the root of the merkle tree from given proof and node that root\n * supposedly includes. It does so by computing parent node from provided node\n * and node in the proof path, then combining that with the next node in the\n * path and so on until the root is reached. Function may return an error if\n * proof path is too long or if proof offset falls out of bounds.\n *\n * @param {API.ProofData} proof\n * @param {API.MerkleTreeNode} node\n * @returns {API.Result<API.MerkleTreeNode, RangeError>}\n */\nexport function resolveRoot(proof, node) {\n  if (depth(proof) > MAX_DEPTH) {\n    return {\n      error: new RangeError(\n        'merkle proofs with depths greater than 63 are not supported'\n      ),\n    }\n  }\n\n  let position = offset(proof)\n  if (position >> BigInt(depth(proof)) !== 0n) {\n    return { error: new RangeError('offset greater than width of the tree') }\n  }\n\n  let top = node\n  let right = 0n\n\n  for (const node of path(proof)) {\n    right =  position & 1n\n    position = position >> 1n\n    top = right === 1n ? computeNode(node, top) : computeNode(top, node)\n  }\n\n  return { ok: top }\n}\n\n/**\n * @param {Uint8Array} payload\n * @param {object} [options]\n * @param {API.SyncMultihashHasher<API.SHA256_CODE>} [options.hasher]\n * @returns {API.MerkleTreeNode}\n */\nexport function truncatedHash(payload, options = {}) {\n  const hasher = options.hasher || SHA256\n  const { digest } = hasher.digest(payload)\n  return truncate(digest)\n}\n\n/**\n * @param {API.MerkleTreeNode} left\n * @param {API.MerkleTreeNode} right\n * @param {object} [options]\n * @param {API.SyncMultihashHasher<API.SHA256_CODE>} [options.hasher]\n * @returns {API.MerkleTreeNode}\n */\nexport const computeNode = (left, right, options) => {\n  const payload = new Uint8Array(left.length + right.length)\n  payload.set(left, 0)\n  payload.set(right, left.length)\n  return truncatedHash(payload, options)\n}\n\n/**\n * @param {API.MerkleTreeNode} node\n * @returns {API.MerkleTreeNode}\n */\nexport function truncate(node) {\n  node[NodeSize - 1] &= 0b00111111\n  return node\n}\n\n/**\n * Takes data model and returns an IPLD View of it.\n *\n * @param {object} source\n * @param {API.uint64} source.offset\n * @param {API.MerkleTreePath} source.path\n * @returns {API.ProofData}\n */\nexport const create = ({ offset, path }) => [offset, path]\n\n/**\n * Takes proof in somewhat arbitrary form and returns a proof data.\n *\n * @param {API.IntoProofData} source\n * @returns {API.ProofData}\n */\nexport const from = (source) => {\n  const [offset, path] = Array.isArray(source)\n    ? source\n    : [source.offset, source.path]\n\n  return create({ offset: BigInt(offset), path })\n}\n\n/**\n * @param {number} height - Height of the merkle tree\n * @param {number} level - Level of the node in the merkle tree\n * @param {API.uint64} index - Index of the node in the level\n */\nexport const validateLevelIndex = (height, level, index) => {\n  if (level < 0) {\n    throw new RangeError('level can not be negative')\n  }\n\n  if (level > height) {\n    throw new RangeError(`level too high: ${level} >= ${height}`)\n  }\n\n  if (index > (1 << (height - level)) - 1) {\n    throw new RangeError(\n      `index too large for level: idx ${index}, level ${level} : ${\n        (1 << (height - level)) - 1\n      }`\n    )\n  }\n}\n", "import * as API from './api.js'\nimport * as Node from './node.js'\nimport * as Proof from './proof.js'\n\nconst MAX_LEVEL = 64\n\n/**\n * This is a lazy zero-comm buffer which we fill up on demand.\n */\nclass ZeroComm {\n  constructor() {\n    this.bytes = new Uint8Array(MAX_LEVEL * Node.Size)\n    this.bytes.set(Node.empty(), 0)\n    /** @private */\n    this.node = Node.empty()\n    /** @private */\n    this.length = Node.Size\n  }\n  /**\n   * @param {number} start\n   * @param {number} end\n   */\n  slice(start, end) {\n    while (this.length < end) {\n      this.node = Proof.computeNode(this.node, this.node)\n      this.bytes.set(this.node, this.length)\n      this.length += Node.Size\n    }\n\n    return this.bytes.subarray(start, end)\n  }\n}\nconst ZERO_COMM = new ZeroComm()\n\n/**\n * simple access by level, only levels between `0` and `64` inclusive are\n * available otherwise throws an error.\n *\n * @param {number} level\n * @returns {API.MerkleTreeNode}\n */\nexport const fromLevel = (level) => {\n  if (level < 0 || level >= MAX_LEVEL) {\n    throw new Error(\n      `Only levels between 0 and ${MAX_LEVEL - 1} inclusive are available`\n    )\n  }\n\n  return ZERO_COMM.slice(Node.Size * level, Node.Size * (level + 1))\n}\n", "import * as API from '../api.js'\nimport { Size as NodeSize } from '../node.js'\nimport * as Proof from '../proof.js'\nexport { computeNode } from '../proof.js'\n\n// The value is an unsigned, 32-bit integer that is always numerically greater\n// than the highest index in the array. This means our tree can represent a\n// piece up to 128 GiB in size.\nexport const MAX_LEAF_COUNT = 2 ** 32 - 1\n\n/**\n * Allocates a tree for a given amount of leafs.\n *\n * The construction rounds the amount of leafs up to the nearest two-power with\n * zeroed nodes to ensure that the tree is perfect and hence all internal node's\n * have well-defined children.\n *\n * @param {number} leafs\n */\nexport function allocate(leafs) {\n  const adjustedLeafs = 2 ** Math.ceil(Math.log2(leafs))\n\n  if (adjustedLeafs > MAX_LEAF_COUNT) {\n    throw new RangeError(\n      `too many leafs ${adjustedLeafs} exceeds ${MAX_LEAF_COUNT} limit`\n    )\n  }\n\n  const height = Math.ceil(Math.log2(adjustedLeafs))\n  const nodes = new Array(height + 1)\n\n  for (const level of nodes.keys()) {\n    nodes[level] = new Array(1 << level)\n  }\n\n  return new PieceTree({ nodes, height })\n}\n\n/**\n * @param {API.TreeData} tree\n */\nconst depth = (tree) => {\n  return tree.nodes.length\n}\n\n/**\n *\n * @param {API.TreeData} tree\n * @returns {API.MerkleTreeNode}\n */\nexport const root = (tree) => {\n  return tree.nodes[0][0]\n}\n\n/**\n * @param {Uint8Array} source\n * @returns {API.MerkleTreeNode[]}\n */\nexport const split = (source) => {\n  const count = source.length / NodeSize\n  const chunks = new Array(count)\n  for (let n = 0; n < count; n++) {\n    const offset = n * NodeSize\n    const chunk = source.subarray(offset, offset + NodeSize)\n    chunks[n] = chunk\n  }\n  return chunks\n}\n\n/**\n * @param {API.Fr23Padded} source\n */\nexport const build = (source) => fromChunks(split(source))\n\n/**\n * @param {API.MerkleTreeNode[]} chunks\n */\nexport const fromChunks = (chunks) => {\n  if (chunks.length === 0) {\n    throw new RangeError('Empty source')\n  }\n\n  const leafs = chunks //await Promise.all(chunks.map(truncatedHash))\n  return fromLeafs(leafs)\n}\n\n/**\n * @param {API.MerkleTreeNode[]} leafs\n * @returns {API.PieceTree}\n */\nexport const fromLeafs = (leafs) => {\n  const tree = allocate(leafs.length)\n  // Set the padded leaf nodes\n  tree.nodes[depth(tree) - 1] = padLeafs(leafs)\n  let parentNodes = tree.nodes[depth(tree) - 1]\n  // Construct the Merkle tree bottom-up, starting from the leafs\n  // Note the -1 due to 0-indexing the root level\n  for (let level = depth(tree) - 2; level >= 0; level--) {\n    /** @type {API.MerkleTreeNode[]} */\n    const currentLevel = new Array(Math.ceil(parentNodes.length / 2))\n    // Traverse the level left to right\n    for (let i = 0; i + 1 < parentNodes.length; i = i + 2) {\n      currentLevel[Math.floor(i / 2)] = Proof.computeNode(\n        parentNodes[i],\n        parentNodes[i + 1]\n      )\n    }\n    tree.nodes[level] = currentLevel\n    parentNodes = currentLevel\n  }\n\n  return new PieceTree(tree)\n}\n\n/**\n * @param {API.MerkleTreeNode[]} leafs\n * @returns {API.MerkleTreeNode[]}\n */\nexport const padLeafs = (leafs) => {\n  const paddingAmount = (1 << Math.ceil(Math.log2(leafs.length))) - leafs.length\n  // arrays are zeroed by default in JS\n  const paddingLeafs = new Array(paddingAmount)\n\n  return [...leafs, ...paddingLeafs]\n}\n\n/**\n * @implements {API.PieceTree}\n */\nclass PieceTree {\n  /**\n   * @param {object} data\n   * @param {API.MerkleTreeNode[][]} data.nodes\n   * @param {number} data.height\n   */\n  constructor({ nodes, height }) {\n    this.nodes = nodes\n    this.height = height\n  }\n\n  get root() {\n    return root(this)\n  }\n  get leafs() {\n    const { nodes } = this\n    return nodes[nodes.length - 1]\n  }\n  get leafCount() {\n    return 2 ** this.height\n  }\n  /**\n   *\n   * @param {number} level\n   * @param {number} index\n   */\n  node(level, index) {\n    const { nodes } = this\n    return nodes[level][index]\n  }\n}\n", "import * as API from './api.js'\nimport {\n  OUT_BYTES_PER_QUAD,\n  FR_RATIO,\n  IN_BYTES_PER_QUAD,\n  MIN_PAYLOAD_SIZE,\n} from './constant.js'\n\n/**\n * Determine the additional bytes of zeroed padding to append to the\n * end of a resource of `size` length in order to fit within a pow2 piece while\n * leaving enough room for Fr32 padding (2 bits per 254).\n *\n * @param {number} payloadSize - The size of the payload.\n * @returns {number}\n */\nexport function toZeroPaddedSize(payloadSize) {\n  const size = Math.max(payloadSize, MIN_PAYLOAD_SIZE)\n  const highestBit = Math.floor(Math.log2(size))\n\n  const bound = Math.ceil(FR_RATIO * 2 ** (highestBit + 1))\n  // the size is either the closest pow2 number, or the next pow2 number if we\n  // don't have space for padding\n  return size <= bound ? bound : Math.ceil(FR_RATIO * 2 ** (highestBit + 2))\n}\n\n/**\n * Derives fr32 padded size from the source content size (that MUST be\n * multiples of {@link IN_BYTES_PER_QUAD}) in bytes.\n *\n * @param {number} size\n */\nexport const toPieceSize = (size) => toZeroPaddedSize(size) / FR_RATIO\n\n/**\n * Derives fr32 unpadded size from the Fr32 padded size in bytes.\n *\n * @param {number} size\n */\nexport const fromPieceSize = (size) => size * FR_RATIO\n\n/**\n * Takes source bytes that returns fr32 padded bytes.\n *\n * @param {Uint8Array} source\n * @param {Uint8Array} output\n * @returns {API.Fr23Padded}\n */\nexport const pad = (\n  source,\n  output = new Uint8Array(toPieceSize(source.length))\n) => {\n  const size = toZeroPaddedSize(source.byteLength)\n  // Calculate number of quads in the given source\n  const quadCount = size / IN_BYTES_PER_QUAD\n\n  // Cycle over four(4) 31-byte groups, leaving 1 byte in between:\n  // 31 + 1 + 31 + 1 + 31 + 1 + 31 = 127\n  for (let n = 0; n < quadCount; n++) {\n    const readOffset = n * IN_BYTES_PER_QUAD\n    const writeOffset = n * OUT_BYTES_PER_QUAD\n\n    // First 31 bytes + 6 bits are taken as-is (trimmed later)\n    output.set(source.subarray(readOffset, readOffset + 32), writeOffset)\n\n    // first 2-bit \"shim\" forced into the otherwise identical output\n    output[writeOffset + 31] &= 0b00111111\n\n    // copy next Fr32 preceded with the last two bits of the previous Fr32\n    for (let i = 32; i < 64; i++) {\n      output[writeOffset + i] =\n        (source[readOffset + i] << 2) | (source[readOffset + i - 1] >> 6)\n    }\n\n    // next 2-bit shim\n    output[writeOffset + 63] &= 0b00111111\n\n    for (let i = 64; i < 96; i++) {\n      output[writeOffset + i] =\n        (source[readOffset + i] << 4) | (source[readOffset + i - 1] >> 4)\n    }\n\n    // next 2-bit shim\n    output[writeOffset + 95] &= 0b00111111\n\n    for (let i = 96; i < 127; i++) {\n      output[writeOffset + i] =\n        (source[readOffset + i] << 6) | (source[readOffset + i - 1] >> 2)\n    }\n\n    // we shim last 2-bits by shifting the last byte by two bits\n    output[writeOffset + 127] = source[readOffset + 126] >> 2\n  }\n\n  return output\n}\n\n/**\n * @param {API.Fr23Padded} source\n * @param {Uint8Array} [out]\n */\nexport const unpad = (\n  source,\n  out = new Uint8Array(fromPieceSize(source.length))\n) => {\n  const chunks = source.length / 128\n  for (let chunk = 0; chunk < chunks; chunk++) {\n    const inOffNext = chunk * 128 + 1\n    const outOff = chunk * 127\n\n    let at = source[chunk * 128]\n\n    for (let i = 0; i < 32; i++) {\n      const next = source[i + inOffNext]\n\n      out[outOff + i] = at\n\n      at = next\n    }\n\n    out[outOff + 31] |= at << 6\n\n    for (let i = 32; i < 64; i++) {\n      const next = source[i + inOffNext]\n\n      out[outOff + i] = at >> 2\n      out[outOff + i] |= next << 6\n\n      at = next\n    }\n\n    out[outOff + 63] ^= (at << 6) ^ (at << 4)\n\n    for (let i = 64; i < 96; i++) {\n      const next = source[i + inOffNext]\n\n      out[outOff + i] = at >> 4\n      out[outOff + i] |= next << 4\n\n      at = next\n    }\n\n    out[outOff + 95] ^= (at << 4) ^ (at << 2)\n\n    for (let i = 96; i < 127; i++) {\n      const next = source[i + inOffNext]\n\n      out[outOff + i]\n      out[outOff + i] = at >> 6\n      out[outOff + i] |= next << 2\n\n      at = next\n    }\n  }\n\n  return out\n}\n", "import * as API from './api.js'\n\n/**\n * Returns the base 2 logarithm of the given `n`, rounded down.\n *\n * @param {API.uint64} n\n * @returns {number}\n */\nexport const log2Floor = (n) => {\n  let result = 0n\n  while ((n >>= 1n)) result++\n  return Number(result)\n}\n\n/**\n * Return the integer logarithm with ceiling for 64 bit unsigned ints.\n *\n * @param {API.uint64} n\n */\nexport const log2Ceil = (n) => (n <= 1n ? 0 : log2Floor(BigInt(n) - 1n) + 1)\n\n/**\n * @param {API.uint64} n\n */\nexport const trailingZeros64 = (n) => {\n  if (n === 0n) {\n    return 64\n  }\n\n  let count = 0\n  while ((n & 1n) === 0n) {\n    n >>= 1n\n    count++\n  }\n\n  return count\n}\n\n/**\n * @param {API.uint64} value\n */\nexport const onesCount64 = (value) => {\n  let count = 0\n  const mask = 1n\n\n  for (let i = 0n; i < 64n; i++) {\n    if ((value & (mask << i)) !== 0n) {\n      count++\n    }\n  }\n\n  return count\n}\n\n/**\n * @param {API.uint64} n\n * @returns {API.uint64}\n */\nexport const pow2 = (n) => 1n << n\n", "import * as API from '../../api.js'\nimport { log2Ceil, trailingZeros64 } from '../../uint64.js'\nimport {\n  PADDED_BYTES_PER_QUAD,\n  EXPANDED_BYTES_PER_QUAD,\n  LEAFS_PER_QUAD,\n} from '../../constant.js'\n\n/**\n * Validates that given `size` is a valid {@link API.UnpaddedPieceSize} and\n * returns {@link API.UnpaddedPieceSize} capturing the validation at the type\n * level. If given `size` is not a valid `UnpaddedPieceSize` throws an error.\n *\n * This function is a variation on {@link validate} that throws exceptions\n * instead of returning a {@link API.Result}.\n *\n * @param {number|API.uint64} size\n * @returns {API.PaddedSize}\n */\nexport const from = (size) => {\n  const result = tryFrom(size)\n  if (result.error) {\n    throw result.error\n  } else {\n    return result.ok\n  }\n}\n\n/**\n * Validates that given `size` is a valid {@link API.UnpaddedPieceSize} that is\n * a power of 2 multiple of 127. Returns {@link API.Result} with\n * `UnpaddedPieceSize` ok case and an Error in the error case.\n *\n * @param {API.uint64|number} input\n * @returns {API.Result<API.PaddedSize, Error>}\n */\nexport const tryFrom = (input) => {\n  const size = BigInt(input)\n  if (size < PADDED_BYTES_PER_QUAD) {\n    return {\n      error: new RangeError(\n        `Padded payload must contain at least ${PADDED_BYTES_PER_QUAD} bytes`\n      ),\n    }\n  }\n\n  if (size >> BigInt(trailingZeros64(size)) !== PADDED_BYTES_PER_QUAD) {\n    return {\n      error: new RangeError(\n        `Padded payload size must be (2\u207F * ${PADDED_BYTES_PER_QUAD})`\n      ),\n    }\n  }\n\n  return { ok: size }\n}\n\n/**\n * @param {API.PieceSize} size\n * @returns {API.PaddedSize}\n */\nexport const fromExpanded = (size) => fromQuads(size / EXPANDED_BYTES_PER_QUAD)\n\n/**\n * Takes `{@link API.PaddedPieceSize}` and returns corresponding\n * {@link API.PieceSize}.\n *\n * Please note that this function does not validate the input size and\n * relies that type-checker will ensure that user passes valid unpadded\n * piece size created with {@link from} or {@link validate} functions.\n *\n *\n * @see https://github.com/filecoin-project/go-state-types/blob/master/abi/piece.go#L14-L16\n *\n * @param {API.PaddedSize} size\n * @returns {API.PieceSize}\n */\nexport const toExpanded = (size) => toQauds(size) * EXPANDED_BYTES_PER_QUAD\n\n/**\n * Calculates the padded size of the piece from the given tree height.\n *\n * @param {number} height\n * @returns {API.uint64}\n */\nexport const fromHeight = (height) => {\n  // We calculate number of quads tree by calculating number of nodes tree\n  // at second layer. This works because we deal with a binary tree so first\n  // layer nodes will contain 2 leaves and second layer nodes will contain 4\n  // leaves hence number of quads.\n  const quads = 2n ** BigInt(height - 2)\n  return quads * PADDED_BYTES_PER_QUAD\n}\n\n/**\n * Calculates the height of the piece tree from unpadded size.\n *\n * @param {API.PaddedSize} size\n */\nexport const toHeight = (size) => log2Ceil(toWidth(size))\n\n/**\n * Takes `{@link API.PaddedPieceSize}` and returns corresponding\n * piece tree width (leaf count).\n *\n * @param {API.PaddedSize} size\n */\nexport const toWidth = (size) => toQauds(size) * LEAFS_PER_QUAD\n\n/**\n *\n * @param {API.uint64} width\n * @returns {API.PaddedSize}\n */\nexport const fromWidth = (width) => fromQuads(width / LEAFS_PER_QUAD)\n\n/**\n * @param {API.PaddedSize} size\n */\nconst toQauds = (size) => size / PADDED_BYTES_PER_QUAD\n\n/**\n *\n * @param {API.uint64} count\n * @returns {API.PaddedSize}\n */\nconst fromQuads = (count) => count * PADDED_BYTES_PER_QUAD\n", "import * as API from '../../api.js'\nimport {\n  PADDED_BYTES_PER_QUAD,\n  EXPANDED_BYTES_PER_QUAD,\n  LEAFS_PER_QUAD,\n} from '../../constant.js'\nimport { log2Ceil } from '../../uint64.js'\nimport * as Padded from './padded.js'\n\n/**\n * Takes the {@link API.Piece} sizing details (height and padding) and\n * calculates original payload size.\n *\n * @param {object} piece\n * @param {number} piece.height\n * @param {API.uint64} piece.padding\n */\nexport const fromPiece = ({ height, padding }) =>\n  Padded.fromHeight(height) - padding\n\n/**\n * Takes arbitrary payload size and calculates 0-padding required to\n * produce a {@link API.PaddedSize}.\n *\n * @param {API.uint64} size\n */\nexport const toPadding = (size) => toPadded(size) - size\n\n/**\n * Takes arbitrary payload size and calculates size after required 0-padding.\n *\n * @param {API.uint64} size\n * @returns {API.PaddedSize}\n */\nexport const toPadded = (size) => toQauds(size) * PADDED_BYTES_PER_QUAD\n\n/**\n * Takes arbitrary payload size and calculates the piece size after required\n * 0-padding and FR32 expansion is applied.\n *\n * @param {API.uint64} size\n * @returns {API.PieceSize}\n */\nexport const toExpanded = (size) => toQauds(size) * EXPANDED_BYTES_PER_QUAD\n\n/**\n * Takes arbitrary payload size and calculates width of the piece tree (leaf\n * count) that will be required to represent it.\n *\n * @param {API.uint64} size\n */\nexport const toWidth = (size) => toQauds(size) * LEAFS_PER_QUAD\n\n/**\n * Takes arbitrary payload size and calculates height of the piece tree that will be required to represent it.\n *\n * @param {API.uint64} size\n */\nexport const toHeight = (size) => log2Ceil(toWidth(size))\n\n/**\n * Takes arbitrary payload size and calculates number of quads that will be\n * required to represent it.\n *\n * @param {API.uint64} size\n */\nconst toQauds = (size) => {\n  // Number of quads required to fit given payload size.\n  // Since bigint division truncates we add another quads shy of 1 number of\n  // bytes to round up.\n  const quadCount = (size + PADDED_BYTES_PER_QUAD - 1n) / PADDED_BYTES_PER_QUAD\n  // Next we we log2 then pow2 with some rounding to ensure that result\n  // is 2 ^ n.\n  return 2n ** BigInt(log2Ceil(quadCount))\n}\n", "import * as API from '../../api.js'\nimport {\n  EXPANDED_BYTES_PER_QUAD,\n  EXPANDED_BYTES_PER_NODE,\n} from '../../constant.js'\nimport { log2Ceil, onesCount64 } from '../../uint64.js'\n\nexport { toExpanded as fromPadded, fromExpanded as toPadded } from './padded.js'\nexport { toExpanded as fromUnpadded } from './unpadded.js'\n\n/**\n * Validates that given `size` is a valid {@link API.PieceSize} that is a\n * power of 2. Returns {@link API.Result} with `PaddedPieceSize` ok case and an\n * Error in the error case.\n *\n * @see https://github.com/filecoin-project/go-state-types/blob/ff2ed169ff566458f2acd8b135d62e8ca27e7d0c/abi/piece.go#L18-L29\n *\n * @param {number|API.uint64} input\n * @returns {API.Result<API.PieceSize, RangeError>}\n */\nexport const tryFrom = (input) => {\n  const size = BigInt(input)\n  if (size < EXPANDED_BYTES_PER_QUAD) {\n    return {\n      error: RangeError(\n        `Minimum piece size is ${EXPANDED_BYTES_PER_QUAD} bytes`\n      ),\n    }\n  }\n\n  if (onesCount64(size) !== 1) {\n    return { error: RangeError('Piece size must be a power of 2') }\n  }\n\n  return { ok: size }\n}\n\n/**\n * Validates that given `size` is a valid {@link API.PieceSize} and\n * returns {@link API.PieceSize} capturing the validation at the type\n * level. If given `size` is not a valid `PaddedPieceSize` throws an error.\n *\n * This function is a variation on {@link validate} that throws exceptions\n * instead of returning a {@link API.Result}.\n *\n * @param {number|API.uint64} size\n */\nexport const from = (size) => {\n  const result = tryFrom(size)\n  if (result.error) {\n    throw result.error\n  } else {\n    return result.ok\n  }\n}\n\n/**\n * Calculates the {@link API.PieceSize} for the given height of the piece tree.\n *\n * @param {number} height\n * @returns {API.PieceSize}\n */\nexport const fromHeight = (height) => fromWidth(2n ** BigInt(height))\n\n/**\n * Calculates the height of the piece tree from unpadded size.\n *\n * @param {API.PieceSize} size\n */\nexport const toHeight = (size) => log2Ceil(toWidth(size))\n\n/**\n * Takes piece tree width (leaf count) and returns corresponding\n * {@link API.PieceSize}.\n *\n * @param {API.uint64} width\n * @returns {API.PieceSize}\n */\nexport const fromWidth = (width) => width * EXPANDED_BYTES_PER_NODE\n\n/**\n * Takes `{@link API.PaddedPieceSize}` and returns corresponding\n * piece tree width (leaf count).\n *\n * @param {API.PieceSize} size\n */\nexport const toWidth = (size) => size / EXPANDED_BYTES_PER_NODE\n", "import { varint } from 'multiformats'\nimport * as API from './api.js'\nimport {\n  IN_BYTES_PER_QUAD,\n  IN_BITS_FR,\n  OUT_BITS_FR,\n  MIN_PAYLOAD_SIZE,\n} from './constant.js'\nimport { SHA256 } from './ipld.js'\nimport { fromHeight as piceSizeFromHeight } from './piece/size/expanded.js'\n\n/**\n * @see https://github.com/multiformats/multicodec/pull/331/files\n */\nexport const name = /** @type {const} */ (\n  'fr32-sha2-256-trunc254-padded-binary-tree'\n)\n\n/**\n * @type {API.MulticodecCode<0x1011, typeof name>}\n * @see https://github.com/multiformats/multicodec/pull/331/files\n */\nexport const code = 0x1011\n\n/**\n * Varint is used to encode the tree height which is limited to 9 bytes.\n *\n * @see https://github.com/multiformats/unsigned-varint#practical-maximum-of-9-bytes-for-security\n */\nconst MAX_PADDING_SIZE = 9\n/**\n * One byte is used to store the tree height.\n */\nexport const HEIGHT_SIZE = 1\n\n/**\n * Amount of bytes used to store the tree root.\n */\nexport const ROOT_SIZE = SHA256.size\n\n/**\n * Size of the multihash digest in bytes.\n */\nexport const MAX_DIGEST_SIZE = MAX_PADDING_SIZE + HEIGHT_SIZE + SHA256.size\n\nexport const TAG_SIZE = varint.encodingLength(code)\n\n/**\n * Max size of the multihash in bytes\n */\nexport const MAX_SIZE =\n  TAG_SIZE + varint.encodingLength(MAX_DIGEST_SIZE) + MAX_DIGEST_SIZE\n\n/**\n * Since first byte in the digest is the tree height, the maximum height is 255.\n *\n * @type {255}\n */\nexport const MAX_HEIGHT = 255\n\n/**\n * Max payload is determined by the maximum height of the tree, which is limited\n * by the int we could store in one byte. We calculate the max piece size\n * and derive max payload size that can would produce it after FR32 padding.\n */\nexport const MAX_PAYLOAD_SIZE =\n  (piceSizeFromHeight(MAX_HEIGHT) * BigInt(IN_BITS_FR)) / BigInt(OUT_BITS_FR)\n\n/**\n * @param {API.Piece} piece\n * @returns {API.PieceDigest}\n */\nexport const fromPiece = ({ padding, height, root }) => {\n  const paddingLength = varint.encodingLength(Number(padding))\n  const size = paddingLength + HEIGHT_SIZE + ROOT_SIZE\n  const sizeLength = varint.encodingLength(size)\n\n  const multihashLength = TAG_SIZE + sizeLength + size\n\n  let offset = 0\n  const bytes = new Uint8Array(multihashLength)\n  varint.encodeTo(code, bytes, offset)\n  offset += TAG_SIZE\n\n  varint.encodeTo(size, bytes, offset)\n  offset += sizeLength\n\n  varint.encodeTo(Number(padding), bytes, offset)\n  offset += paddingLength\n\n  bytes[offset] = height\n  offset += HEIGHT_SIZE\n\n  bytes.set(root, offset)\n\n  return new Digest(bytes)\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {API.PieceDigest}\n */\nexport const fromBytes = (bytes) => new Digest(bytes)\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const toBytes = ({ digest }) => {\n  const SIZE_BYTE_LENGTH = varint.encodingLength(digest.length)\n\n  // number of bytes prefix will take up\n  const prefixByteLength = SIZE_BYTE_LENGTH + TAG_SIZE\n\n  // if digest is view within a buffer that has enough bytes in front to\n  // fit the prefix it may be already include a prefix in which case we\n  // will simply use a larger slice.\n  if (digest.byteOffset >= prefixByteLength) {\n    const bytes = new Uint8Array(\n      digest.buffer,\n      digest.byteOffset - prefixByteLength,\n      digest.byteOffset + digest.length\n    )\n\n    // if the prefix matches our bytes represent a multihash\n    const [tag, offset] = varint.decode(bytes)\n    if (tag === code && varint.decode(bytes, offset)[0] === digest.length) {\n      return bytes\n    }\n  }\n\n  const bytes = new Uint8Array(digest.length + prefixByteLength)\n  varint.encodeTo(code, bytes)\n  varint.encodeTo(digest.length, bytes, TAG_SIZE)\n  bytes.set(digest, prefixByteLength)\n\n  return bytes\n}\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const height = ({ digest }) => {\n  const [, offset] = varint.decode(digest)\n  return digest[offset]\n}\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const padding = ({ digest }) => {\n  const [padding] = varint.decode(digest)\n  return BigInt(padding)\n}\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const root = ({ digest }) => {\n  const [, offset] = varint.decode(digest)\n  return digest.subarray(\n    offset + HEIGHT_SIZE,\n    offset + HEIGHT_SIZE + SHA256.size\n  )\n}\n\n/**\n * @implements {API.PieceDigest}\n */\nclass Digest {\n  /**\n   * @param {Uint8Array} bytes\n   */\n  constructor(bytes) {\n    this.bytes = bytes\n    const [tag] = varint.decode(bytes)\n    if (tag !== code) {\n      throw new RangeError(`Expected multihash with code ${code}`)\n    }\n\n    let offset = TAG_SIZE\n    const [size, length] = varint.decode(bytes, offset)\n    offset += length\n    const digest = bytes.subarray(offset)\n\n    if (digest.length !== size) {\n      throw new RangeError(\n        `Invalid multihash size expected ${offset + size} bytes, got ${\n          bytes.length\n        } bytes`\n      )\n    }\n\n    this.digest = digest\n  }\n  get name() {\n    return name\n  }\n  get code() {\n    return code\n  }\n  get size() {\n    return this.digest.length\n  }\n  get padding() {\n    return padding(this)\n  }\n  get height() {\n    return height(this)\n  }\n  get root() {\n    return root(this)\n  }\n}\n", "import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode }: { name: Name, code: Code, encode(input: Uint8Array): Await<Uint8Array> }): Hasher<Name, Code> {\n  return new Hasher(name, code, encode)\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  digest (input: Uint8Array): Await<Digest.Digest<Code, number>> {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n", null, "import * as UCAN from '@ipld/dag-ucan'\nimport * as API from '@ucanto/interface'\nimport * as Link from './link.js'\nimport * as DAG from './dag.js'\nimport * as CAR from './car.js'\nimport * as CBOR from './cbor.js'\nimport * as Schema from './schema.js'\nimport { ok, error } from './result.js'\n\n/**\n * @deprecated\n * Import `isLink` from module directly\n */\nexport const isLink =\n  /** @type {(value:API.Proof) => value is API.UCANLink} */\n  (Link.isLink)\n\n/**\n *\n * @param {API.Proof} proof\n * @return {proof is API.Delegation}\n */\nexport const isDelegation = proof => !Link.isLink(proof)\n\n/**\n * Takes one or more delegations and returns all delegated capabilities in\n * UCAN 0.10 format, expanding all the special forms like `with: ucan:*` and\n * `can: *` to explicit forms.\n *\n * Note that this function only considers included proofs and ignores linked\n * proofs. It is up to the user of this function to resolve whatever proofs it\n * needs and build delegation with them before calling this function.\n *\n * Also note that this function does not validate the delegations and may\n * produce result containing capabilities that escalate, which for the validator\n * perspective is no different from not including such capabilities.\n *\n * @template {[API.Delegation, ...API.Delegation[]]} T\n * @param {T} delegations\n * @returns {API.InferAllowedFromDelegations<T>}\n */\nexport const allows = (...delegations) => {\n  /** @type {API.Allows} */\n  let allow = {}\n  for (const delegation of delegations) {\n    for (const { with: uri, can, nb } of iterateCapabilities(delegation)) {\n      const resource = allow[uri] || (allow[uri] = {})\n      const abilities = resource[can] || (resource[can] = [])\n      abilities.push({ ...nb })\n    }\n  }\n\n  return /** @type {API.InferAllowedFromDelegations<T>} */ (allow)\n}\n\n/**\n * Function takes a delegation and iterates over all the capabilities expanding\n * all the special forms like `with: ucan:*` and `can: *`.\n *\n * Note that this function only considers proofs that are included in the\n * delegation, linked proofs will not be resolved nor considered. It is up to\n * the user of this function to resolve whatever proofs it needs to consider\n * before calling this function.\n *\n * @param {API.Delegation} delegation\n * @returns {Iterable<API.Capability>}\n */\nconst iterateCapabilities = function* ({ issuer, capabilities, proofs }) {\n  for (const own of capabilities) {\n    // If `with` field is set to  `ucan:*` it implies re-delegation of all own\n    // and delegated capabilities.\n    if (own.with === 'ucan:*') {\n      // Fist we include own capabilities. Note that we can not expand `can`\n      // because it implicitly covers all possible options in the universe.\n      yield {\n        ...own,\n        with: issuer.did(),\n      }\n\n      // Next we iterate over all delegated capabilities including ones that\n      // match ability in the `own.can` field.\n      for (const proof of proofs) {\n        // We only consider proofs that are included and ignore linked proofs.\n        if (isDelegation(proof)) {\n          for (const capability of iterateCapabilities(proof)) {\n            // We attempt to match `capability.can` against `own.can` field\n            // if there is a match we include the capability otherwise we skip\n            const can = matchAbility(capability.can, own.can)\n            if (can) {\n              yield {\n                ...capability,\n                can,\n                // We do not know capability semantics so it is impossible\n                // for us to eliminate capabilities that do not satisfy imposed\n                // caveats (`own.nb`). Therefore we optimistically assume that\n                // `own.nb` further constraints `capability.nb` and do a shallow\n                // merge of the two. As a result we may include capabilities\n                // that during validation will be considered invalid due to\n                // constraint violations. While that is not ideal validator\n                // will treat them as if they were omitted and therefore it\n                // is a reasonable compromise.\n                nb: { ...capability.nb, ...Object(own.nb) },\n              }\n            }\n          }\n        }\n      }\n    } else {\n      yield own\n    }\n  }\n}\n\n/**\n * Function takes `can` field from the delegated capability and attempts to\n * match it against `can` field of the claimed capability. If there is a match\n * the function returns more specific `can` field of two, otherwise it returns\n * `null`.\n *\n * @param {API.Ability} provided\n * @param {API.Ability} claimed\n */\nconst matchAbility = (provided, claimed) => {\n  // If provided capability delegates all abilities we can derive any `can`\n  // from it so we return `claimed` as is.\n  if (provided === '*') {\n    return claimed\n  }\n  // If claimed capability delegates all abilities that includes any `can`\n  // so we return `provided` as is.\n  if (claimed === '*') {\n    return provided\n  }\n  // If claimed `can` is a pattern that includes `provided` `can` we return\n  // `provided` as is.\n  if (claimed.endsWith('/*') && provided.startsWith(claimed.slice(0, -1))) {\n    return provided\n  }\n  // If provided `can` is a pattern that includes `claimed` `can` we can derive\n  // `claimed` from it so we return `claimed` as is.\n  if (provided.endsWith('/*') && claimed.startsWith(provided.slice(0, -1))) {\n    return claimed\n  }\n  // If `can` fields are concrete and the same we have a match and can return it.\n  if (provided === claimed) {\n    return provided\n  }\n  // otherwise two are incompatible and we return null.\n  return null\n}\n\n/**\n * Represents UCAN chain view over the set of DAG UCAN nodes. You can think of\n * this as UCAN interface of the CAR.\n *\n * @template {API.Capabilities} C\n * @implements {API.Delegation<C>}\n * @extends {DelegationView<C>}\n */\nexport class Delegation {\n  /**\n   * @param {API.UCANBlock<C>} root\n   * @param {DAG.BlockStore} [blocks]\n   */\n  constructor(root, blocks = new Map()) {\n    this.root = root\n    this.blocks = blocks\n\n    Object.defineProperties(this, {\n      blocks: {\n        enumerable: false,\n      },\n    })\n  }\n\n  /**\n   * @returns {API.AttachedLinkSet}\n   */\n  get attachedLinks() {\n    const _attachedLinks = new Set()\n    const ucanView = this.data\n\n    // Get links from capabilities nb\n    for (const capability of ucanView.capabilities) {\n      /** @type {Link[]} */\n      const links = getLinksFromObject(capability)\n\n      for (const link of links) {\n        _attachedLinks.add(`${link}`)\n      }\n    }\n\n    // Get links from facts values\n    for (const fact of ucanView.facts) {\n      if (Link.isLink(fact)) {\n        _attachedLinks.add(`${fact}`)\n      } else {\n        /** @type {Link[]} */\n        // @ts-expect-error isLink does not infer value type\n        const links = Object.values(fact).filter(e => Link.isLink(e))\n\n        for (const link of links) {\n          _attachedLinks.add(`${link}`)\n        }\n      }\n    }\n\n    return _attachedLinks\n  }\n\n  get version() {\n    return this.data.version\n  }\n  get signature() {\n    return this.data.signature\n  }\n  get cid() {\n    return this.root.cid\n  }\n  link() {\n    return this.root.cid\n  }\n  get asCID() {\n    return this.cid\n  }\n  get bytes() {\n    return this.root.bytes\n  }\n  get data() {\n    const data = decode(this.root)\n    Object.defineProperties(this, { data: { value: data, enumerable: false } })\n    return data\n  }\n  /**\n   * Attach a block to the delegation DAG so it would be included in the\n   * block iterator.\n   * \u26A0\uFE0F You can only attach blocks that are referenced from the `capabilities`\n   * or `facts`.\n   *\n   * @param {API.Block} block\n   */\n  attach(block) {\n    if (!this.attachedLinks.has(`${block.cid.link()}`)) {\n      throw new Error(`given block with ${block.cid} is not an attached link`)\n    }\n    this.blocks.set(`${block.cid}`, block)\n  }\n  export() {\n    return exportDAG(this.root, this.blocks, this.attachedLinks)\n  }\n\n  /**\n   * @returns {API.Await<API.Result<Uint8Array, Error>>}\n   */\n  archive() {\n    return archive(this)\n  }\n\n  iterateIPLDBlocks() {\n    return exportDAG(this.root, this.blocks, this.attachedLinks)\n  }\n\n  /**\n   * @type {API.Proof[]}\n   */\n  get proofs() {\n    return proofs(this)\n  }\n\n  /**\n   * @type {API.Principal}\n   */\n  get issuer() {\n    return this.data.issuer\n  }\n\n  /**\n   * @type {API.Principal}\n   */\n  get audience() {\n    return this.data.audience\n  }\n\n  /**\n   * @returns {C}\n   */\n  get capabilities() {\n    return /** @type {C} */ (this.data.capabilities)\n  }\n\n  /**\n   * @returns {number}\n   */\n  get expiration() {\n    return this.data.expiration\n  }\n\n  /**\n   * @returns {undefined|number}\n   */\n  get notBefore() {\n    return this.data.notBefore\n  }\n\n  /**\n   * @returns {undefined|string}\n   */\n\n  get nonce() {\n    return this.data.nonce\n  }\n\n  /**\n   * @returns {API.Fact[]}\n   */\n  get facts() {\n    return this.data.facts\n  }\n\n  /**\n   * Iterate over the proofs\n   *\n   * @returns {IterableIterator<API.Delegation>}\n   */\n  iterate() {\n    return it(this)\n  }\n\n  delegate() {\n    return this\n  }\n\n  buildIPLDView() {\n    return this\n  }\n\n  /**\n   * @returns {API.DelegationJSON<this>}\n   */\n  toJSON() {\n    return /** @type {any} */ ({\n      ...this.data.toJSON(),\n      '/': this.cid.toString(),\n      prf: this.proofs.map(proof =>\n        isDelegation(proof) ? proof : { '/': proof.toString() }\n      ),\n    })\n  }\n}\n\n/**\n * Writes given `Delegation` chain into a content addressed archive (CAR)\n * buffer and returns it.\n *\n * @param {API.Delegation} delegation}\n * @returns {Promise<API.Result<Uint8Array, Error>>}\n */\nexport const archive = async delegation => {\n  try {\n    // Iterate over all of the blocks in the DAG and add them to the\n    // block store.\n    const store = new Map()\n    for (const block of delegation.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block)\n    }\n\n    // Then we we create a descriptor block to describe what this DAG represents\n    // and it to the block store as well.\n    const variant = await CBOR.write({\n      [`ucan@${delegation.version}`]: delegation.root.cid,\n    })\n    store.set(`${variant.cid}`, variant)\n\n    // And finally we encode the whole thing into a CAR.\n    const bytes = CAR.encode({\n      roots: [variant],\n      blocks: store,\n    })\n\n    return ok(bytes)\n  } catch (cause) {\n    return error(/** @type {Error} */ (cause))\n  }\n}\n\nexport const ArchiveSchema = Schema.variant({\n  'ucan@0.9.1': /** @type {Schema.Schema<API.UCANLink>} */ (\n    Schema.link({ version: 1 })\n  ),\n})\n\n/**\n * Extracts a `Delegation` chain from a given content addressed archive (CAR)\n * buffer. Assumes that the CAR contains a single root block corresponding to\n * the delegation variant.\n *\n * @param {Uint8Array} archive\n */\nexport const extract = async archive => {\n  try {\n    const { roots, blocks } = CAR.decode(archive)\n    const [root] = roots\n    if (root == null) {\n      return Schema.error('CAR archive does not contain a root block')\n    }\n    const { bytes } = root\n    const variant = CBOR.decode(bytes)\n    const [, link] = ArchiveSchema.match(variant)\n    return ok(view({ root: link, blocks }))\n  } catch (cause) {\n    return error(/** @type {Error} */ (cause))\n  }\n}\n\n/**\n * @param {API.Delegation} delegation\n * @returns {IterableIterator<API.Delegation>}\n */\nconst it = function* (delegation) {\n  for (const proof of delegation.proofs) {\n    if (isDelegation(proof)) {\n      yield* it(proof)\n      yield proof\n    }\n  }\n}\n\nconst decodeCache = new WeakMap()\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} block\n * @returns {UCAN.View<C>}\n */\nconst decode = ({ bytes }) => {\n  const data = decodeCache.get(bytes)\n  if (!data) {\n    const data = UCAN.decode(bytes)\n    decodeCache.set(bytes, data)\n    return data\n  }\n  return data\n}\n\n/**\n * Creates a new signed token with a given `options.issuer`. If expiration is\n * not set it defaults to 30 seconds from now. Returns UCAN in primary - IPLD\n * representation.\n *\n * @template {API.Capabilities} C\n * @param {API.DelegationOptions<C>} data\n * @param {API.EncodeOptions} [options]\n * @returns {Promise<API.Delegation<C>>}\n */\n\nexport const delegate = async (\n  { issuer, audience, proofs = [], attachedBlocks = new Map(), ...input },\n  options\n) => {\n  const links = []\n  const blocks = new Map()\n  for (const proof of proofs) {\n    if (!isDelegation(proof)) {\n      links.push(proof)\n    } else {\n      links.push(proof.cid)\n      for (const block of proof.export()) {\n        blocks.set(block.cid.toString(), block)\n      }\n    }\n  }\n\n  const data = await UCAN.issue({\n    ...input,\n    issuer,\n    audience,\n    proofs: links,\n  })\n  const { cid, bytes } = await UCAN.write(data, options)\n  decodeCache.set(cid, data)\n\n  /** @type {API.Delegation<C>} */\n  const delegation = new Delegation({ cid, bytes }, blocks)\n  Object.defineProperties(delegation, { proofs: { value: proofs } })\n\n  for (const block of attachedBlocks.values()) {\n    delegation.attach(block)\n  }\n\n  return delegation\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} root\n * @param {DAG.BlockStore} blocks\n * @param {API.AttachedLinkSet} attachedLinks\n * @returns {IterableIterator<API.Block>}\n */\n\nexport const exportDAG = function* (root, blocks, attachedLinks) {\n  for (const link of decode(root).proofs) {\n    // Check if block is included in this delegation\n    const root = /** @type {UCAN.Block} */ (blocks.get(`${link}`))\n    if (root) {\n      yield* exportSubDAG(root, blocks)\n    }\n  }\n\n  for (const link of attachedLinks.values()) {\n    const block = blocks.get(link)\n\n    if (block) {\n      // @ts-expect-error can get blocks with v0 and v1\n      yield block\n    }\n  }\n\n  yield root\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} root\n * @param {DAG.BlockStore} blocks\n * @returns {IterableIterator<API.Block>}\n */\nconst exportSubDAG = function* (root, blocks) {\n  for (const link of decode(root).proofs) {\n    // Check if block is included in this delegation\n    const root = /** @type {UCAN.Block} */ (blocks.get(`${link}`))\n    if (root) {\n      yield* exportSubDAG(root, blocks)\n    }\n  }\n\n  yield root\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {Iterable<API.Block>} dag\n * @returns {API.Delegation<C>}\n */\nexport const importDAG = dag => {\n  /** @type {Array<[string, API.Block]>} */\n  let entries = []\n  for (const block of dag) {\n    entries.push([block.cid.toString(), block])\n  }\n\n  const last = entries.pop()\n  if (!last) {\n    throw new RangeError('Empty DAG can not be turned into a delegation')\n  } else {\n    const [, root] = last\n\n    return new Delegation(\n      /** @type {API.UCANBlock<C>} */ (root),\n      new Map(entries)\n    )\n  }\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {object} dag\n * @param {API.UCANBlock<C>} dag.root\n * @param {DAG.BlockStore} [dag.blocks]\n * @returns {API.Delegation<C>}\n */\nexport const create = ({ root, blocks }) => new Delegation(root, blocks)\n\n/**\n * @template {API.Capabilities} C\n * @template [E=never]\n * @param {object} dag\n * @param {API.UCANLink<C>} dag.root\n * @param {DAG.BlockStore} dag.blocks\n * @param {E} [fallback]\n * @returns {API.Delegation<C>|E}\n */\nexport const view = ({ root, blocks }, fallback) => {\n  const block = DAG.get(root, blocks, null)\n  if (block == null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n  return create({ root: block, blocks })\n}\n\n/**\n * @param {API.Delegation} delegation\n */\nconst proofs = delegation => {\n  /** @type {API.Proof[]} */\n  const proofs = []\n  const { root, blocks } = delegation\n  // Iterate over proof links and materialize Delegation views.\n  for (const link of decode(root).proofs) {\n    // Check if linked proof is included in our blocks if so create delegation\n    // view otherwise use a link\n    const root = /** @type {UCAN.Block} */ (blocks.get(link.toString()))\n    proofs.push(root ? create({ root, blocks }) : link)\n  }\n\n  // we cache result of this computation as this property may get accessed\n  // more than once.\n  Object.defineProperty(delegation, 'proofs', { value: proofs })\n  return proofs\n}\n\n/**\n * @param {API.Capability<API.Ability, `${string}:${string}`, unknown>} obj\n */\nfunction getLinksFromObject(obj) {\n  /** @type {Link[]} */\n  const links = []\n\n  /**\n   * @param {object} obj\n   */\n  function recurse(obj) {\n    for (const key in obj) {\n      // @ts-expect-error record type not inferred\n      const value = obj[key]\n      if (Link.isLink(value)) {\n        // @ts-expect-error isLink does not infer value type\n        links.push(value)\n      } else if (value && typeof value === 'object') {\n        recurse(value)\n      }\n    }\n  }\n\n  recurse(obj)\n\n  return links\n}\n\nexport { Delegation as View }\n", "export const encoder = new TextEncoder()\nexport const decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {import('./ucan').ToString<T>} text\n * @returns {import('./ucan').ByteView<T>}\n */\nexport const encode = text => encoder.encode(text)\n\n/**\n * @template T\n * @param {import('./ucan').ByteView<T>} bytes\n * @returns {import('./ucan').ToString<T>}\n */\nexport const decode = bytes => decoder.decode(bytes)\n", "import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n", "var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n", "// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import * as varint from './varint.js'\nimport * as Digest from './hashes/digest.js'\nimport { base58btc } from './bases/base58.js'\nimport { base32 } from './bases/base32.js'\nimport { coerce } from './bytes.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   *\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport { CID, format, toJSON, fromJSON } from './cid.js'\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nconst DAG_PB_CODE = 0x70\n// eslint-disable-next-line\nconst SHA_256_CODE = 0x12\n\n/**\n * Simplified version of `create` for CIDv0.\n *\n * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n * @returns {API.LegacyLink}\n */\nexport const createLegacy = digest => CID.create(0, DAG_PB_CODE, digest)\n\n/**\n * Simplified version of `create` for CIDv1.\n *\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @param {Code} code - Content encoding format code.\n * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n * @returns {API.Link<Data, Code, Alg>}\n */\nexport const create = (code, digest) => CID.create(1, code, digest)\n\n/**\n * Type predicate returns true if value is the link.\n *\n * @template {API.Link<unknown, number, number, 0|1>} L\n * @param {unknown|L} value\n * @returns {value is L & CID}\n */\nexport const isLink = value => {\n  if (value == null) {\n    return false\n  }\n\n  const withSlash = /** @type {{'/'?: Uint8Array, bytes: Uint8Array}} */ (value)\n\n  if (withSlash['/'] != null && withSlash['/'] === withSlash.bytes) {\n    return true\n  }\n\n  const withAsCID = /** @type {{'asCID'?: unknown}} */ (value)\n\n  if (withAsCID.asCID === value) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Takes cid in a string representation and creates an instance. If `base`\n * decoder is not provided will use a default from the configuration. It will\n * throw an error if encoding of the CID is not compatible with supplied (or\n * a default decoder).\n *\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {API.Link<Data, Code, Alg, Ver>}\n */\nexport const parse = (source, base) => CID.parse(source, base)\n\nexport { format, toJSON, fromJSON }\n\n/**\n * Decoded a CID from its binary representation. The byte array must contain\n * only the CID with no additional bytes.\n *\n * An error will be thrown if the bytes provided do not contain a valid\n * binary representation of a CID.\n *\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n * @returns {API.Link<Data, Code, Alg, Ver>}\n */\nexport const decode = bytes => CID.decode(bytes)\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n", "import * as Digest from './digest.js'\n\n/**\n * @template {string} Name\n * @template {number} Code\n * @param {object} options\n * @param {Name} options.name\n * @param {Code} options.code\n * @param {(input: Uint8Array) => Await<Uint8Array>} options.encode\n */\nexport const from = ({ name, code, encode }) => new Hasher(name, code, encode)\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n *\n * @template {string} Name\n * @template {number} Code\n * @class\n * @implements {MultihashHasher<Code>}\n */\nexport class Hasher {\n  /**\n   *\n   * @param {Name} name\n   * @param {Code} code\n   * @param {(input: Uint8Array) => Await<Uint8Array>} encode\n   */\n  constructor (name, code, encode) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  /**\n   * @param {Uint8Array} input\n   * @returns {Await<Digest.Digest<Code, number>>}\n   */\n  digest (input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * @template {number} Alg\n * @typedef {import('./interface.js').MultihashHasher} MultihashHasher\n */\n\n/**\n * @template T\n * @typedef {Promise<T>|T} Await\n */\n", "import * as UCAN from \"./ucan.js\"\nimport { base58btc } from \"multiformats/bases/base58\"\nimport { varint } from \"multiformats\"\nimport * as UTF8 from \"./utf8.js\"\n\nconst DID_PREFIX = \"did:\"\nconst DID_PREFIX_SIZE = DID_PREFIX.length\nconst DID_KEY_PREFIX = `did:key:`\nconst DID_KEY_PREFIX_SIZE = DID_KEY_PREFIX.length\n\nexport const ED25519 = 0xed\nexport const RSA = 0x1205\nexport const P256 = 0x1200\nexport const P384 = 0x1201\nexport const P521 = 0x1202\nexport const SECP256K1 = 0xe7\nexport const BLS12381G1 = 0xea\nexport const BLS12381G2 = 0xeb\nexport const DID_CORE = 0x0d1d\nconst METHOD_OFFSET = varint.encodingLength(DID_CORE)\n\n/**\n * @typedef {typeof ED25519|typeof RSA|typeof P256|typeof P384|typeof P521|typeof DID_CORE} Code\n */\n\n/**\n * Parses a DID string into a DID buffer view\n *\n * @template {UCAN.DID} ID\n * @param {ID|UCAN.ToString<unknown>} did\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const parse = did => {\n  if (!did.startsWith(DID_PREFIX)) {\n    throw new RangeError(`Invalid DID \"${did}\", must start with 'did:'`)\n  } else if (did.startsWith(DID_KEY_PREFIX)) {\n    const key = base58btc.decode(did.slice(DID_KEY_PREFIX_SIZE))\n    return decode(key)\n  } else {\n    const suffix = UTF8.encode(did.slice(DID_PREFIX_SIZE))\n    const bytes = new Uint8Array(suffix.byteLength + METHOD_OFFSET)\n    varint.encodeTo(DID_CORE, bytes)\n    bytes.set(suffix, METHOD_OFFSET)\n    return new DID(bytes)\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.Principal<ID>} id\n * @returns {ID}\n */\nexport const format = id => id.did()\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.PrincipalView<ID>|UCAN.ByteView<UCAN.Principal<ID>>|UCAN.Principal<ID>|ID|UCAN.ToJSONString<unknown>} principal\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const from = principal => {\n  if (principal instanceof DID) {\n    return principal\n  } else if (principal instanceof Uint8Array) {\n    return decode(principal)\n  } else if (typeof principal === \"string\") {\n    return parse(principal)\n  } else {\n    return parse(principal.did())\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.ByteView<UCAN.Principal<ID>>} bytes\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const decode = bytes => {\n  const [code] = varint.decode(bytes)\n  const { buffer, byteOffset, byteLength } = bytes\n  switch (code) {\n    case P256:\n      if (bytes.length > 35) {\n        throw new RangeError(`Only p256-pub compressed is supported.`)\n      }\n    case ED25519:\n    case RSA:\n    case P384:\n    case P521:\n    case BLS12381G1:\n    case BLS12381G2:\n    case SECP256K1:\n      return /** @type {UCAN.PrincipalView<any>} */ (\n        new DIDKey(buffer, byteOffset, byteLength)\n      )\n    case DID_CORE:\n      return new DID(buffer, byteOffset, byteLength)\n    default:\n      throw new RangeError(\n        `Unsupported DID encoding, unknown multicode 0x${code.toString(16)}.`\n      )\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.Principal<ID>} principal\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const encode = principal => parse(principal.did())\n\n/**\n * @template {UCAN.DID} ID\n * @implements {UCAN.PrincipalView<ID>}\n * @extends {Uint8Array}\n */\nclass DID extends Uint8Array {\n  /**\n   * @returns {ID}\n   */\n  did() {\n    const bytes = new Uint8Array(this.buffer, this.byteOffset + METHOD_OFFSET)\n    return /** @type {ID} */ (`did:${UTF8.decode(bytes)}`)\n  }\n\n  toJSON() {\n    return this.did()\n  }\n}\n\n/**\n * @implements {UCAN.PrincipalView<UCAN.DID<\"key\">>}\n * @extends {DID<UCAN.DID<\"key\">>}\n */\nclass DIDKey extends DID {\n  /**\n   * @return {`did:key:${string}`}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this)}`\n  }\n}\n", "// @ts-check\n\nimport { coerce } from '../bytes.js'\n\n/**\n * @template T\n * @typedef {import('./interface.js').ByteView<T>} ByteView\n */\n\nexport const name = 'raw'\nexport const code = 0x55\n\n/**\n * @param {Uint8Array} node\n * @returns {ByteView<Uint8Array>}\n */\nexport const encode = (node) => coerce(node)\n\n/**\n * @param {ByteView<Uint8Array>} data\n * @returns {Uint8Array}\n */\nexport const decode = (data) => coerce(data)\n", "import * as UCAN from \"./ucan.js\"\nimport { varint } from \"multiformats\"\nimport { base64url, base64 } from \"multiformats/bases/base64\"\nimport * as UTF8 from \"./utf8.js\"\n\nexport const NON_STANDARD = 0xd000\nexport const ES256K = 0xd0e7\nexport const BLS12381G1 = 0xd0ea\nexport const BLS12381G2 = 0xd0eb\nexport const EdDSA = 0xd0ed\nexport const ES256 = 0xd01200\nexport const ES384 = 0xd01201\nexport const ES512 = 0xd01202\nexport const RS256 = 0xd01205\nexport const EIP191 = 0xd191\n\n/**\n * @param {number} code\n * @returns {string}\n */\nconst codeName = code => {\n  switch (code) {\n    case ES256K:\n      return \"ES256K\"\n    case BLS12381G1:\n      return \"BLS12381G1\"\n    case BLS12381G2:\n      return \"BLS12381G2\"\n    case EdDSA:\n      return \"EdDSA\"\n    case ES256:\n      return \"ES256\"\n    case ES384:\n      return \"ES384\"\n    case ES512:\n      return \"ES512\"\n    case RS256:\n      return \"RS256\"\n    case EIP191:\n      return \"EIP191\"\n    default:\n      throw new RangeError(\n        `Unknown signature algorithm code 0x${code.toString(16)}`\n      )\n  }\n}\n\n/**\n *\n * @param {string} name\n */\nexport const nameCode = name => {\n  switch (name) {\n    case \"ES256K\":\n      return ES256K\n    case \"BLS12381G1\":\n      return BLS12381G1\n    case \"BLS12381G2\":\n      return BLS12381G2\n    case \"EdDSA\":\n      return EdDSA\n    case \"ES256\":\n      return ES256\n    case \"ES384\":\n      return ES384\n    case \"ES512\":\n      return ES512\n    case \"RS256\":\n      return RS256\n    case \"EIP191\":\n      return EIP191\n    default:\n      return NON_STANDARD\n  }\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @implements {UCAN.SignatureView<T, A>}\n */\nexport class Signature extends Uint8Array {\n  get code() {\n    const [code] = varint.decode(this)\n    Object.defineProperties(this, { code: { value: code } })\n    return /** @type {A} */ (code)\n  }\n\n  get size() {\n    const value = size(this)\n    Object.defineProperties(this, { size: { value } })\n    return value\n  }\n  get algorithm() {\n    const value = algorithm(this)\n    Object.defineProperties(this, { algorithm: { value } })\n    return value\n  }\n\n  get raw() {\n    const { buffer, byteOffset, size, code } = this\n    const codeSize = varint.encodingLength(code)\n    const rawSize = varint.encodingLength(size)\n    const value = new Uint8Array(buffer, byteOffset + codeSize + rawSize, size)\n    Object.defineProperties(this, { raw: { value } })\n    return value\n  }\n\n  /**\n   * Verify that this signature was created by the given key.\n   *\n   * @param {UCAN.Crypto.Verifier<A>} signer\n   * @param {UCAN.ByteView<T>} payload\n   */\n  async verify(signer, payload) {\n    try {\n      if ((await signer.verify(payload, this)) === true) {\n        return { ok: {} }\n      } else {\n        throw new Error(\"Invalid signature\")\n      }\n    } catch (cause) {\n      return { error: /** @type {Error} */ (cause) }\n    }\n  }\n\n  toJSON() {\n    return toJSON(this)\n  }\n}\n\n/**\n * @param {UCAN.Signature} signature\n */\nconst algorithm = signature => {\n  const { code, raw, buffer, byteOffset } = signature\n  if (code === NON_STANDARD) {\n    const offset =\n      raw.byteLength +\n      varint.encodingLength(code) +\n      varint.encodingLength(raw.byteLength)\n    const bytes = new Uint8Array(buffer, byteOffset + offset)\n    return UTF8.decode(bytes)\n  } else {\n    return codeName(code)\n  }\n}\n\n/**\n * @param {UCAN.Signature} signature\n */\nconst size = signature => {\n  const offset = varint.encodingLength(signature.code)\n  const [size] = varint.decode(\n    new Uint8Array(signature.buffer, signature.byteOffset + offset)\n  )\n  return size\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {A} code\n * @param {Uint8Array} raw\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const create = (code, raw) => {\n  const _ = codeName(code)\n  const codeSize = varint.encodingLength(code)\n  const rawSize = varint.encodingLength(raw.byteLength)\n\n  /** @type {Signature<T, A>} */\n  const signature = new Signature(codeSize + rawSize + raw.byteLength)\n  varint.encodeTo(code, signature)\n  varint.encodeTo(raw.byteLength, signature, codeSize)\n  signature.set(raw, codeSize + rawSize)\n  Object.defineProperties(signature, {\n    code: { value: code },\n    size: { value: raw.byteLength },\n  })\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @param {string} name\n * @param {Uint8Array} raw\n * @return {UCAN.SignatureView<T>}\n */\nexport const createNamed = (name, raw) => {\n  const code = nameCode(name)\n  return code === NON_STANDARD\n    ? createNonStandard(name, raw)\n    : create(code, raw)\n}\n\n/**\n * @template {unknown} T\n * @param {string} name\n * @param {Uint8Array} raw\n * @return {UCAN.SignatureView<T, typeof NON_STANDARD>}\n */\nexport const createNonStandard = (name, raw) => {\n  const code = NON_STANDARD\n  const codeSize = varint.encodingLength(code)\n  const rawSize = varint.encodingLength(raw.byteLength)\n  const nameBytes = UTF8.encode(name)\n  /** @type {Signature<T, typeof NON_STANDARD>} */\n  const signature = new Signature(\n    codeSize + rawSize + raw.byteLength + nameBytes.byteLength\n  )\n  varint.encodeTo(code, signature)\n  varint.encodeTo(raw.byteLength, signature, codeSize)\n  signature.set(raw, codeSize + rawSize)\n  signature.set(nameBytes, codeSize + rawSize + raw.byteLength)\n\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>} bytes\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const view = bytes =>\n  new Signature(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>} bytes\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const decode = bytes => {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError(\n      `Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(\n        bytes\n      )}`\n    )\n  }\n\n  /** @type {UCAN.SignatureView<T, A>} */\n  const signature = view(bytes)\n  const { code, algorithm, raw } = signature\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.Signature<T, A>} signature\n * @returns {UCAN.ByteView<UCAN.Signature<T, A>>}\n */\nexport const encode = signature => decode(signature)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @template {string} [Prefix=\"u\"]\n * @param {UCAN.Signature<T, A>} signature\n * @param {UCAN.MultibaseEncoder<Prefix>} [base]\n * @returns {UCAN.ToString<UCAN.Signature<T, A>>}\n */\nexport const format = (signature, base) => (base || base64url).encode(signature)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @template {string} [Prefix=\"u\"]\n * @param {UCAN.ToString<UCAN.Signature<T, A>>} signature\n * @param {UCAN.MultibaseDecoder<Prefix>} [base]\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const parse = (signature, base) =>\n  /** @type {UCAN.SignatureView<T, A>} */ (\n    decode((base || base64url).decode(signature))\n  )\n\n/**\n * @template {UCAN.Signature} Signature\n * @param {Signature} signature\n * @returns {UCAN.SignatureJSON<Signature>}\n */\nexport const toJSON = signature => ({\n  \"/\": { bytes: base64.baseEncode(signature) },\n})\n\n/**\n * @template {unknown} T\n * @template {UCAN.SigAlg} A\n * @param {UCAN.SignatureJSON<UCAN.Signature<T, A>>} json\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const fromJSON = json => decode(base64.baseDecode(json[\"/\"].bytes))\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "import * as UCAN from \"./ucan.js\"\nimport * as UTF8 from \"./utf8.js\"\nimport * as Link from \"multiformats/link\"\nimport { identity } from \"multiformats/hashes/identity\"\nimport * as DID from \"./did.js\"\nimport * as raw from \"multiformats/codecs/raw\"\nimport * as Signature from \"./signature.js\"\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @returns {UCAN.Payload<C>}\n */\nexport const readPayload = data =>\n  readPayloadWith(data, {\n    readPrincipal,\n    readProof,\n  })\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @returns {UCAN.Payload<C>}\n */\nexport const readJWTPayload = data =>\n  readPayloadWith(data, {\n    readPrincipal: readStringPrincipal,\n    readProof: readStringProof,\n  })\n/**\n *\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @param {object} readers\n * @param {(source:unknown, context:string) => UCAN.Principal} readers.readPrincipal\n * @param {(source:unknown, context:string) => UCAN.Link} readers.readProof\n * @returns {UCAN.Payload<C>}\n */\nconst readPayloadWith = (data, { readPrincipal, readProof }) => ({\n  iss: readPrincipal(data.iss, \"iss\"),\n  aud: readPrincipal(data.aud, \"aud\"),\n  att: readCapabilities(data.att, \"att\"),\n  prf: readOptionalArray(data.prf, readProof, \"prf\") || [],\n  exp: readNullable(data.exp === Infinity ? null : data.exp, readInt, \"exp\"),\n  nbf: readOptional(data.nbf, readInt, \"nbf\"),\n  fct: readOptionalArray(data.fct, readFact, \"fct\") || [],\n  nnc: readOptional(data.nnc, readString, \"nnc\"),\n})\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>|unknown} source\n */\nexport const readSignature = source => {\n  if (source instanceof Uint8Array) {\n    return Signature.decode(source)\n  } else {\n    throw new TypeError(\n      `Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(\n        source\n      )}`\n    )\n  }\n}\n\n/**\n * @param {unknown} input\n * @param {string} name\n * @returns {number}\n */\nexport const readInt = (input, name) =>\n  Number.isInteger(input)\n    ? /** @type {number} */ (input)\n    : ParseError.throw(\n        `Expected ${name} to be integer, instead got ${JSON.stringify(input)}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n */\n\nexport const readCapability = (input, context) =>\n  readStruct(input, asCapability, context)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {unknown|C} input\n * @param {string} context\n * @returns {C}\n */\nexport const readCapabilities = (input, context) =>\n  /** @type {C} */ (readArray(input, readCapability, context))\n\n/**\n * @template {UCAN.Capability} C\n * @param {object & {can?:unknown, with?:unknown}|C} input\n * @returns {C}\n */\nexport const asCapability = input =>\n  /** @type {C} */ ({\n    ...input,\n    can: readAbility(input.can),\n    with: readResource(input.with),\n  })\n\n/**\n * @param {unknown} input\n */\nconst readAbility = input =>\n  typeof input !== \"string\"\n    ? ParseError.throw(\n        `Capability has invalid 'can: ${JSON.stringify(\n          input\n        )}', value must be a string`\n      )\n    : input.slice(1, -1).includes(\"/\")\n    ? /** @type {UCAN.Ability} */ (input.toLocaleLowerCase())\n    : input === \"*\"\n    ? input\n    : ParseError.throw(\n        `Capability has invalid 'can: \"${input}\"', value must have at least one path segment`\n      )\n\n/**\n * @param {unknown} input\n */\nconst readResource = input =>\n  typeof input !== \"string\"\n    ? ParseError.throw(\n        `Capability has invalid 'with: ${JSON.stringify(\n          input\n        )}', value must be a string`\n      )\n    : parseURL(input) ||\n      ParseError.throw(\n        `Capability has invalid 'with: \"${input}\"', value must be a valid URI string`\n      )\n\n/**\n * @param {string} input\n */\nconst parseURL = input => {\n  try {\n    new URL(input)\n    return input\n  } catch (_) {\n    return null\n  }\n}\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:unknown, context:string) => T} read\n * @param {string} context\n * @returns {T[]}\n */\nexport const readArray = (input, read, context) =>\n  Array.isArray(input)\n    ? input.map((element, n) => read(element, `${context}[${n}]`))\n    : ParseError.throw(`${context} must be an array`)\n\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:unknown, context: string) => T} reader\n * @param {string} context\n * @returns {T[]|undefined}\n */\nexport const readOptionalArray = (input, reader, context) =>\n  input === undefined ? input : readArray(input, reader, context)\n\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:object) => T} reader\n * @param {string} context\n * @returns {T}\n */\nexport const readStruct = (input, reader, context) =>\n  input != null && typeof input === \"object\"\n    ? reader(input)\n    : ParseError.throw(\n        `${context} must be of type object, instead got ${input}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n * @returns {UCAN.Fact}\n */\nexport const readFact = (input, context) => readStruct(input, Object, context)\n\n/**\n * @param {unknown} source\n * @param {string} context\n * @returns {UCAN.Link}\n */\nexport const readProof = (source, context) =>\n  Link.isLink(source)\n    ? /** @type {UCAN.Link} */ (source)\n    : fail(\n        `Expected ${context} to be IPLD link, instead got ${JSON.stringify(\n          source\n        )}`\n      )\n\n/**\n * @param {unknown} source\n * @param {string} context\n * @returns {UCAN.Link}\n */\nexport const readStringProof = (source, context) =>\n  parseProof(readString(source, context))\n\n/**\n * @param {string} source\n * @returns {UCAN.Link}\n */\nconst parseProof = source => {\n  // First we attempt to read proof as CID, if we fail fallback to reading it as\n  // an inline proof.\n  try {\n    return Link.parse(source)\n  } catch (error) {\n    return Link.create(raw.code, identity.digest(UTF8.encode(source)))\n  }\n}\n\n/**\n * @param {unknown} input\n * @param {string} context\n */\nexport const readPrincipal = (input, context) =>\n  DID.decode(readBytes(input, context))\n\n/**\n * @param {unknown} source\n * @param {string} context\n */\nexport const readStringPrincipal = (source, context) =>\n  DID.parse(readString(source, context))\n\n/**\n * @template T\n * @param {unknown} source\n * @param {(source:unknown, context:string) => T} read\n * @param {string} [context]\n * @returns {T|undefined}\n */\nexport const readOptional = (source, read, context = \"Field\") =>\n  source !== undefined ? read(source, context) : undefined\n\n/**\n * @template T\n * @param {unknown} source\n * @param {(source:unknown, context:string) => T} read\n * @param {string} context\n * @returns {T|null}\n */\nexport const readNullable = (source, read, context) =>\n  source === null ? null : read(source, context)\n\n/**\n * @param {unknown} source\n * @param {string} [context]\n * @returns {string}\n */\nexport const readString = (source, context = \"Field\") =>\n  typeof source === \"string\"\n    ? source\n    : fail(`${context} has invalid value ${source}`)\n\n/**\n *\n * @param {unknown} source\n * @param {string} context\n * @returns {Uint8Array}\n */\nexport const readBytes = (source, context) =>\n  source instanceof Uint8Array\n    ? source\n    : fail(\n        `Expected ${context} to be Uint8Array, instead got ${JSON.stringify(\n          source\n        )}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n * @returns {UCAN.Version}\n */\nexport const readVersion = (input, context) =>\n  /\\d+\\.\\d+\\.\\d+/.test(/** @type {string} */ (input))\n    ? /** @type {UCAN.Version} */ (input)\n    : ParseError.throw(`Invalid version '${context}: ${JSON.stringify(input)}'`)\n\n/**\n * @template {string|number|boolean|null} T\n * @param {unknown} input\n * @param {T} literal\n * @param {string} context\n * @returns {T}\n */\nexport const readLiteral = (input, literal, context) =>\n  input === literal\n    ? literal\n    : ParseError.throw(\n        `Expected ${context} to be a ${JSON.stringify(\n          literal\n        )} instead got ${JSON.stringify(input)}`\n      )\n\nexport class ParseError extends TypeError {\n  get name() {\n    return \"ParseError\"\n  }\n  /**\n   * @param {string} message\n   * @returns {never}\n   */\n  static throw(message) {\n    throw new this(message)\n  }\n}\n\n/**\n * @param {string} reason\n */\nexport const fail = reason => ParseError.throw(reason)\n\nexport { fail as throw }\n", "import { Type } from '../token.js'\nimport { encodeCustom } from '../encode.js'\nimport { encodeErrPrefix } from '../common.js'\nimport { asU8A, fromString } from '../byte-utils.js'\n\n/**\n * @typedef {import('../../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../token').Token} Token\n * @typedef {import('../bl').Bl} Bl\n */\n\nclass JSONEncoder extends Array {\n  constructor () {\n    super()\n    /** @type {{type:Type,elements:number}[]} */\n    this.inRecursive = []\n  }\n\n  /**\n   * @param {Bl} buf\n   */\n  prefix (buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1]\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++\n        if (recurs.elements !== 1) { // >first\n          buf.push([44]) // ','\n        }\n      }\n      if (recurs.type === Type.map) {\n        recurs.elements++\n        if (recurs.elements !== 1) { // >first\n          if (recurs.elements % 2 === 1) { // key\n            buf.push([44]) // ','\n          } else {\n            buf.push([58]) // ':'\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.uint.major] (buf, token) {\n    this.prefix(buf)\n    const is = String(token.value)\n    const isa = []\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i)\n    }\n    buf.push(isa)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.negint.major] (buf, token) {\n    // @ts-ignore hack\n    this[Type.uint.major](buf, token)\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.bytes.major] (_buf, _token) {\n    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.string.major] (buf, token) {\n    this.prefix(buf)\n    // buf.push(34) // '\"'\n    // encodeUtf8(token.value, byts)\n    // buf.push(34) // '\"'\n    const byts = fromString(JSON.stringify(token.value))\n    buf.push(byts.length > 32 ? asU8A(byts) : byts)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.array.major] (buf, _token) {\n    this.prefix(buf)\n    this.inRecursive.push({ type: Type.array, elements: 0 })\n    buf.push([91]) // '['\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.map.major] (buf, _token) {\n    this.prefix(buf)\n    this.inRecursive.push({ type: Type.map, elements: 0 })\n    buf.push([123]) // '{'\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.tag.major] (_buf, _token) {}\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.float.major] (buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop()\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]) // ']'\n        } else if (recurs.type === Type.map) {\n          buf.push([125]) // '}'\n        /* c8 ignore next 3 */\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!')\n        }\n        return\n      }\n      /* c8 ignore next 2 */\n      throw new Error('Unexpected break; this should not happen!')\n    }\n    if (token.value === undefined) {\n      throw new Error(`${encodeErrPrefix} unsupported type: undefined`)\n    }\n\n    this.prefix(buf)\n    if (token.type.name === 'true') {\n      buf.push([116, 114, 117, 101]) // 'true'\n      return\n    } else if (token.type.name === 'false') {\n      buf.push([102, 97, 108, 115, 101]) // 'false'\n      return\n    } else if (token.type.name === 'null') {\n      buf.push([110, 117, 108, 108]) // 'null'\n      return\n    }\n\n    // number\n    const is = String(token.value)\n    const isa = []\n    let dp = false\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i)\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) { // '[.eE]'\n        dp = true\n      }\n    }\n    if (!dp) { // need a decimal point for floats\n      isa.push(46) // '.'\n      isa.push(48) // '0'\n    }\n    buf.push(isa)\n  }\n}\n\n// The below code is mostly taken and modified from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n// function encodeUtf8 (string, byts) {\n//   let codePoint\n//   const length = string.length\n//   let leadSurrogate = null\n\n//   for (let i = 0; i < length; ++i) {\n//     codePoint = string.charCodeAt(i)\n\n//     // is surrogate component\n//     if (codePoint > 0xd7ff && codePoint < 0xe000) {\n//       // last char was a lead\n//       if (!leadSurrogate) {\n//         // no lead yet\n//         /* c8 ignore next 9 */\n//         if (codePoint > 0xdbff) {\n//           // unexpected trail\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         } else if (i + 1 === length) {\n//           // unpaired lead\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         }\n\n//         // valid lead\n//         leadSurrogate = codePoint\n\n//         continue\n//       }\n\n//       // 2 leads in a row\n//       /* c8 ignore next 5 */\n//       if (codePoint < 0xdc00) {\n//         byts.push(0xef, 0xbf, 0xbd)\n//         leadSurrogate = codePoint\n//         continue\n//       }\n\n//       // valid surrogate pair\n//       codePoint = (leadSurrogate - 0xd800 << 10 | codePoint - 0xdc00) + 0x10000\n//     /* c8 ignore next 4 */\n//     } else if (leadSurrogate) {\n//       // valid bmp char, but last char was a lead\n//       byts.push(0xef, 0xbf, 0xbd)\n//     }\n\n//     leadSurrogate = null\n\n//     // encode utf8\n//     if (codePoint < 0x80) {\n//       // special JSON escapes\n//       switch (codePoint) {\n//         case 8: // '\\b'\n//           byts.push(92, 98) // '\\\\b'\n//           continue\n//         case 9: // '\\t'\n//           byts.push(92, 116) // '\\\\t'\n//           continue\n//         case 10: // '\\n'\n//           byts.push(92, 110) // '\\\\n'\n//           continue\n//         case 12: // '\\f'\n//           byts.push(92, 102) // '\\\\f'\n//           continue\n//         case 13: // '\\r'\n//           byts.push(92, 114) // '\\\\r'\n//           continue\n//         case 34: // '\"'\n//           byts.push(92, 34) // '\\\\\"'\n//           continue\n//         case 92: // '\\\\'\n//           byts.push(92, 92) // '\\\\\\\\'\n//           continue\n//       }\n\n//       byts.push(codePoint)\n//     } else if (codePoint < 0x800) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0x6 | 0xc0,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else if (codePoint < 0x10000) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0xc | 0xe0,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     /* c8 ignore next 9 */\n//     } else if (codePoint < 0x110000) {\n//       byts.push(\n//         codePoint >> 0x12 | 0xf0,\n//         codePoint >> 0xc & 0x3f | 0x80,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else {\n//       /* c8 ignore next 2 */\n//       throw new Error('Invalid code point')\n//     }\n//   }\n// }\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${encodeErrPrefix} complex map keys are not supported`)\n  }\n  const keyToken1 = e1[0]\n  const keyToken2 = e2[0]\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`)\n  }\n  if (keyToken1 < keyToken2) {\n    return -1\n  }\n  if (keyToken1 > keyToken2) {\n    return 1\n  }\n  /* c8 ignore next 1 */\n  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`)\n}\n\nconst defaultEncodeOptions = { addBreakTokens: true, mapSorter }\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, new JSONEncoder(), options)\n}\n\nexport { encode }\n", "import { decode as _decode, decodeFirst as _decodeFirst } from '../decode.js'\nimport { Token, Type } from '../token.js'\nimport { decodeCodePointsArray } from '../byte-utils.js'\nimport { decodeErrPrefix } from '../common.js'\n\n/**\n * @typedef {import('../../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../../interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n    /** @type {string[]} */\n    this.modeStack = ['value']\n    this.lastToken = ''\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  /**\n   * @returns {number}\n   */\n  ch () {\n    return this.data[this._pos]\n  }\n\n  /**\n   * @returns {string}\n   */\n  currentMode () {\n    return this.modeStack[this.modeStack.length - 1]\n  }\n\n  skipWhitespace () {\n    let c = this.ch()\n    // @ts-ignore\n    while (c === 32 /* ' ' */ || c === 9 /* '\\t' */ || c === 13 /* '\\r' */ || c === 10 /* '\\n' */) {\n      c = this.data[++this._pos]\n    }\n  }\n\n  /**\n   * @param {number[]} str\n   */\n  expect (str) {\n    if (this.data.length - this._pos < str.length) {\n      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this._pos}`)\n    }\n    for (let i = 0; i < str.length; i++) {\n      if (this.data[this._pos++] !== str[i]) {\n        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`)\n      }\n    }\n  }\n\n  parseNumber () {\n    const startPos = this._pos\n    let negative = false\n    let float = false\n\n    /**\n     * @param {number[]} chars\n     */\n    const swallow = (chars) => {\n      while (!this.done()) {\n        const ch = this.ch()\n        if (chars.includes(ch)) {\n          this._pos++\n        } else {\n          break\n        }\n      }\n    }\n\n    // lead\n    if (this.ch() === 45) { // '-'\n      negative = true\n      this._pos++\n    }\n    if (this.ch() === 48) { // '0'\n      this._pos++\n      if (this.ch() === 46) { // '.'\n        this._pos++\n        float = true\n      } else {\n        return new Token(Type.uint, 0, this._pos - startPos)\n      }\n    }\n    swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    if (negative && this._pos === startPos + 1) {\n      throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`)\n    }\n    if (!this.done() && this.ch() === 46) { // '.'\n      if (float) {\n        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`)\n      }\n      float = true\n      this._pos++\n      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    }\n    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) { // '[eE]'\n      float = true\n      this._pos++\n      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) { // '+', '-'\n        this._pos++\n      }\n      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    }\n    // @ts-ignore\n    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos))\n    const num = parseFloat(numStr)\n    if (float) {\n      return new Token(Type.float, num, this._pos - startPos)\n    }\n    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {\n      return new Token(num >= 0 ? Type.uint : Type.negint, num, this._pos - startPos)\n    }\n    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this._pos - startPos)\n  }\n\n  /**\n   * @returns {Token}\n   */\n  parseString () {\n    /* c8 ignore next 4 */\n    if (this.ch() !== 34) { // '\"'\n      // this would be a programming error\n      throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}; this shouldn't happen`)\n    }\n    this._pos++\n\n    // check for simple fast-path, all printable ascii, no escapes\n    // >0x10000 elements may fail fn.apply() (http://stackoverflow.com/a/22747272/680742)\n    for (let i = this._pos, l = 0; i < this.data.length && l < 0x10000; i++, l++) {\n      const ch = this.data[i]\n      if (ch === 92 || ch < 32 || ch >= 128) { // '\\', ' ', control-chars or non-trivial\n        break\n      }\n      if (ch === 34) { // '\"'\n        // @ts-ignore\n        const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i))\n        this._pos = i + 1\n        return new Token(Type.string, str, l)\n      }\n    }\n\n    const startPos = this._pos\n    const chars = []\n\n    const readu4 = () => {\n      if (this._pos + 4 >= this.data.length) {\n        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this._pos}`)\n      }\n      let u4 = 0\n      for (let i = 0; i < 4; i++) {\n        let ch = this.ch()\n        if (ch >= 48 && ch <= 57) { // '0' && '9'\n          ch -= 48\n        } else if (ch >= 97 && ch <= 102) { // 'a' && 'f'\n          ch = ch - 97 + 10\n        } else if (ch >= 65 && ch <= 70) { // 'A' && 'F'\n          ch = ch - 65 + 10\n        } else {\n          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this._pos}`)\n        }\n        u4 = u4 * 16 + ch\n        this._pos++\n      }\n      return u4\n    }\n\n    // mostly taken from feross/buffer and adjusted to fit\n    const readUtf8Char = () => {\n      const firstByte = this.ch()\n      let codePoint = null\n      /* c8 ignore next 1 */\n      let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n      if (this._pos + bytesPerSequence > this.data.length) {\n        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this._pos}`)\n      }\n\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        /* c8 ignore next 6 */\n        // this case is dealt with by the caller function\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = this.data[this._pos + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = this.data[this._pos + 1]\n          thirdByte = this.data[this._pos + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = this.data[this._pos + 1]\n          thirdByte = this.data[this._pos + 2]\n          fourthByte = this.data[this._pos + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n\n      /* c8 ignore next 5 */\n      if (codePoint === null) {\n        // we did not generate a valid codePoint so insert a\n        // replacement char (U+FFFD) and advance only 1 byte\n        codePoint = 0xfffd\n        bytesPerSequence = 1\n      } else if (codePoint > 0xffff) {\n        // encode to utf16 (surrogate pair dance)\n        codePoint -= 0x10000\n        chars.push(codePoint >>> 10 & 0x3ff | 0xd800)\n        codePoint = 0xdc00 | codePoint & 0x3ff\n      }\n\n      chars.push(codePoint)\n      this._pos += bytesPerSequence\n    }\n\n    // TODO: could take the approach of a quick first scan for special chars like encoding/json/decode.go#unquoteBytes\n    // and converting all of the ascii chars from the base array in bulk\n    while (!this.done()) {\n      const ch = this.ch()\n      let ch1\n      switch (ch) {\n        case 92: // '\\'\n          this._pos++\n          if (this.done()) {\n            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this._pos}`)\n          }\n          ch1 = this.ch()\n          this._pos++\n          switch (ch1) {\n            case 34: // '\"'\n            case 39: // '\\''\n            case 92: // '\\'\n            case 47: // '/'\n              chars.push(ch1)\n              break\n            case 98: // 'b'\n              chars.push(8)\n              break\n            case 116: // 't'\n              chars.push(9)\n              break\n            case 110: // 'n'\n              chars.push(10)\n              break\n            case 102: // 'f'\n              chars.push(12)\n              break\n            case 114: // 'r'\n              chars.push(13)\n              break\n            case 117: // 'u'\n              chars.push(readu4())\n              break\n            default:\n              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this._pos}`)\n          }\n          break\n        case 34: // '\"'\n          this._pos++\n          return new Token(Type.string, decodeCodePointsArray(chars), this._pos - startPos)\n        default:\n          if (ch < 32) { // ' '\n            throw new Error(`${decodeErrPrefix} invalid control character at position ${this._pos}`)\n          } else if (ch < 0x80) {\n            chars.push(ch)\n            this._pos++\n          } else {\n            readUtf8Char()\n          }\n      }\n    }\n\n    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this._pos}`)\n  }\n\n  /**\n   * @returns {Token}\n   */\n  parseValue () {\n    switch (this.ch()) {\n      case 123: // '{'\n        this.modeStack.push('obj-start')\n        this._pos++\n        return new Token(Type.map, Infinity, 1)\n      case 91: // '['\n        this.modeStack.push('array-start')\n        this._pos++\n        return new Token(Type.array, Infinity, 1)\n      case 34: { // '\"'\n        return this.parseString()\n      }\n      case 110: // 'n' / null\n        this.expect([110, 117, 108, 108]) // 'null'\n        return new Token(Type.null, null, 4)\n      case 102: // 'f' / // false\n        this.expect([102, 97, 108, 115, 101]) // 'false'\n        return new Token(Type.false, false, 5)\n      case 116: // 't' / // true\n        this.expect([116, 114, 117, 101]) // 'true'\n        return new Token(Type.true, true, 4)\n      case 45: // '-'\n      case 48: // '0'\n      case 49: // '1'\n      case 50: // '2'\n      case 51: // '3'\n      case 52: // '4'\n      case 53: // '5'\n      case 54: // '6'\n      case 55: // '7'\n      case 56: // '8'\n      case 57: // '9'\n        return this.parseNumber()\n      default:\n        throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}`)\n    }\n  }\n\n  /**\n   * @returns {Token}\n   */\n  next () {\n    this.skipWhitespace()\n    switch (this.currentMode()) {\n      case 'value':\n        this.modeStack.pop()\n        return this.parseValue()\n      case 'array-value': {\n        this.modeStack.pop()\n        if (this.ch() === 93) { // ']'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        if (this.ch() !== 44) { // ','\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.modeStack.push('array-value')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      case 'array-start': {\n        this.modeStack.pop()\n        if (this.ch() === 93) { // ']'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        this.modeStack.push('array-value')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      // @ts-ignore\n      case 'obj-key':\n        if (this.ch() === 125) { // '}'\n          this.modeStack.pop()\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        if (this.ch() !== 44) { // ','\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.skipWhitespace()\n      case 'obj-start': { // eslint-disable-line no-fallthrough\n        this.modeStack.pop()\n        if (this.ch() === 125) { // '}'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        const token = this.parseString()\n        this.skipWhitespace()\n        if (this.ch() !== 58) { // ':'\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.modeStack.push('obj-value')\n        return token\n      }\n      case 'obj-value': {\n        this.modeStack.pop()\n        this.modeStack.push('obj-key')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      /* c8 ignore next 2 */\n      default:\n        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this._pos}; this shouldn't happen`)\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options)\n  return _decode(data, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options)\n  return _decodeFirst(data, options)\n}\n\nexport { decode, decodeFirst, Tokenizer }\n", "import { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "/* eslint max-depth: [\"error\", 7] */\nimport { Token, Type } from 'cborg'\nimport * as cborgJson from 'cborg/json'\nimport { CID } from 'multiformats'\nimport { base64 } from 'multiformats/bases/base64'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n/**\n * @template T\n * @typedef {import('multiformats').ToString<T>} ToString\n */\n/**\n * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nfunction toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal. Encoding a CID means replacing it with a `{\"/\":\"<CidString>}`\n * object as per the DAG-JSON spec.\n *\n * @param {any} obj\n * @returns {Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const cidString = cid.toString()\n\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.string, cidString, cidString.length), // value\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it\n * needs to replace it with a `{\"/\":{\"bytes\":\"Base64ByteString\"}}` object as\n * per the DAG-JSON spec.\n *\n * @param {Uint8Array} bytes\n * @returns {Token[]|null}\n */\nfunction bytesEncoder (bytes) {\n  const bytesString = base64.encode(bytes).slice(1) // no mbase prefix\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.map, Infinity, 1), // value\n    new Token(Type.string, 'bytes', 5), // inner key\n    new Token(Type.string, bytesString, bytesString.length), // inner value\n    new Token(Type.break, undefined, 1),\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so\n * that we access the underlying ArrayBuffer data\n *\n * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj\n * @returns {Token[]|null}\n */\nfunction taBytesEncoder (obj) {\n  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n}\n\n/**\n * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers\n *\n * @param {ArrayBuffer} ab\n * @returns {Token[]|null}\n */\nfunction abBytesEncoder (ab) {\n  return bytesEncoder(new Uint8Array(ab))\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null // process with standard number encoder\n}\n\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Buffer: bytesEncoder,\n    Uint8Array: bytesEncoder,\n    Int8Array: taBytesEncoder,\n    Uint16Array: taBytesEncoder,\n    Int16Array: taBytesEncoder,\n    Uint32Array: taBytesEncoder,\n    Int32Array: taBytesEncoder,\n    Float32Array: taBytesEncoder,\n    Float64Array: taBytesEncoder,\n    Uint8ClampedArray: taBytesEncoder,\n    BigInt64Array: taBytesEncoder,\n    BigUint64Array: taBytesEncoder,\n    DataView: taBytesEncoder,\n    ArrayBuffer: abBytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {object} [options]\n   */\n  constructor (data, options) {\n    super(data, options)\n    /** @type {Token[]} */\n    this.tokenBuffer = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this.tokenBuffer.length === 0 && super.done()\n  }\n\n  /**\n   * @returns {Token}\n   */\n  _next () {\n    if (this.tokenBuffer.length > 0) {\n      // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406\n      return this.tokenBuffer.pop()\n    }\n    return super.next()\n  }\n\n  /**\n   * Implements rules outlined in https://github.com/ipld/specs/pull/356\n   *\n   * @returns {Token}\n   */\n  next () {\n    const token = this._next()\n\n    if (token.type === Type.map) {\n      const keyToken = this._next()\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next()\n        if (valueToken.type === Type.string) { // *must* be a CID\n          const breakToken = this._next() // swallow the end-of-map token\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form')\n          }\n          this.tokenBuffer.push(valueToken) // CID.parse will pick this up after our tag token\n          return new Token(Type.tag, 42, 0)\n        }\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next()\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next()\n            if (innerValueToken.type === Type.string) { // *must* be Bytes\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next() // swallow two end-of-map tokens\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form')\n                }\n              }\n              const bytes = base64.decode(`m${innerValueToken.value}`)\n              return new Token(Type.bytes, bytes, innerValueToken.value.length)\n            }\n            this.tokenBuffer.push(innerValueToken) // bail\n          }\n          this.tokenBuffer.push(innerKeyToken) // bail\n        }\n        this.tokenBuffer.push(valueToken) // bail\n      }\n      this.tokenBuffer.push(keyToken) // bail\n    }\n    return token\n  }\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n\n// we're going to get TAG(42)STRING(\"bafy...\") from the tokenizer so we only need\n// to deal with the STRING(\"bafy...\") at this point\ndecodeOptions.tags[42] = CID.parse\n\nexport const name = 'dag-json'\nexport const code = 0x0129\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborgJson.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => {\n  const buf = toByteView(data)\n  // the tokenizer is stateful so we need a single instance of it\n  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(buf, decodeOptions) })\n  return cborgJson.decode(buf, options)\n}\n\n/**\n * @template T\n * @param {T} node\n * @returns {ToString<T>}\n */\nexport const format = (node) => utf8Decoder.decode(encode(node))\nexport { format as stringify }\nconst utf8Decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {ToString<T>} data\n * @returns {T}\n */\nexport const parse = (data) => decode(utf8Encoder.encode(data))\nconst utf8Encoder = new TextEncoder()\n", "import * as UCAN from \"./ucan.js\"\nimport * as DID from \"./did.js\"\nimport * as json from \"@ipld/dag-json\"\nimport { base64url } from \"multiformats/bases/base64\"\nimport * as Signature from \"./signature.js\"\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Model<C>} model\n * @returns {UCAN.JWT<C>}\n */\nexport const format = model => {\n  const header = formatHeader(model.v, model.s.algorithm)\n  const payload = formatPayload(model)\n  const signature = formatSignature(model.s)\n  return /** @type {UCAN.JWT<C>} */ (`${header}.${payload}.${signature}`)\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} payload\n * @param {UCAN.Version} version\n * @param {string} alg\n */\nexport const formatSignPayload = (payload, version, alg) =>\n  `${formatHeader(version, alg)}.${formatPayload(payload)}`\n\n/**\n * @param {UCAN.Version} version\n * @param {string} alg\n */\nexport const formatHeader = (version, alg) =>\n  base64url.baseEncode(encodeHeader(version, alg))\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} data\n */\nexport const formatPayload = data => base64url.baseEncode(encodePayload(data))\n\n/**\n * @param {UCAN.Signature<string>} signature\n */\nexport const formatSignature = signature => base64url.baseEncode(signature.raw)\n\n/**\n * @param {UCAN.Version} v\n * @param {string} alg\n * @returns {UCAN.ByteView<UCAN.JWTHeader>}\n */\nconst encodeHeader = (v, alg) =>\n  json.encode({\n    alg,\n    ucv: v,\n    typ: \"JWT\",\n  })\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} data\n * @returns {UCAN.ByteView<UCAN.JWTPayload<C>>}\n */\nconst encodePayload = data =>\n  json.encode({\n    iss: DID.format(data.iss),\n    aud: DID.format(data.aud),\n    att: data.att,\n    exp: data.exp,\n    prf: data.prf.map(encodeProof),\n    // leave out optionals and empty fields\n    ...(data.fct.length > 0 && { fct: data.fct }),\n    ...(data.nnc && { nnc: data.nnc }),\n    ...(data.nbf && { nbf: data.nbf }),\n  })\n\n/**\n * @param {UCAN.Link} proof\n * @returns {UCAN.ToString<UCAN.Link>}\n */\nconst encodeProof = proof =>\n  /** @type {UCAN.ToString<UCAN.Link>} */ (proof.toString())\n", "import * as UCAN from \"./ucan.js\"\nimport * as DID from \"./did.js\"\nimport { encode as encodeJSON } from \"@ipld/dag-json\"\nimport { decode as decodeUTF8 } from \"./utf8.js\"\n\n/**\n * @param {unknown} data\n */\nconst toJSON = data => JSON.parse(decodeUTF8(encodeJSON(data)))\n\n/**\n * @template {UCAN.Capabilities} C\n */\nexport class View {\n  /**\n   * @param {UCAN.UCAN<C>} model\n   */\n  constructor(model) {\n    /** @readonly */\n    this.model = model\n  }\n\n  get version() {\n    return this.model.v\n  }\n\n  get issuer() {\n    return DID.from(this.model.iss)\n  }\n\n  get audience() {\n    return DID.from(this.model.aud)\n  }\n\n  /**\n   * @returns {C}\n   */\n  get capabilities() {\n    return this.model.att\n  }\n\n  /**\n   * @returns {number}\n   */\n  get expiration() {\n    const { exp } = this.model\n    return exp === null ? Infinity : exp\n  }\n\n  /**\n   * @returns {undefined|number}\n   */\n  get notBefore() {\n    return this.model.nbf\n  }\n\n  /**\n   * @returns {undefined|string}\n   */\n\n  get nonce() {\n    return this.model.nnc\n  }\n\n  /**\n   * @returns {UCAN.Fact[]}\n   */\n  get facts() {\n    return this.model.fct\n  }\n\n  /**\n   * @returns {UCAN.Link[]}\n   */\n\n  get proofs() {\n    return this.model.prf\n  }\n\n  get signature() {\n    return this.model.s\n  }\n\n  // compatibility with UCAN.UCAN\n  get jwt() {\n    return this.model.jwt\n  }\n  get s() {\n    return this.model.s\n  }\n  get v() {\n    return this.model.v\n  }\n  get iss() {\n    return this.model.iss\n  }\n  get aud() {\n    return this.model.aud\n  }\n  get att() {\n    return this.model.att\n  }\n  get exp() {\n    return this.model.exp\n  }\n  get nbf() {\n    return this.model.nbf\n  }\n  get nnc() {\n    return this.model.nnc\n  }\n  get fct() {\n    return this.model.fct\n  }\n  get prf() {\n    return this.model.prf\n  }\n\n  /**\n   * @returns {UCAN.ToJSON<UCAN.UCAN<C>, UCAN.UCANJSON<this>>}\n   */\n  toJSON() {\n    const { v, iss, aud, s, att, prf, exp, fct, nnc, nbf } = this.model\n\n    return {\n      iss,\n      aud,\n      v,\n      s,\n      exp,\n      ...toJSON({\n        att,\n        prf,\n        ...(fct.length > 0 && { fct }),\n      }),\n      ...(nnc != null && { nnc }),\n      ...(nbf && { nbf }),\n    }\n  }\n}\n", "import * as UCAN from \"../ucan.js\"\nimport * as CBOR from \"@ipld/dag-cbor\"\nimport { readPayload, readVersion, readSignature } from \"../schema.js\"\nimport { format } from \"../formatter.js\"\nimport * as Signature from \"../signature.js\"\nimport { View } from \"../view.js\"\n\nexport const name = \"dag-ucan\"\nexport const code = CBOR.code\n\n/**\n * Creates a UCAN view from the underlying data model. Please note that this\n * function does no verification of the model and it is callers responsibility\n * to ensure that:\n *\n * 1. Data model is correct contains all the field etc...\n * 2. Payload of the signature will match paylodad when model is serialized\n *    with DAG-JSON.\n *\n * In other words you should never use this function unless you've parsed or\n * decoded a valid UCAN and want to wrap it into a view.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromModel<C>} model\n * @returns {UCAN.View<C>}\n */\nexport const from = model => new CBORView(model)\n\n/**\n * Encodes given UCAN (in either IPLD or JWT representation) and encodes it into\n * corresponding bytes representation. UCAN in IPLD representation is encoded as\n * DAG-CBOR which JWT representation is encoded as raw bytes of JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Model<C>} model\n * @returns {UCAN.ByteView<UCAN.Model<C>>}\n */\nexport const encode = model => {\n  const { fct, nnc, nbf, ...payload } = readPayload(model)\n\n  return /** @type {Uint8Array} */ (\n    CBOR.encode({\n      // leave out optionals unless they are set\n      ...(fct.length > 0 && { fct }),\n      ...(nnc != null && { nnc }),\n      ...(nbf && { nbf }),\n      ...payload,\n      // add version and signature\n      v: readVersion(model.v, \"v\"),\n      s: encodeSignature(model.s, \"s\"),\n    })\n  )\n}\n\n/**\n * @param {UCAN.Signature} signature\n * @param {string} context\n */\nconst encodeSignature = (signature, context) => {\n  try {\n    return Signature.encode(signature)\n  } catch (cause) {\n    throw new Error(\n      `Expected signature ${context}, instead got ${JSON.stringify(signature)}`,\n      // @ts-expect-error - types don't know about second arg\n      { cause }\n    )\n  }\n}\n\n/**\n * Decodes UCAN in primary CBOR representation. It does not validate UCAN, it's\n * signature or proof chain. This is to say decoded UCAN may be invalid.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.Model<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  const model = CBOR.decode(bytes)\n  return new CBORView({\n    ...readPayload(model),\n    v: readVersion(model.v, \"v\"),\n    s: readSignature(model.s),\n  })\n}\n\nexport { format }\n\n/**\n * @template {UCAN.Capabilities} C\n * @extends {View<C>}\n */\nclass CBORView extends View {\n  get code() {\n    return code\n  }\n  format() {\n    return format(this.model)\n  }\n  encode() {\n    return encode(this.model)\n  }\n}\n", "import * as UCAN from \"./ucan.js\"\nimport * as json from \"@ipld/dag-json\"\nimport * as Schema from \"./schema.js\"\nimport { base64url } from \"multiformats/bases/base64\"\nimport { createNamed as createSignature } from \"./signature.js\"\n\n/**\n * Parse JWT formatted UCAN. Note than no validation takes place here.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.JWT<C>|string} jwt\n * @returns {UCAN.Model<C>}\n */\nexport const parse = jwt => {\n  const segments = jwt.split(\".\")\n  const [header, payload, signature] =\n    segments.length === 3\n      ? segments\n      : Schema.throw(\n          `Can't parse UCAN: ${jwt}: Expected JWT format: 3 dot-separated base64url-encoded values.`\n        )\n\n  const { ucv, alg } = parseHeader(header)\n\n  return {\n    ...parsePayload(payload),\n    v: ucv,\n    s: createSignature(alg, base64url.baseDecode(signature)),\n  }\n}\n\n/**\n * @param {string} header\n */\nexport const parseHeader = header => {\n  const { ucv, alg, typ } = json.decode(base64url.baseDecode(header))\n\n  return {\n    typ: Schema.readLiteral(typ, \"JWT\", \"typ\"),\n    ucv: Schema.readVersion(ucv, \"ucv\"),\n    alg: Schema.readString(alg, \"alg\"),\n  }\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {string} source\n * @returns {UCAN.Payload<C>}\n */\nexport const parsePayload = source => {\n  /** @type {Record<string, unknown>} */\n  const payload = json.decode(base64url.baseDecode(source))\n  return Schema.readJWTPayload(payload)\n}\n", "import * as UCAN from \"../ucan.js\"\nimport * as UTF8 from \"../utf8.js\"\nimport { parse } from \"../parser.js\"\nimport { code } from \"multiformats/codecs/raw\"\nimport { View } from \"../view.js\"\n\nexport { code }\nexport const name = \"dag-ucan\"\n\n/**\n * Creates a UCAN view from the underlying data model. Please note that this\n * function does no verification of the model and it is callers responsibility\n * to ensure that:\n *\n * 1. Data model is correct contains all the field etc...\n * 2. Payload of the signature will match paylodad when model is serialized\n *    with DAG-JSON.\n *\n * In other words you should never use this function unless you've parsed or\n * decoded a valid UCAN and want to wrap it into a view.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.View<C>}\n */\nexport const from = model => new JWTView(model)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.FromJWT<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  const jwt = /** @type {UCAN.JWT<C>} */ (UTF8.decode(bytes))\n\n  return new JWTView({ ...parse(jwt), jwt })\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.ByteView<UCAN.UCAN<C>>}\n */\nexport const encode = ({ jwt }) => UTF8.encode(jwt)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.JWT<C>}\n */\nexport const format = ({ jwt }) => jwt\n\n/**\n * @template {UCAN.Capabilities} C\n * @extends {View<C>}\n */\nclass JWTView extends View {\n  /**\n   * @param {UCAN.FromJWT<C>} model\n   */\n  constructor(model) {\n    super(model)\n    this.model = model\n  }\n  get code() {\n    return code\n  }\n  format() {\n    return format(this.model)\n  }\n  encode() {\n    return encode(this.model)\n  }\n}\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import * as UCAN from \"./ucan.js\"\nimport * as CBOR from \"./codec/cbor.js\"\nimport * as JWT from \"./codec/jwt.js\"\nimport * as UTF8 from \"./utf8.js\"\nimport { readPayload } from \"./schema.js\"\nimport { parse as parseDID } from \"./did.js\"\nimport { parse as parseJWT } from \"./parser.js\"\nimport { formatSignPayload } from \"./formatter.js\"\nimport { sha256 } from \"multiformats/hashes/sha2\"\nimport { create as createLink } from \"multiformats/link\"\nimport { format as formatDID } from \"./did.js\"\n\nexport * from \"./ucan.js\"\n\nexport const VERSION = \"0.9.1\"\nexport const name = \"dag-ucan\"\nexport const code = /** @type {UCAN.Code} */ (CBOR.code)\n\n/**\n * We cast sha256 to workaround typescripts limited inference problem when using\n * sha256 as default. If hasher is omitted type `A` should match sha256.code\n * but TS fails to deduce that.\n * @type {UCAN.MultihashHasher<any>}\n */\nconst defaultHasher = sha256\n\n/**\n * Encodes given UCAN (in either IPLD or JWT representation) and encodes it into\n * corresponding bytes representation. UCAN in IPLD representation is encoded as\n * DAG-CBOR which JWT representation is encoded as raw bytes of JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCAN<C>} ucan\n * @returns {UCAN.ByteView<UCAN.UCAN<C>>}\n */\nexport const encode = ucan => (ucan.jwt ? JWT.encode(ucan) : CBOR.encode(ucan))\n\n/**\n * Decodes binary encoded UCAN. It assumes UCAN is in primary IPLD\n * representation and attempts to decode it with DAG-CBOR, if that\n * fails it falls back to secondary representation and parses it as\n * a JWT.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.UCAN<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  try {\n    return CBOR.decode(bytes)\n  } catch (_) {\n    return JWT.decode(/** @type {UCAN.ByteView<UCAN.FromJWT<C>>} */ (bytes))\n  }\n}\n\n/**\n * Convenience function to create a CID for the given UCAN. If UCAN is\n * in JWT representation get CID with RAW multicodec, while UCANs in IPLD\n * representation get UCAN multicodec code.\n *\n * @template {UCAN.Capabilities} C\n * @template {number} [A=typeof sha256.code] - Multihash code\n * @param {UCAN.View<C>} ucan\n * @param {{hasher?: UCAN.MultihashHasher<A>}} [options]\n */\nexport const link = async (ucan, options) => {\n  const { cid } = await write(ucan, options)\n  return cid\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @template {number} [A=typeof sha256.code] - Multihash code\n * @param {UCAN.UCAN<C>} ucan\n * @param {{hasher?: UCAN.MultihashHasher<A>}} options\n * @returns {Promise<UCAN.Block<C, UCAN.Code, A>>}\n */\nexport const write = async (ucan, { hasher = defaultHasher } = {}) => {\n  const [code, bytes] = ucan.jwt\n    ? [JWT.code, JWT.encode(ucan)]\n    : [CBOR.code, CBOR.encode(ucan)]\n  const digest = await hasher.digest(bytes)\n\n  return {\n    bytes,\n    cid: createLink(code, digest),\n    data: ucan,\n  }\n}\n\n/**\n * Parses UCAN formatted as JWT string. Returns UCAN view in IPLD representation\n * when serializing it back would produce original string, otherwise returns UCAN\n * view in secondary JWT representation which is not as compact, but it retains\n * key order and whitespaces so it could be formatted back to same JWT string.\n * View will have `type` field with either `\"IPLD\"` or `\"JWT\"` value telling\n * in which representation UCAN is.\n *\n * Note: Parsing does not perform validation of capabilities or semantics of the\n * UCAN, it only ensures structure is spec compliant and throws `ParseError`\n * if it is not.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.JWT<C>|string} jwt\n * @returns {UCAN.View<C>}\n */\nexport const parse = jwt => {\n  const model = parseJWT(jwt)\n\n  // If formatting UCAN produces same jwt string we can use IPLD representation\n  // otherwise we need to fallback to raw representation. This decision will\n  // affect how we `encode` the UCAN.\n  return CBOR.format(model) === jwt\n    ? CBOR.from(model)\n    : JWT.from({ ...model, jwt: /** @type {UCAN.JWT<C>} */ (jwt) })\n}\n\n/**\n * Takes UCAN object and formats it into JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCAN<C>} ucan\n * @returns {UCAN.JWT<C>}\n */\nexport const format = ucan => (ucan.jwt ? JWT.format(ucan) : CBOR.format(ucan))\n\n/**\n * Creates a new signed token with a given `options.issuer`. If expiration is\n * not set it defaults to 30 seconds from now. Returns UCAN in primary - IPLD\n * representation.\n *\n * @template {number} A\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCANOptions<C, A>} options\n * @returns {Promise<UCAN.View<C>>}\n */\nexport const issue = async ({\n  issuer,\n  audience,\n  capabilities,\n  lifetimeInSeconds = 30,\n  expiration = now() + lifetimeInSeconds,\n  notBefore,\n  facts = [],\n  proofs = [],\n  nonce,\n}) => {\n  const v = VERSION\n  const data = readPayload({\n    iss: parseDID(issuer.did()),\n    aud: parseDID(audience.did()),\n    att: capabilities,\n    fct: facts,\n    exp: expiration,\n    nbf: notBefore,\n    prf: proofs,\n    nnc: nonce,\n  })\n  const payload = encodeSignaturePayload(data, v, issuer.signatureAlgorithm)\n\n  return CBOR.from({\n    ...data,\n    v,\n    s: await issuer.sign(payload),\n  })\n}\n\n/**\n *\n * @param {UCAN.Payload} payload\n * @param {UCAN.Version} version\n * @param {string} algorithm\n * @returns\n */\nconst encodeSignaturePayload = (payload, version, algorithm) =>\n  UTF8.encode(formatSignPayload(payload, version, algorithm))\n\n/**\n * Verifies UCAN signature.\n *\n * @param {UCAN.View} ucan\n * @param {UCAN.Verifier} verifier\n */\nexport const verifySignature = (ucan, verifier) =>\n  formatDID(ucan.issuer) === verifier.did() &&\n  verifier.verify(\n    encodeSignaturePayload(ucan.model, ucan.model.v, ucan.signature.algorithm),\n    ucan.signature\n  )\n\n/**\n * Check if a UCAN is expired.\n *\n * @param {UCAN.View} ucan\n */\nexport const isExpired = ucan => ucan.expiration <= now()\n\n/**\n * Check if a UCAN is not active yet.\n * @param {UCAN.View} ucan\n */\nexport const isTooEarly = ucan =>\n  ucan.notBefore != null && now() <= ucan.notBefore\n\n/**\n * Returns UTC Unix timestamp for comparing it against time window of the UCAN.\n */\nexport const now = () => Math.floor(Date.now() / 1000)\n", "import * as API from '@ucanto/interface'\nimport * as CBOR from '@ipld/dag-cbor'\nexport { code, name, decode } from '@ipld/dag-cbor'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { create as createLink, isLink } from 'multiformats/link'\n\n// @see https://www.iana.org/assignments/media-types/application/vnd.ipld.dag-cbor\nexport const contentType = 'application/vnd.ipld.dag-cbor'\n\n/**\n * @param {unknown} data\n * @param {Set<unknown>} seen\n * @returns {unknown}\n */\nconst prepare = (data, seen) => {\n  if (seen.has(data)) {\n    throw new TypeError('Can not encode circular structure')\n  }\n  // top level undefined is ok\n  if (data === undefined && seen.size === 0) {\n    return null\n  }\n\n  if (data === null) {\n    return null\n  }\n\n  if (typeof data === 'symbol' && seen.size === 0) {\n    return null\n  }\n\n  if (isLink(data)) {\n    return data\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    return data\n  }\n\n  if (Array.isArray(data)) {\n    seen.add(data)\n    const items = []\n    for (const item of data) {\n      items.push(\n        item === undefined || typeof item === 'symbol'\n          ? null\n          : prepare(item, seen)\n      )\n    }\n    return items\n  }\n\n  if (typeof (/** @type {{toJSON?:unknown}} */ (data).toJSON) === 'function') {\n    seen.add(data)\n    const json = /** @type {{toJSON():unknown}} */ (data).toJSON()\n    return prepare(json, seen)\n  }\n\n  if (typeof data === 'object') {\n    seen.add(data)\n    /** @type {Record<string, unknown>} */\n    const object = {}\n    for (const [key, value] of Object.entries(data)) {\n      if (value !== undefined && typeof value !== 'symbol') {\n        object[key] = prepare(value, new Set(seen))\n      }\n    }\n    return object\n  }\n\n  return data\n}\n\n/**\n * @template T\n * @param {T} data\n * @returns {CBOR.ByteView<T>}\n */\nexport const encode = data =>\n  /** @type {CBOR.ByteView<T>} */ (CBOR.encode(prepare(data, new Set())))\n\n/**\n * @template T\n * @param {API.ByteView<T>} bytes\n * @param {{hasher?: API.MultihashHasher }} options\n * @returns {Promise<API.Link<T, typeof CBOR.code>>}\n *\n */\nexport const link = async (bytes, { hasher = sha256 } = {}) => {\n  return /** @type {API.Link<T, typeof CBOR.code>} */ (\n    createLink(CBOR.code, await hasher.digest(bytes))\n  )\n}\n\n/**\n * @template T\n * @param {T} data\n * @param {{hasher?: API.MultihashHasher }} [options]\n * @returns {Promise<API.Block<T, typeof CBOR.code>>}\n */\nexport const write = async (data, options) => {\n  const bytes = encode(data)\n  const cid = await link(bytes, options)\n\n  return { cid, bytes }\n}\n", "import * as API from '@ucanto/interface'\nimport { create as createLink } from './link.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as MF from 'multiformats/interface'\nimport * as CBOR from './cbor.js'\nimport { identity } from 'multiformats/hashes/identity'\n\nexport { CBOR, sha256, identity }\n\n/**\n * Function takes arbitrary value and if it happens to be an `IPLDView`\n * it will iterate over it's blocks. It is just a convenience for traversing\n * arbitrary structures that may contain `IPLDView`s in them.\n * Note if you pass anything other than `IPLDView` it will not attempt\n * to find views nested inside them, instead it will just emit no blocks.\n *\n * @param {unknown} value\n * @returns {IterableIterator<API.Block>}\n */\nexport const iterate = function* (value) {\n  if (\n    value &&\n    typeof value === 'object' &&\n    'iterateIPLDBlocks' in value &&\n    typeof value.iterateIPLDBlocks === 'function'\n  ) {\n    yield* value.iterateIPLDBlocks()\n  }\n}\n\n/**\n * @template [T=unknown]\n * @typedef {Map<API.ToString<API.Link>, API.Block<T, number, number, 0>|API.Block<T, number, number, 1>>} BlockStore\n */\n\n/**\n * @template [T=unknown]\n * @param {API.Block<T>[]} blocks\n * @returns {API.BlockStore<T>}\n */\nexport const createStore = (blocks = []) => {\n  const store = new Map()\n  addEveryInto(blocks, store)\n  return store\n}\n\n/** @type {API.MulticodecCode<typeof identity.code, typeof identity.name>} */\nconst EMBED_CODE = identity.code\n\n/**\n * Gets block corresponding to the given CID from the store. If store does not\n * contain the block, `fallback` is returned. If `fallback` is not provided, it\n * will throw an error.\n *\n * @template {0|1} V\n * @template {T} U\n * @template T\n * @template {API.MulticodecCode} Format\n * @template {API.MulticodecCode} Alg\n * @template [E=never]\n * @param {API.Link<U, Format, Alg, V>} cid\n * @param {BlockStore<T>} store\n * @param {E} [fallback]\n * @returns {API.Block<U, Format, Alg, V>|E}\n */\nexport const get = (cid, store, fallback) => {\n  // If CID uses identity hash, we can return the block data directly\n  if (cid.multihash.code === EMBED_CODE) {\n    return { cid, bytes: cid.multihash.digest }\n  }\n\n  const block = /** @type {API.Block<U, Format, Alg, V>|undefined} */ (\n    store.get(`${cid}`)\n  )\n  return block ? block : fallback === undefined ? notFound(cid) : fallback\n}\n\n/**\n * @template T\n * @template {T} U\n * @param {U} source\n * @template {API.MulticodecCode} [C=API.MulticodecCode<typeof CBOR.code, typeof CBOR.name>]\n * @param {object} options\n * @param {MF.BlockEncoder<C, U>} [options.codec]\n * @returns {API.Block<U, C, typeof EMBED_CODE> & { data: U }}\n */\nexport const embed = (source, { codec } = {}) => {\n  const encoder = /** @type {MF.BlockEncoder<C, U>}  */ (codec || CBOR)\n  const bytes = encoder.encode(source)\n  const digest = identity.digest(bytes)\n  return {\n    cid: createLink(encoder.code, digest),\n    bytes,\n    data: source,\n  }\n}\n\n/**\n * @param {API.Link<*, *, *, *>} link\n * @returns {never}\n */\nexport const notFound = link => {\n  throw new Error(`Block for the ${link} is not found`)\n}\n\n/**\n * @template T\n * @template {T} U\n * @template {API.MulticodecCode} C\n * @template {API.MulticodecCode} A\n * @param {U} source\n * @param {BlockStore<T>} store\n * @param {object} options\n * @param {MF.BlockEncoder<C, unknown>} [options.codec]\n * @param {MF.MultihashHasher<A>} [options.hasher]\n * @returns {Promise<API.Block<U, C, A> & { data: U }>}\n */\nexport const writeInto = async (source, store, options = {}) => {\n  const codec = /** @type {MF.BlockEncoder<C, U>} */ (options.codec || CBOR)\n  const hasher = /** @type {MF.MultihashHasher<A>} */ (options.hasher || sha256)\n\n  const bytes = codec.encode(source)\n  const digest = await hasher.digest(bytes)\n  /** @type {API.Link<U, typeof codec.code, typeof hasher.code>} */\n  const link = createLink(codec.code, digest)\n  store.set(/** @type {API.ToString<typeof link>} */ (link.toString()), {\n    bytes,\n    cid: link,\n  })\n\n  return { bytes, cid: link, data: source }\n}\n\n/**\n * @template T\n * @template {T} U\n * @param {API.Block<U>} block\n * @param {BlockStore<T>} store\n * @returns {API.Block<U>}\n */\nexport const addInto = ({ cid, bytes }, store) => {\n  store.set(/** @type {API.ToString<typeof cid>} */ (cid.toString()), {\n    bytes,\n    cid,\n  })\n\n  return { bytes, cid }\n}\n\n/**\n * @template T\n * @template {T} U\n * @param {Iterable<API.Block<U>>} source\n * @param {BlockStore<T>} store\n */\nexport const addEveryInto = (source, store) => {\n  for (const block of source) {\n    addInto(block, store)\n  }\n}\n", "import * as API from '@ucanto/interface'\nimport { CarBufferReader } from '@ipld/car/buffer-reader'\nimport * as CarBufferWriter from '@ipld/car/buffer-writer'\nimport { base32 } from 'multiformats/bases/base32'\nimport { create as createLink } from './link.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\n// @see https://www.iana.org/assignments/media-types/application/vnd.ipld.car\nexport const contentType = 'application/vnd.ipld.car'\nexport const name = 'CAR'\n\n/** @type {API.MulticodecCode<0x0202, 'CAR'>} */\nexport const code = 0x0202\n\n/**\n * @typedef {{\n * roots: API.IPLDBlock[]\n * blocks: Map<string, API.IPLDBlock>\n * }} Model\n */\n\nclass Writer {\n  /**\n   * @param {API.IPLDBlock[]} blocks\n   * @param {number} byteLength\n   */\n  constructor(blocks = [], byteLength = 0) {\n    this.written = new Set()\n    this.blocks = blocks\n    this.byteLength = byteLength\n  }\n  /**\n   * @param {API.IPLDBlock[]} blocks\n   */\n  write(...blocks) {\n    for (const block of blocks) {\n      const id = block.cid.toString(base32)\n      if (!this.written.has(id)) {\n        this.blocks.push(block)\n        this.byteLength += CarBufferWriter.blockLength(\n          /** @type {any} */ (block)\n        )\n        this.written.add(id)\n      }\n    }\n    return this\n  }\n  /**\n   * @param {API.IPLDBlock[]} rootBlocks\n   */\n  flush(...rootBlocks) {\n    const roots = []\n    // We reverse the roots so that the first root is the last block in the CAR\n    for (const block of rootBlocks.reverse()) {\n      const id = block.cid.toString(base32)\n      if (!this.written.has(id)) {\n        this.blocks.unshift(block)\n        this.byteLength += CarBufferWriter.blockLength({\n          cid: /** @type {CarBufferWriter.CID} */ (block.cid),\n          bytes: block.bytes,\n        })\n        this.written.add(id)\n      }\n\n      // We unshift here because we want to preserve the order of the roots\n      roots.unshift(/** @type {CarBufferWriter.CID} */ (block.cid))\n    }\n\n    this.byteLength += CarBufferWriter.headerLength({ roots })\n\n    const buffer = new ArrayBuffer(this.byteLength)\n    const writer = CarBufferWriter.createWriter(buffer, { roots })\n\n    for (const block of /** @type {CarBufferWriter.Block[]} */ (this.blocks)) {\n      writer.write(block)\n    }\n\n    return writer.close()\n  }\n}\n\nexport const createWriter = () => new Writer()\n\n/**\n * @template {Partial<Model>} T\n * @param {T} input\n * @returns {API.ByteView<T>}\n */\nexport const encode = ({ roots = [], blocks }) => {\n  const writer = new Writer()\n  if (blocks) {\n    writer.write(...blocks.values())\n  }\n  return writer.flush(...roots)\n}\n\n/**\n * @param {API.ByteView<Partial<Model>>} bytes\n * @returns {Model}\n */\nexport const decode = bytes => {\n  const reader = CarBufferReader.fromBytes(bytes)\n  /** @type {API.IPLDBlock[]} */\n  const roots = []\n  const blocks = new Map()\n\n  for (const root of reader.getRoots()) {\n    const block = /** @type {API.IPLDBlock} */ (reader.get(root))\n    if (block) {\n      roots.push(block)\n    }\n  }\n\n  for (const block of reader.blocks()) {\n    blocks.set(block.cid.toString(), block)\n  }\n\n  return { roots, blocks }\n}\n\n/**\n * @template {Partial<Model>} T\n * @param {API.ByteView<T>} bytes\n * @param {{hasher?: API.MultihashHasher }} options\n */\nexport const link = async (bytes, { hasher = sha256 } = {}) => {\n  return /** @type {API.Link<T, typeof code, typeof hasher.code>} */ (\n    createLink(code, await hasher.digest(bytes))\n  )\n}\n\n/**\n * @template {Partial<Model>} T\n * @param {T} data\n * @param {{hasher?: API.MultihashHasher }} [options]\n * @returns {Promise<API.Block<T, typeof code>>}\n */\nexport const write = async (data, options) => {\n  const bytes = encode(data)\n  const cid = await link(bytes, options)\n\n  return { bytes, cid }\n}\n", "import varint from 'varint'\n\nexport const CIDV0_BYTES = {\n  SHA2_256: 0x12,\n  LENGTH: 0x20,\n  DAG_PB: 0x70\n}\n\nexport const V2_HEADER_LENGTH = /* characteristics */ 16 /* v1 offset */ + 8 /* v1 size */ + 8 /* index offset */ + 8\n\n/**\n * Decodes varint and seeks the buffer\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @param {import('./coding').Seekable} seeker\n * @returns {number}\n */\nexport function decodeVarint (bytes, seeker) {\n  if (!bytes.length) {\n    throw new Error('Unexpected end of data')\n  }\n  const i = varint.decode(bytes)\n  seeker.seek(/** @type {number} */(varint.decode.bytes))\n  return i\n}\n\n/**\n * Decode v2 header\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.exactly(V2_HEADER_LENGTH, true) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @returns {import('./coding').CarV2FixedHeader}\n */\nexport function decodeV2Header (bytes) {\n  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  let offset = 0\n  const header = {\n    version: 2,\n    /** @type {[bigint, bigint]} */\n    characteristics: [\n      dv.getBigUint64(offset, true),\n      dv.getBigUint64(offset += 8, true)\n    ],\n    dataOffset: Number(dv.getBigUint64(offset += 8, true)),\n    dataSize: Number(dv.getBigUint64(offset += 8, true)),\n    indexOffset: Number(dv.getBigUint64(offset += 8, true))\n  }\n  return header\n}\n\n/**\n * Checks the length of the multihash to be read afterwards\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n */\nexport function getMultihashLength (bytes) {\n  // | code | length | .... |\n  // where both code and length are varints, so we have to decode\n  // them first before we can know total length\n\n  varint.decode(bytes) // code\n  const codeLength = /** @type {number} */(varint.decode.bytes)\n  const length = varint.decode(bytes.subarray(varint.decode.bytes))\n  const lengthLength = /** @type {number} */(varint.decode.bytes)\n  const mhLength = codeLength + lengthLength + length\n\n  return mhLength\n}\n", "/** Auto-generated with @ipld/schema@v4.2.0 at Thu Sep 14 2023 from IPLD Schema:\n *\n * # CarV1HeaderOrV2Pragma is a more relaxed form, and can parse {version:x} where\n * # roots are optional. This is typically useful for the {verison:2} CARv2\n * # pragma.\n *\n * type CarV1HeaderOrV2Pragma struct {\n * \troots optional [&Any]\n * \t# roots is _not_ optional for CarV1 but we defer that check within code to\n * \t# gracefully handle the V2 case where it's just {version:X}\n * \tversion Int\n * }\n *\n * # CarV1Header is the strict form of the header, and requires roots to be\n * # present. This is compatible with the CARv1 specification.\n *\n * # type CarV1Header struct {\n * # \troots [&Any]\n * # \tversion Int\n * # }\n *\n */\n\nconst Kinds = {\n  Null: /** @returns {undefined|null} */ (/** @type {any} */ obj) => obj === null ? obj : undefined,\n  Int: /** @returns {undefined|number} */ (/** @type {any} */ obj) => Number.isInteger(obj) ? obj : undefined,\n  Float: /** @returns {undefined|number} */ (/** @type {any} */ obj) => typeof obj === 'number' && Number.isFinite(obj) ? obj : undefined,\n  String: /** @returns {undefined|string} */ (/** @type {any} */ obj) => typeof obj === 'string' ? obj : undefined,\n  Bool: /** @returns {undefined|boolean} */ (/** @type {any} */ obj) => typeof obj === 'boolean' ? obj : undefined,\n  Bytes: /** @returns {undefined|Uint8Array} */ (/** @type {any} */ obj) => obj instanceof Uint8Array ? obj : undefined,\n  Link: /** @returns {undefined|object} */ (/** @type {any} */ obj) => obj !== null && typeof obj === 'object' && obj.asCID === obj ? obj : undefined,\n  List: /** @returns {undefined|Array<any>} */ (/** @type {any} */ obj) => Array.isArray(obj) ? obj : undefined,\n  Map: /** @returns {undefined|object} */ (/** @type {any} */ obj) => obj !== null && typeof obj === 'object' && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : undefined\n}\n/** @type {{ [k in string]: (obj:any)=>undefined|any}} */\nconst Types = {\n  'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarV1HeaderOrV2Pragma > roots (anon)': /** @returns {undefined|any} */ (/** @type {any} */ obj) => {\n    if (Kinds.List(obj) === undefined) {\n      return undefined\n    }\n    for (let i = 0; i < obj.length; i++) {\n      let v = obj[i]\n      v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n      if (v === undefined) {\n        return undefined\n      }\n      if (v !== obj[i]) {\n        const ret = obj.slice(0, i)\n        for (let j = i; j < obj.length; j++) {\n          let v = obj[j]\n          v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n          if (v === undefined) {\n            return undefined\n          }\n          ret.push(v)\n        }\n        return ret\n      }\n    }\n    return obj\n  },\n  Int: Kinds.Int,\n  CarV1HeaderOrV2Pragma: /** @returns {undefined|any} */ (/** @type {any} */ obj) => {\n    if (Kinds.Map(obj) === undefined) {\n      return undefined\n    }\n    const entries = Object.entries(obj)\n    /** @type {{[k in string]: any}} */\n    let ret = obj\n    let requiredCount = 1\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i]\n      switch (key) {\n        case 'roots':\n          {\n            const v = Types['CarV1HeaderOrV2Pragma > roots (anon)'](obj[key])\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.roots = v\n            }\n          }\n          break\n        case 'version':\n          {\n            requiredCount--\n            const v = Types.Int(obj[key])\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.version = v\n            }\n          }\n          break\n        default:\n          return undefined\n      }\n    }\n\n    if (requiredCount > 0) {\n      return undefined\n    }\n    return ret\n  }\n}\n/** @type {{ [k in string]: (obj:any)=>undefined|any}} */\nconst Reprs = {\n  'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarV1HeaderOrV2Pragma > roots (anon)': /** @returns {undefined|any} */ (/** @type {any} */ obj) => {\n    if (Kinds.List(obj) === undefined) {\n      return undefined\n    }\n    for (let i = 0; i < obj.length; i++) {\n      let v = obj[i]\n      v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n      if (v === undefined) {\n        return undefined\n      }\n      if (v !== obj[i]) {\n        const ret = obj.slice(0, i)\n        for (let j = i; j < obj.length; j++) {\n          let v = obj[j]\n          v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n          if (v === undefined) {\n            return undefined\n          }\n          ret.push(v)\n        }\n        return ret\n      }\n    }\n    return obj\n  },\n  Int: Kinds.Int,\n  CarV1HeaderOrV2Pragma: /** @returns {undefined|any} */ (/** @type {any} */ obj) => {\n    if (Kinds.Map(obj) === undefined) {\n      return undefined\n    }\n    const entries = Object.entries(obj)\n    /** @type {{[k in string]: any}} */\n    let ret = obj\n    let requiredCount = 1\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i]\n      switch (key) {\n        case 'roots':\n          {\n            const v = Reprs['CarV1HeaderOrV2Pragma > roots (anon)'](value)\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.roots = v\n            }\n          }\n          break\n        case 'version':\n          {\n            requiredCount--\n            const v = Reprs.Int(value)\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.version = v\n            }\n          }\n          break\n        default:\n          return undefined\n      }\n    }\n    if (requiredCount > 0) {\n      return undefined\n    }\n    return ret\n  }\n}\n\nexport const CarV1HeaderOrV2Pragma = {\n  toTyped: Types.CarV1HeaderOrV2Pragma,\n  toRepresentation: Reprs.CarV1HeaderOrV2Pragma\n}\n", "import { decode as decodeDagCbor } from '@ipld/dag-cbor'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js'\nimport { CarV1HeaderOrV2Pragma } from './header-validator.js'\n\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockHeader} BlockHeader\n * @typedef {import('./api').BlockIndex} BlockIndex\n * @typedef {import('./coding').BytesBufferReader} BytesBufferReader\n * @typedef {import('./coding').CarHeader} CarHeader\n * @typedef {import('./coding').CarV2Header} CarV2Header\n * @typedef {import('./coding').CarV2FixedHeader} CarV2FixedHeader\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name decoder.readHeader(reader)\n * @param {BytesBufferReader} reader\n * @param {number} [strictVersion]\n * @returns {CarHeader | CarV2Header}\n */\nexport function readHeader (reader, strictVersion) {\n  const length = decodeVarint(reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)')\n  }\n  const header = reader.exactly(length, true)\n  const block = decodeDagCbor(header)\n  if (CarV1HeaderOrV2Pragma.toTyped(block) === undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  if ((block.version !== 1 && block.version !== 2) || (strictVersion !== undefined && block.version !== strictVersion)) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`)\n  }\n  if (block.version === 1) {\n    // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory\n    if (!Array.isArray(block.roots)) {\n      throw new Error('Invalid CAR header format')\n    }\n    return block\n  }\n  // version 2\n  if (block.roots !== undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  const v2Header = decodeV2Header(reader.exactly(V2_HEADER_LENGTH, true))\n  reader.seek(v2Header.dataOffset - reader.pos)\n  const v1Header = readHeader(reader, 1)\n  return Object.assign(v1Header, v2Header)\n}\n\n/**\n * Reads CID sync\n *\n * @param {BytesBufferReader} reader\n * @returns {CID}\n */\nfunction readCid (reader) {\n  const first = reader.exactly(2, false)\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = reader.exactly(34, true)\n    const multihash = Digest.decode(bytes)\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash)\n  }\n\n  const version = decodeVarint(reader.upTo(8), reader)\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`)\n  }\n  const codec = decodeVarint(reader.upTo(8), reader)\n  const bytes = reader.exactly(getMultihashLength(reader.upTo(8)), true)\n  const multihash = Digest.decode(bytes)\n  return CID.create(version, codec, multihash)\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesBufferReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesBufferReader} reader\n * @returns {BlockHeader}\n */\nexport function readBlockHead (reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos\n  let length = decodeVarint(reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)')\n  }\n  length += (reader.pos - start)\n  const cid = readCid(reader)\n  const blockLength = length - Number(reader.pos - start) // subtract CID length\n\n  return { cid, length, blockLength }\n}\n\n/**\n * Returns Car header and blocks from a Uint8Array\n *\n * @param {Uint8Array} bytes\n * @returns {{ header : CarHeader | CarV2Header , blocks: Block[]}}\n */\nexport function fromBytes (bytes) {\n  let reader = bytesReader(bytes)\n  const header = readHeader(reader)\n  if (header.version === 2) {\n    const v1length = reader.pos - header.dataOffset\n    reader = limitReader(reader, header.dataSize - v1length)\n  }\n\n  const blocks = []\n  while (reader.upTo(8).length > 0) {\n    const { cid, blockLength } = readBlockHead(reader)\n\n    blocks.push({ cid, bytes: reader.exactly(blockLength, true) })\n  }\n\n  return {\n    header, blocks\n  }\n}\n\n/**\n * Creates a `BytesBufferReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesBufferReader}\n */\nexport function bytesReader (bytes) {\n  let pos = 0\n\n  /** @type {BytesBufferReader} */\n  return {\n    upTo (length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos))\n    },\n\n    exactly (length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data')\n      }\n\n      const out = bytes.subarray(pos, pos + length)\n      if (seek) {\n        pos += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * Wraps a `BytesBufferReader` in a limiting `BytesBufferReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesBufferReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesBufferReader} reader\n * @param {number} byteLimit\n * @returns {BytesBufferReader}\n */\nexport function limitReader (reader, byteLimit) {\n  let bytesRead = 0\n\n  /** @type {BytesBufferReader} */\n  return {\n    upTo (length) {\n      let bytes = reader.upTo(length)\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead)\n      }\n      return bytes\n    },\n\n    exactly (length, seek = false) {\n      const bytes = reader.exactly(length, seek)\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data')\n      }\n      if (seek) {\n        bytesRead += length\n      }\n      return bytes\n    },\n\n    seek (length) {\n      bytesRead += length\n      reader.seek(length)\n    },\n\n    get pos () {\n      return reader.pos\n    }\n  }\n}\n", "import * as BufferDecoder from './buffer-decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').CarBufferReader} ICarBufferReader\n * @typedef {import('./coding').CarHeader} CarHeader\n * @typedef {import('./coding').CarV2Header} CarV2Header\n */\n\n/**\n * Provides blockstore-like access to a CAR.\n *\n * Implements the `RootsBufferReader` interface:\n * {@link ICarBufferReader.getRoots `getRoots()`}. And the `BlockBufferReader` interface:\n * {@link ICarBufferReader.get `get()`}, {@link ICarBufferReader.has `has()`},\n * {@link ICarBufferReader.blocks `blocks()`} and\n * {@link ICarBufferReader.cids `cids()`}.\n *\n * Load this class with either `import { CarBufferReader } from '@ipld/car/buffer-reader'`\n * (`const { CarBufferReader } = require('@ipld/car/buffer-reader')`). Or\n * `import { CarBufferReader } from '@ipld/car'` (`const { CarBufferReader } = require('@ipld/car')`).\n * The former will likely result in smaller bundle sizes where this is\n * important.\n *\n * @name CarBufferReader\n * @class\n * @implements {ICarBufferReader}\n * @property {number} version The version number of the CAR referenced by this\n * reader (should be `1` or `2`).\n */\nexport class CarBufferReader {\n  /**\n   * @constructs CarBufferReader\n   * @param {CarHeader|CarV2Header} header\n   * @param {Block[]} blocks\n   */\n  constructor (header, blocks) {\n    this._header = header\n    this._blocks = blocks\n    this._cids = undefined\n  }\n\n  /**\n   * @property version\n   * @memberof CarBufferReader\n   * @instance\n   */\n  get version () {\n    return this._header.version\n  }\n\n  /**\n   * Get the list of roots defined by the CAR referenced by this reader. May be\n   * zero or more `CID`s.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @returns {CID[]}\n   */\n  getRoots () {\n    return this._header.roots\n  }\n\n  /**\n   * Check whether a given `CID` exists within the CAR referenced by this\n   * reader.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @param {CID} key\n   * @returns {boolean}\n   */\n  has (key) {\n    return this._blocks.some(b => b.cid.equals(key))\n  }\n\n  /**\n   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR\n   * referenced by this reader matching the provided `CID`. In the case where\n   * the provided `CID` doesn't exist within the CAR, `undefined` will be\n   * returned.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @param {CID} key\n   * @returns {Block | undefined}\n   */\n  get (key) {\n    return this._blocks.find(b => b.cid.equals(key))\n  }\n\n  /**\n   * Returns a `Block[]` of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within\n   * the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @returns {Block[]}\n   */\n  blocks () {\n    return this._blocks\n  }\n\n  /**\n   * Returns a `CID[]` of the `CID`s contained within the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @returns {CID[]}\n   */\n  cids () {\n    if (!this._cids) {\n      this._cids = this._blocks.map(b => b.cid)\n    }\n    return this._cids\n  }\n\n  /**\n   * Instantiate a {@link CarBufferReader} from a `Uint8Array` blob. This performs a\n   * decode fully in memory and maintains the decoded state in memory for full\n   * access to the data via the `CarReader` API.\n   *\n   * @static\n   * @memberof CarBufferReader\n   * @param {Uint8Array} bytes\n   * @returns {CarBufferReader}\n   */\n  static fromBytes (bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array')\n    }\n\n    const { header, blocks } = BufferDecoder.fromBytes(bytes)\n    return new CarBufferReader(header, blocks)\n  }\n}\n\nexport const __browser = true\n", "import { makeCborEncoders, objectToTokens } from './encode.js'\nimport { quickEncodeToken } from './jump.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\nconst cborEncoders = makeCborEncoders()\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  quickEncodeToken\n}\n\n/**\n * Calculate the byte length of the given data when encoded as CBOR with the\n * options provided.\n * This calculation will be accurate if the same options are used as when\n * performing a normal encode. Some encode options can change the encoding\n * output length.\n *\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {number}\n */\nexport function encodedLength (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  options.mapSorter = undefined // won't change the length\n  const tokens = objectToTokens(data, options)\n  return tokensToLength(tokens, cborEncoders, options)\n}\n\n/**\n * Calculate the byte length of the data as represented by the given tokens when\n * encoded as CBOR with the options provided.\n * This function is for advanced users and would not normally be called\n * directly. See `encodedLength()` for appropriate use.\n *\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} [encoders]\n * @param {EncodeOptions} [options]\n */\nexport function tokensToLength (tokens, encoders = cborEncoders, options = defaultEncodeOptions) {\n  if (Array.isArray(tokens)) {\n    let len = 0\n    for (const token of tokens) {\n      len += tokensToLength(token, encoders, options)\n    }\n    return len\n  } else {\n    const encoder = encoders[tokens.type.major]\n    /* c8 ignore next 3 */\n    if (encoder.encodedSize === undefined || typeof encoder.encodedSize !== 'function') {\n      throw new Error(`Encoder for ${tokens.type.name} does not have an encodedSize()`)\n    }\n    return encoder.encodedSize(tokens, options)\n  }\n}\n", "import * as CBOR from '@ipld/dag-cbor'\nimport { Token, Type } from 'cborg'\nimport { tokensToLength } from 'cborg/length'\nimport varint from 'varint'\n\n/**\n * @typedef {import('./api').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').CarBufferWriter} Writer\n * @typedef {import('./api').CarBufferWriterOptions} Options\n * @typedef {import('./coding').CarEncoder} CarEncoder\n */\n\n/**\n * A simple CAR writer that writes to a pre-allocated buffer.\n *\n * @class\n * @name CarBufferWriter\n * @implements {Writer}\n */\nclass CarBufferWriter {\n  /**\n   * @param {Uint8Array} bytes\n   * @param {number} headerSize\n   */\n  constructor (bytes, headerSize) {\n    /** @readonly */\n    this.bytes = bytes\n    this.byteOffset = headerSize\n\n    /**\n     * @readonly\n     * @type {CID[]}\n     */\n    this.roots = []\n    this.headerSize = headerSize\n  }\n\n  /**\n   * Add a root to this writer, to be used to create a header when the CAR is\n   * finalized with {@link CarBufferWriter.close `close()`}\n   *\n   * @param {CID} root\n   * @param {{resize?:boolean}} [options]\n   * @returns {CarBufferWriter}\n   */\n  addRoot (root, options) {\n    addRoot(this, root, options)\n    return this\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   * Throws if there is not enough capacity.\n   *\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {CarBufferWriter}\n   */\n  write (block) {\n    addBlock(this, block)\n    return this\n  }\n\n  /**\n   * Finalize the CAR and return it as a `Uint8Array`.\n   *\n   * @param {object} [options]\n   * @param {boolean} [options.resize]\n   * @returns {Uint8Array}\n   */\n  close (options) {\n    return close(this, options)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {CID} root\n * @param {{resize?:boolean}} [options]\n */\nexport const addRoot = (writer, root, options = {}) => {\n  const { resize = false } = options\n  const { bytes, headerSize, byteOffset, roots } = writer\n  writer.roots.push(root)\n  const size = headerLength(writer)\n  // If there is not enough space for the new root\n  if (size > headerSize) {\n    // Check if we root would fit if we were to resize the head.\n    if (size - headerSize + byteOffset < bytes.byteLength) {\n      // If resize is enabled resize head\n      if (resize) {\n        resizeHeader(writer, size)\n      // otherwise remove head and throw an error suggesting to resize\n      } else {\n        roots.pop()\n        throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root}.\n  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`)\n      }\n    // If head would not fit even with resize pop new root and throw error\n    } else {\n      roots.pop()\n      throw new RangeError(`Buffer has no capacity for a new root ${root}`)\n    }\n  }\n}\n\n/**\n * Calculates number of bytes required for storing given block in CAR. Useful in\n * estimating size of an `ArrayBuffer` for the `CarBufferWriter`.\n *\n * @name CarBufferWriter.blockLength(Block)\n * @param {Block} block\n * @returns {number}\n */\nexport const blockLength = ({ cid, bytes }) => {\n  const size = cid.bytes.byteLength + bytes.byteLength\n  return varint.encodingLength(size) + size\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {Block} block\n */\nexport const addBlock = (writer, { cid, bytes }) => {\n  const byteLength = cid.bytes.byteLength + bytes.byteLength\n  const size = varint.encode(byteLength)\n  if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {\n    throw new RangeError('Buffer has no capacity for this block')\n  } else {\n    writeBytes(writer, size)\n    writeBytes(writer, cid.bytes)\n    writeBytes(writer, bytes)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {object} [options]\n * @param {boolean} [options.resize]\n */\nexport const close = (writer, options = {}) => {\n  const { resize = false } = options\n  const { roots, bytes, byteOffset, headerSize } = writer\n\n  const headerBytes = CBOR.encode({ version: 1, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n\n  const size = varintBytes.length + headerBytes.byteLength\n  const offset = headerSize - size\n\n  // If header size estimate was accurate we just write header and return\n  // view into buffer.\n  if (offset === 0) {\n    writeHeader(writer, varintBytes, headerBytes)\n    return bytes.subarray(0, byteOffset)\n    // If header was overestimated and `{resize: true}` is passed resize header\n  } else if (resize) {\n    resizeHeader(writer, size)\n    writeHeader(writer, varintBytes, headerBytes)\n    return bytes.subarray(0, writer.byteOffset)\n  } else {\n    throw new RangeError(`Header size was overestimated.\nYou can use close({ resize: true }) to resize header`)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number} byteLength\n */\nexport const resizeHeader = (writer, byteLength) => {\n  const { bytes, headerSize } = writer\n  // Move data section to a new offset\n  bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength)\n  // Update header size & byteOffset\n  writer.byteOffset += byteLength - headerSize\n  writer.headerSize = byteLength\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number[]|Uint8Array} bytes\n */\n\nconst writeBytes = (writer, bytes) => {\n  writer.bytes.set(bytes, writer.byteOffset)\n  writer.byteOffset += bytes.length\n}\n/**\n * @param {{bytes:Uint8Array}} writer\n * @param {number[]} varint\n * @param {Uint8Array} header\n */\nconst writeHeader = ({ bytes }, varint, header) => {\n  bytes.set(varint)\n  bytes.set(header, varint.length)\n}\n\nconst headerPreludeTokens = [\n  new Token(Type.map, 2),\n  new Token(Type.string, 'version'),\n  new Token(Type.uint, 1),\n  new Token(Type.string, 'roots')\n]\n\nconst CID_TAG = new Token(Type.tag, 42)\n\n/**\n * Calculates header size given the array of byteLength for roots.\n *\n * @name CarBufferWriter.calculateHeaderLength(rootLengths)\n * @param {number[]} rootLengths\n * @returns {number}\n */\nexport const calculateHeaderLength = (rootLengths) => {\n  const tokens = [...headerPreludeTokens]\n  tokens.push(new Token(Type.array, rootLengths.length))\n  for (const rootLength of rootLengths) {\n    tokens.push(CID_TAG)\n    tokens.push(new Token(Type.bytes, { length: rootLength + 1 }))\n  }\n  const length = tokensToLength(tokens) // no options needed here because we have simple tokens\n  return varint.encodingLength(length) + length\n}\n\n/**\n * Calculates header size given the array of roots.\n *\n * @name CarBufferWriter.headerLength({ roots })\n * @param {object} options\n * @param {CID[]} options.roots\n * @returns {number}\n */\nexport const headerLength = ({ roots }) =>\n  calculateHeaderLength(roots.map(cid => cid.bytes.byteLength))\n\n/**\n * Estimates header size given a count of the roots and the expected byte length\n * of the root CIDs. The default length works for a standard CIDv1 with a\n * single-byte multihash code, such as SHA2-256 (i.e. the most common CIDv1).\n *\n * @name CarBufferWriter.estimateHeaderLength(rootCount[, rootByteLength])\n * @param {number} rootCount\n * @param {number} [rootByteLength]\n * @returns {number}\n */\nexport const estimateHeaderLength = (rootCount, rootByteLength = 36) =>\n  calculateHeaderLength(new Array(rootCount).fill(rootByteLength))\n\n/**\n * Creates synchronous CAR writer that can be used to encode blocks into a given\n * buffer. Optionally you could pass `byteOffset` and `byteLength` to specify a\n * range inside buffer to write into. If car file is going to have `roots` you\n * need to either pass them under `options.roots` (from which header size will\n * be calculated) or provide `options.headerSize` to allocate required space\n * in the buffer. You may also provide known `roots` and `headerSize` to\n * allocate space for the roots that may not be known ahead of time.\n *\n * Note: Incorrect `headerSize` may lead to copying bytes inside a buffer\n * which will have a negative impact on performance.\n *\n * @name CarBufferWriter.createWriter(buffer[, options])\n * @param {ArrayBuffer} buffer\n * @param {object} [options]\n * @param {CID[]} [options.roots]\n * @param {number} [options.byteOffset]\n * @param {number} [options.byteLength]\n * @param {number} [options.headerSize]\n * @returns {CarBufferWriter}\n */\nexport const createWriter = (buffer, options = {}) => {\n  const {\n    roots = [],\n    byteOffset = 0,\n    byteLength = buffer.byteLength,\n    headerSize = headerLength({ roots })\n  } = options\n  const bytes = new Uint8Array(buffer, byteOffset, byteLength)\n\n  const writer = new CarBufferWriter(bytes, headerSize)\n  for (const root of roots) {\n    writer.addRoot(root)\n  }\n\n  return writer\n}\n", "export * as URI from './schema/uri.js'\nexport * as Link from './schema/link.js'\nexport * as DID from './schema/did.js'\nexport * as Text from './schema/text.js'\nexport * from './schema/schema.js'\nexport { match as link } from './schema/link.js'\nexport { match as did } from './schema/did.js'\nexport { match as uri } from './schema/uri.js'\nexport { match as text } from './schema/text.js'\n", "import * as API from '@ucanto/interface'\nimport * as Schema from './schema.js'\n\n/**\n * @template {API.Protocol} [P=API.Protocol]\n * @typedef {{protocol: P}} Options\n */\n\n/**\n * @template {Options} O\n * @extends {Schema.API<API.URI<O['protocol']>, unknown, Partial<O>>}\n */\nclass URISchema extends Schema.API {\n  /**\n   * @param {unknown} input\n   * @param {Partial<O>} options\n   * @returns {Schema.ReadResult<API.URI<O['protocol']>>}\n   */\n  readWith(input, { protocol } = {}) {\n    if (typeof input !== 'string' && !(input instanceof URL)) {\n      return Schema.error(\n        `Expected URI but got ${input === null ? 'null' : typeof input}`\n      )\n    }\n\n    try {\n      const url = new URL(String(input))\n      if (protocol != null && url.protocol !== protocol) {\n        return Schema.error(`Expected ${protocol} URI instead got ${url.href}`)\n      } else {\n        return { ok: /** @type {API.URI<O['protocol']>} */ (url.href) }\n      }\n    } catch (_) {\n      return Schema.error(`Invalid URI`)\n    }\n  }\n}\n\nconst schema = new URISchema({})\n\n/**\n * @returns {Schema.Schema<API.URI, unknown>}\n */\nexport const uri = () => schema\n\n/**\n * @param {unknown} input\n */\nexport const read = input => schema.read(input)\n\n/**\n * @template {API.Protocol} P\n * @template {Options<P>} O\n * @param {O} options\n * @returns {Schema.Schema<API.URI<O['protocol']>, unknown>}\n */\nexport const match = options => new URISchema(options)\n\n/**\n * @template {string} [Scheme=string]\n * @param {`${Scheme}:${string}`} input\n */\nexport const from = input =>\n  /** @type {API.URI<`${Scheme}:`>} */ (schema.from(input))\n", "import * as API from '@ucanto/interface'\n\n/**\n * Creates the success result containing given `value`. Throws if\n * `null` or `undefined` passed to encourage use of units instead.\n *\n * @template {{}|string|boolean|number} T\n * @param {T} value\n * @returns {{ok: T, error?:undefined}}\n */\nexport const ok = value => {\n  if (value == null) {\n    throw new TypeError(`ok(${value}) is not allowed, consider ok({}) instead`)\n  } else {\n    return { ok: value }\n  }\n}\n\n/**\n * Creates the failing result containing given `cause` of error.\n * Throws if `cause` is `null` or `undefined` to encourage\n * passing descriptive errors instead.\n *\n * @template {{}|string|boolean|number} X\n * @param {X} cause\n * @returns {{ok?:undefined, error:X}}\n */\nexport const error = cause => {\n  if (cause == null) {\n    throw new TypeError(\n      `error(${cause}) is not allowed, consider passing an error instead`\n    )\n  } else {\n    return { error: cause }\n  }\n}\n\n/**\n * Crash the program with a given `message`. This function is\n * intended to be used in places where it is impossible to\n * recover from an error. It is similar to `panic` function in\n * Rust.\n *\n * @param {string} message\n */\nexport const panic = message => {\n  throw new Failure(message)\n}\n/**\n * Creates the failing result containing an error with a given\n * `message`. Unlike `error` function it creates a very generic\n *  error with `message` & `stack` fields. The `error` function\n * is recommended over `fail` for all but the most basic use cases.\n *\n * @param {string} message\n * @returns {{error:API.Failure, ok?:undefined}}\n */\nexport const fail = message => ({ error: new Failure(message) })\n\n/**\n * @implements {API.Failure}\n */\nexport class Failure extends Error {\n  describe() {\n    return this.toString()\n  }\n  get message() {\n    return this.describe()\n  }\n  toJSON() {\n    const { name, message, stack } = this\n    return { name, message, stack }\n  }\n}\n", "import * as Schema from './type.js'\nimport { ok, Failure } from '../result.js'\nexport * from './type.js'\n\nexport { ok }\n/**\n * @abstract\n * @template [T=unknown]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {Schema.Base<T, I, Settings>}\n * @implements {Schema.Schema<T, I>}\n */\nexport class API {\n  /**\n   * @param {Settings} settings\n   */\n  constructor(settings) {\n    /** @protected */\n    this.settings = settings\n  }\n\n  toString() {\n    return `new ${this.constructor.name}()`\n  }\n  /**\n   * @abstract\n   * @param {I} input\n   * @param {Settings} settings\n   * @returns {Schema.ReadResult<T>}\n   */\n  /* c8 ignore next 3 */\n  readWith(input, settings) {\n    throw new Error(`Abstract method readWith must be implemented by subclass`)\n  }\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<T>}\n   */\n  read(input) {\n    return this.readWith(input, this.settings)\n  }\n\n  /**\n   * @param {unknown} value\n   * @returns {value is T}\n   */\n  is(value) {\n    return !this.read(/** @type {I} */ (value))?.error\n  }\n\n  /**\n   * @param {unknown} value\n   * @return {T}\n   */\n  from(value) {\n    const result = this.read(/** @type {I} */ (value))\n    if (result.error) {\n      throw result.error\n    } else {\n      return result.ok\n    }\n  }\n\n  /**\n   * @returns {Schema.Schema<T|undefined, I>}\n   */\n  optional() {\n    return optional(this)\n  }\n\n  /**\n   * @returns {Schema.Schema<T|null, I>}\n   */\n  nullable() {\n    return nullable(this)\n  }\n\n  /**\n   * @returns {Schema.Schema<T[], I>}\n   */\n  array() {\n    return array(this)\n  }\n  /**\n   * @template U\n   * @param {Schema.Reader<U, I>} schema\n   * @returns {Schema.Schema<T | U, I>}\n   */\n\n  or(schema) {\n    return or(this, schema)\n  }\n\n  /**\n   * @template U\n   * @param {Schema.Reader<U, I>} schema\n   * @returns {Schema.Schema<T & U, I>}\n   */\n  and(schema) {\n    return and(this, schema)\n  }\n\n  /**\n   * @template {T} U\n   * @param {Schema.Reader<U, T>} schema\n   * @returns {Schema.Schema<U, I>}\n   */\n  refine(schema) {\n    return refine(this, schema)\n  }\n\n  /**\n   * @template {string} Kind\n   * @param {Kind} [kind]\n   * @returns {Schema.Schema<Schema.Branded<T, Kind>, I>}\n   */\n  brand(kind) {\n    return /** @type {Schema.Schema<Schema.Branded<T, Kind>, I>} */ (this)\n  }\n\n  /**\n   * @param {Schema.NotUndefined<T>} value\n   * @returns {Schema.DefaultSchema<Schema.NotUndefined<T>, I>}\n   */\n  default(value) {\n    // \u26A0\uFE0F this.from will throw if wrong default is provided\n    const fallback = this.from(value)\n    // we also check that fallback is not undefined because that is the point\n    // of having a fallback\n    if (fallback === undefined) {\n      throw new Error(`Value of type undefined is not a valid default`)\n    }\n\n    const schema = new Default({\n      reader: /** @type {Schema.Reader<T, I>} */ (this),\n      value: /** @type {Schema.NotUndefined<T>} */ (fallback),\n    })\n\n    return /** @type {Schema.DefaultSchema<Schema.NotUndefined<T>, I>} */ (\n      schema\n    )\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {API<never, I>}\n * @implements {Schema.Schema<never, I>}\n */\nclass Never extends API {\n  toString() {\n    return 'never()'\n  }\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<never>}\n   */\n  read(input) {\n    return typeError({ expect: 'never', actual: input })\n  }\n}\n\n/**\n * @template [I=unknown]\n * @returns {Schema.Schema<never, I>}\n */\nexport const never = () => new Never()\n\n/**\n * @template [I=unknown]\n * @extends API<unknown, I, void>\n * @implements {Schema.Schema<unknown, I>}\n */\nclass Unknown extends API {\n  /**\n   * @param {I} input\n   */\n  read(input) {\n    return /** @type {Schema.ReadResult<unknown>}*/ ({ ok: input })\n  }\n  toString() {\n    return 'unknown()'\n  }\n}\n\n/**\n * @template [I=unknown]\n * @returns {Schema.Schema<unknown, I>}\n */\nexport const unknown = () => new Unknown()\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<null|O, I, Schema.Reader<O, I>>}\n * @implements {Schema.Schema<null|O, I>}\n */\nclass Nullable extends API {\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} reader\n   */\n  readWith(input, reader) {\n    const result = reader.read(input)\n    if (result.error) {\n      return input === null\n        ? { ok: null }\n        : {\n            error: new UnionError({\n              causes: [\n                result.error,\n                typeError({ expect: 'null', actual: input }).error,\n              ],\n            }),\n          }\n    } else {\n      return result\n    }\n  }\n  toString() {\n    return `${this.settings}.nullable()`\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.Schema<O|null, I>}\n */\nexport const nullable = schema => new Nullable(schema)\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<O|undefined, I, Schema.Reader<O, I>>}\n * @implements {Schema.Schema<O|undefined, I>}\n */\nclass Optional extends API {\n  optional() {\n    return this\n  }\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} reader\n   * @returns {Schema.ReadResult<O|undefined>}\n   */\n  readWith(input, reader) {\n    const result = reader.read(input)\n    return result.error && input === undefined ? { ok: undefined } : result\n  }\n  toString() {\n    return `${this.settings}.optional()`\n  }\n}\n\n/**\n * @template {unknown} O\n * @template [I=unknown]\n * @extends {API<O, I, {reader:Schema.Reader<O, I>, value:O & Schema.NotUndefined<O>}>}\n * @implements {Schema.DefaultSchema<O, I>}\n */\nclass Default extends API {\n  /**\n   * @returns {Schema.DefaultSchema<O & Schema.NotUndefined<O>, I>}\n   */\n  optional() {\n    // Short circuit here as we there is no point in wrapping this in optional.\n    return /** @type {Schema.DefaultSchema<O & Schema.NotUndefined<O>, I>} */ (\n      this\n    )\n  }\n  /**\n   * @param {I} input\n   * @param {object} options\n   * @param {Schema.Reader<O|undefined, I>} options.reader\n   * @param {O} options.value\n   * @returns {Schema.ReadResult<O>}\n   */\n  readWith(input, { reader, value }) {\n    if (input === undefined) {\n      return /** @type {Schema.ReadResult<O>} */ ({ ok: value })\n    } else {\n      const result = reader.read(input)\n\n      return result.error\n        ? result\n        : result.ok !== undefined\n        ? // We just checked that result.ok is not undefined but still needs\n          // reassurance\n          /** @type {Schema.ReadResult<O>} */ (result)\n        : { ok: value }\n    }\n  }\n  toString() {\n    return `${this.settings.reader}.default(${JSON.stringify(\n      this.settings.value\n    )})`\n  }\n\n  get value() {\n    return this.settings.value\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.Schema<O|undefined, I>}\n */\nexport const optional = schema => new Optional(schema)\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<O[], I, Schema.Reader<O, I>>}\n * @implements {Schema.ArraySchema<O, I>}\n */\nclass ArrayOf extends API {\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} schema\n   */\n  readWith(input, schema) {\n    if (!Array.isArray(input)) {\n      return typeError({ expect: 'array', actual: input })\n    }\n    /** @type {O[]} */\n    const results = []\n    for (const [index, value] of input.entries()) {\n      const result = schema.read(value)\n      if (result.error) {\n        return memberError({ at: index, cause: result.error })\n      } else {\n        results.push(result.ok)\n      }\n    }\n    return { ok: results }\n  }\n  get element() {\n    return this.settings\n  }\n  toString() {\n    return `array(${this.element})`\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.ArraySchema<O, I>}\n */\nexport const array = schema => new ArrayOf(schema)\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferTuple<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferTuple<U>, I>}\n */\nclass Tuple extends API {\n  /**\n   * @param {I} input\n   * @param {U} shape\n   * @returns {Schema.ReadResult<Schema.InferTuple<U>>}\n   */\n  readWith(input, shape) {\n    if (!Array.isArray(input)) {\n      return typeError({ expect: 'array', actual: input })\n    }\n    if (input.length !== this.shape.length) {\n      return error(`Array must contain exactly ${this.shape.length} elements`)\n    }\n\n    const results = []\n    for (const [index, reader] of shape.entries()) {\n      const result = reader.read(input[index])\n      if (result.error) {\n        return memberError({ at: index, cause: result.error })\n      } else {\n        results[index] = result.ok\n      }\n    }\n\n    return { ok: /** @type {Schema.InferTuple<U>} */ (results) }\n  }\n\n  /** @type {U} */\n  get shape() {\n    return this.settings\n  }\n\n  toString() {\n    return `tuple([${this.shape.map(reader => reader.toString()).join(', ')}])`\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} shape\n * @returns {Schema.Schema<Schema.InferTuple<U>, I>}\n */\nexport const tuple = shape => new Tuple(shape)\n\n/**\n * @template V\n * @template {string} K\n * @template [I=unknown]\n * @extends {API<Schema.Dictionary<K, V>, I, { key: Schema.Reader<K, string>, value: Schema.Reader<V, I> }>}\n * @implements {Schema.DictionarySchema<V, K, I>}\n */\nclass Dictionary extends API {\n  /**\n   * @param {I} input\n   * @param {object} schema\n   * @param {Schema.Reader<K, string>} schema.key\n   * @param {Schema.Reader<V, I>} schema.value\n   */\n  readWith(input, { key, value }) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'dictionary',\n        actual: input,\n      })\n    }\n\n    const dict = /** @type {Schema.Dictionary<K, V>} */ ({})\n\n    for (const [k, v] of Object.entries(input)) {\n      const keyResult = key.read(k)\n      if (keyResult.error) {\n        return memberError({ at: k, cause: keyResult.error })\n      }\n\n      const valueResult = value.read(v)\n      if (valueResult.error) {\n        return memberError({ at: k, cause: valueResult.error })\n      }\n\n      // skip undefined because they mess up CBOR and are generally useless.\n      if (valueResult.ok !== undefined) {\n        dict[keyResult.ok] = valueResult.ok\n      }\n    }\n\n    return { ok: dict }\n  }\n  get key() {\n    return this.settings.key\n  }\n  get value() {\n    return this.settings.value\n  }\n\n  partial() {\n    const { key, value } = this.settings\n    return new Dictionary({\n      key,\n      value: optional(value),\n    })\n  }\n  toString() {\n    return `dictionary(${this.settings})`\n  }\n}\n\n/**\n * @template {string} K\n * @template {unknown} V\n * @template [I=unknown]\n * @param {object} shape\n * @param {Schema.Reader<V, I>} shape.value\n * @param {Schema.Reader<K, string>} [shape.key]\n * @returns {Schema.DictionarySchema<V, K, I>}\n */\nexport const dictionary = ({ value, key }) =>\n  new Dictionary({\n    value,\n    key: key || /** @type {Schema.Reader<K, string>} */ (string()),\n  })\n\n/**\n * @template {[unknown, ...unknown[]]} T\n * @template [I=unknown]\n * @extends {API<T[number], I, {type: string, variants:Set<T[number]>}>}\n * @implements {Schema.Schema<T[number], I>}\n */\nclass Enum extends API {\n  /**\n   * @param {I} input\n   * @param {{type:string, variants:Set<T[number]>}} settings\n   * @returns {Schema.ReadResult<T[number]>}\n   */\n  readWith(input, { variants, type }) {\n    if (variants.has(input)) {\n      return /** @type {Schema.ReadResult<T[number]>} */ ({ ok: input })\n    } else {\n      return typeError({ expect: type, actual: input })\n    }\n  }\n  toString() {\n    return this.settings.type\n  }\n}\n\n/**\n * @template {string} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<U[number], I>}\n */\nconst createEnum = variants =>\n  new Enum({\n    type: variants.join('|'),\n    variants: new Set(variants),\n  })\nexport { createEnum as enum }\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferUnion<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferUnion<U>, I>}\n */\nclass Union extends API {\n  /**\n   * @param {I} input\n   * @param {U} variants\n   */\n  readWith(input, variants) {\n    const causes = []\n    for (const reader of variants) {\n      const result = reader.read(input)\n      if (result.error) {\n        causes.push(result.error)\n      } else {\n        return /** @type {Schema.ReadResult<Schema.InferUnion<U>>} */ (result)\n      }\n    }\n    return { error: new UnionError({ causes }) }\n  }\n\n  get variants() {\n    return this.settings\n  }\n  toString() {\n    return `union([${this.variants.map(type => type.toString()).join(', ')}])`\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<Schema.InferUnion<U>, I>}\n */\nconst union = variants => new Union(variants)\n\n/**\n * @template T, U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} left\n * @param {Schema.Reader<U, I>} right\n * @returns {Schema.Schema<T|U, I>}\n */\nexport const or = (left, right) => union([left, right])\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferIntersection<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferIntersection<U>, I>}\n */\nclass Intersection extends API {\n  /**\n   * @param {I} input\n   * @param {U} schemas\n   * @returns {Schema.ReadResult<Schema.InferIntersection<U>>}\n   */\n  readWith(input, schemas) {\n    const causes = []\n    for (const schema of schemas) {\n      const result = schema.read(input)\n      if (result.error) {\n        causes.push(result.error)\n      }\n    }\n\n    return causes.length > 0\n      ? { error: new IntersectionError({ causes }) }\n      : /** @type {Schema.ReadResult<Schema.InferIntersection<U>>} */ ({\n          ok: input,\n        })\n  }\n  toString() {\n    return `intersection([${this.settings\n      .map(type => type.toString())\n      .join(',')}])`\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<Schema.InferIntersection<U>, I>}\n */\nexport const intersection = variants => new Intersection(variants)\n\n/**\n * @template T, U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} left\n * @param {Schema.Reader<U, I>} right\n * @returns {Schema.Schema<T & U, I>}\n */\nexport const and = (left, right) => intersection([left, right])\n\n/**\n * @template [I=unknown]\n * @extends {API<boolean, I>}\n */\nclass Boolean extends API {\n  /**\n   * @param {I} input\n   */\n  readWith(input) {\n    switch (input) {\n      case true:\n      case false:\n        return { ok: /** @type {boolean} */ (input) }\n      default:\n        return typeError({\n          expect: 'boolean',\n          actual: input,\n        })\n    }\n  }\n\n  toString() {\n    return `boolean()`\n  }\n}\n\n/** @type {Schema.Schema<boolean, unknown>} */\nconst anyBoolean = new Boolean()\n\nexport const boolean = () => anyBoolean\n\n/**\n * @template {number} [O=number]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {API<O, I, Settings>}\n * @implements {Schema.NumberSchema<O, I>}\n */\nclass UnknownNumber extends API {\n  /**\n   * @param {number} n\n   */\n  greaterThan(n) {\n    return this.refine(greaterThan(n))\n  }\n  /**\n   * @param {number} n\n   */\n  lessThan(n) {\n    return this.refine(lessThan(n))\n  }\n\n  /**\n   * @template {O} U\n   * @param {Schema.Reader<U, O>} schema\n   * @returns {Schema.NumberSchema<U, I>}\n   */\n  refine(schema) {\n    return new RefinedNumber({ base: this, schema })\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {UnknownNumber<number, I>}\n * @implements {Schema.NumberSchema<number, I>}\n */\nclass AnyNumber extends UnknownNumber {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<number>}\n   */\n  readWith(input) {\n    return typeof input === 'number'\n      ? { ok: input }\n      : typeError({ expect: 'number', actual: input })\n  }\n  toString() {\n    return `number()`\n  }\n}\n\n/** @type {Schema.NumberSchema<number, unknown>} */\nconst anyNumber = new AnyNumber()\nexport const number = () => anyNumber\n\n/**\n * @template {number} [T=number]\n * @template {T} [O=T]\n * @template [I=unknown]\n * @extends {UnknownNumber<O, I, {base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}>}\n * @implements {Schema.NumberSchema<O, I>}\n */\nclass RefinedNumber extends UnknownNumber {\n  /**\n   * @param {I} input\n   * @param {{base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}} settings\n   * @returns {Schema.ReadResult<O>}\n   */\n  readWith(input, { base, schema }) {\n    const result = base.read(input)\n    return result.error ? result : schema.read(result.ok)\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`\n  }\n}\n\n/**\n * @template {number} T\n * @extends {API<T, T, number>}\n */\nclass LessThan extends API {\n  /**\n   * @param {T} input\n   * @param {number} number\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, number) {\n    if (input < number) {\n      return { ok: input }\n    } else {\n      return error(`Expected ${input} < ${number}`)\n    }\n  }\n  toString() {\n    return `lessThan(${this.settings})`\n  }\n}\n\n/**\n * @template {number} T\n * @param {number} n\n * @returns {Schema.Schema<T, T>}\n */\nexport const lessThan = n => new LessThan(n)\n\n/**\n * @template {number} T\n * @extends {API<T, T, number>}\n */\nclass GreaterThan extends API {\n  /**\n   * @param {T} input\n   * @param {number} number\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, number) {\n    if (input > number) {\n      return { ok: input }\n    } else {\n      return error(`Expected ${input} > ${number}`)\n    }\n  }\n  toString() {\n    return `greaterThan(${this.settings})`\n  }\n}\n\n/**\n * @template {number} T\n * @param {number} n\n * @returns {Schema.Schema<T, T>}\n */\nexport const greaterThan = n => new GreaterThan(n)\n\nconst Integer = {\n  /**\n   * @param {number} input\n   * @returns {Schema.ReadResult<Schema.Integer>}\n   */\n  read(input) {\n    return Number.isInteger(input)\n      ? { ok: /** @type {Schema.Integer} */ (input) }\n      : typeError({\n          expect: 'integer',\n          actual: input,\n        })\n  },\n  toString() {\n    return `Integer`\n  },\n}\n\nconst anyInteger = anyNumber.refine(Integer)\nexport const integer = () => anyInteger\n\nconst MAX_UINT64 = 2n ** 64n - 1n\n\n/**\n * @template {bigint} [O=Schema.Uint64]\n * @template [I=unknown]\n * @extends {API<O, I, void>}\n * @implements {Schema.Schema<O, I>}\n */\nclass Uint64Schema extends API {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<O>}\n   */\n  read(input) {\n    switch (typeof input) {\n      case 'bigint':\n        return input > MAX_UINT64\n          ? error(`Integer is too big for uint64, ${input} > ${MAX_UINT64}`)\n          : input < 0\n          ? error(\n              `Negative integer can not be represented as uint64, ${input} < ${0}`\n            )\n          : { ok: /** @type {I & O} */ (input) }\n\n      case 'number':\n        return !Number.isInteger(input)\n          ? typeError({\n              expect: 'uint64',\n              actual: input,\n            })\n          : input < 0\n          ? error(\n              `Negative integer can not be represented as uint64, ${input} < ${0}`\n            )\n          : { ok: /** @type {O} */ (BigInt(input)) }\n\n      default:\n        return typeError({\n          expect: 'uint64',\n          actual: input,\n        })\n    }\n  }\n\n  toString() {\n    return `uint64`\n  }\n}\n\n/** @type {Schema.Schema<Schema.Uint64, unknown>} */\nconst Uint64 = new Uint64Schema()\n\n/**\n * Creates a schema for {@link Schema.Uint64} values represented as  a`bigint`.\n *\n * \u26A0\uFE0F Please note that while IPLD in principal considers the range of integers\n * to be infinite n practice, many libraries / codecs may choose to implement\n * things in such a way that numbers may have limited sizes.\n *\n * So please use this with caution and always ensure that used codecs do support\n * uint64.\n */\nexport const uint64 = () => Uint64\n\nconst Float = {\n  /**\n   * @param {number} number\n   * @returns {Schema.ReadResult<Schema.Float>}\n   */\n  read(number) {\n    return Number.isFinite(number)\n      ? { ok: /** @type {Schema.Float} */ (number) }\n      : typeError({\n          expect: 'Float',\n          actual: number,\n        })\n  },\n  toString() {\n    return 'Float'\n  },\n}\n\nconst anyFloat = anyNumber.refine(Float)\nexport const float = () => anyFloat\n\n/**\n * @template {string} [O=string]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {API<O, I, Settings>}\n */\nclass UnknownString extends API {\n  /**\n   * @template {O|unknown} U\n   * @param {Schema.Reader<U, O>} schema\n   * @returns {Schema.StringSchema<O & U, I>}\n   */\n  refine(schema) {\n    const other = /** @type {Schema.Reader<U, O>} */ (schema)\n    const rest = new RefinedString({\n      base: this,\n      schema: other,\n    })\n\n    return /** @type {Schema.StringSchema<O & U, I>} */ (rest)\n  }\n  /**\n   * @template {string} Prefix\n   * @param {Prefix} prefix\n   */\n  startsWith(prefix) {\n    return this.refine(startsWith(prefix))\n  }\n  /**\n   * @template {string} Suffix\n   * @param {Suffix} suffix\n   */\n  endsWith(suffix) {\n    return this.refine(endsWith(suffix))\n  }\n  toString() {\n    return `string()`\n  }\n}\n\n/**\n * @template O\n * @template {string} [T=string]\n * @template [I=unknown]\n * @extends {UnknownString<T & O, I, {base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}>}\n * @implements {Schema.StringSchema<O & T, I>}\n */\nclass RefinedString extends UnknownString {\n  /**\n   * @param {I} input\n   * @param {{base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}} settings\n   * @returns {Schema.ReadResult<T & O>}\n   */\n  readWith(input, { base, schema }) {\n    const result = base.read(input)\n    return result.error\n      ? result\n      : /** @type {Schema.ReadResult<T & O>} */ (schema.read(result.ok))\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {UnknownString<string, I>}\n * @implements {Schema.StringSchema<string, I>}\n */\nclass AnyString extends UnknownString {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<string>}\n   */\n  readWith(input) {\n    return typeof input === 'string'\n      ? { ok: input }\n      : typeError({ expect: 'string', actual: input })\n  }\n}\n\n/** @type {Schema.StringSchema<string, unknown>} */\nconst anyString = new AnyString()\nexport const string = () => anyString\n\n/**\n * @template [I=unknown]\n * @extends {API<Uint8Array, I, void>}\n */\nclass BytesSchema extends API {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<Uint8Array>}\n   */\n  readWith(input) {\n    if (input instanceof Uint8Array) {\n      return { ok: input }\n    } else {\n      return typeError({ expect: 'Uint8Array', actual: input })\n    }\n  }\n}\n\n/** @type {Schema.Schema<Uint8Array, unknown>} */\nexport const Bytes = new BytesSchema()\nexport const bytes = () => Bytes\n\n/**\n * @template {string} Prefix\n * @template {string} Body\n * @extends {API<Body & `${Prefix}${Body}`, Body, Prefix>}\n * @implements {Schema.Schema<Body & `${Prefix}${Body}`, Body>}\n */\nclass StartsWith extends API {\n  /**\n   * @param {Body} input\n   * @param {Prefix} prefix\n   */\n  readWith(input, prefix) {\n    const result = input.startsWith(prefix)\n      ? /** @type {Schema.ReadResult<Body & `${Prefix}${Body}`>} */ ({\n          ok: input,\n        })\n      : error(`Expect string to start with \"${prefix}\" instead got \"${input}\"`)\n\n    return result\n  }\n  get prefix() {\n    return this.settings\n  }\n  toString() {\n    return `startsWith(\"${this.prefix}\")`\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {string} Body\n * @param {Prefix} prefix\n * @returns {Schema.Schema<`${Prefix}${string}`, string>}\n */\nexport const startsWith = prefix => new StartsWith(prefix)\n\n/**\n * @template {string} Suffix\n * @template {string} Body\n * @extends {API<Body & `${Body}${Suffix}`, Body, Suffix>}\n */\nclass EndsWith extends API {\n  /**\n   * @param {Body} input\n   * @param {Suffix} suffix\n   */\n  readWith(input, suffix) {\n    return input.endsWith(suffix)\n      ? /** @type {Schema.ReadResult<Body & `${Body}${Suffix}`>} */ ({\n          ok: input,\n        })\n      : error(`Expect string to end with \"${suffix}\" instead got \"${input}\"`)\n  }\n  get suffix() {\n    return this.settings\n  }\n  toString() {\n    return `endsWith(\"${this.suffix}\")`\n  }\n}\n\n/**\n * @template {string} Suffix\n * @param {Suffix} suffix\n * @returns {Schema.Schema<`${string}${Suffix}`, string>}\n */\nexport const endsWith = suffix => new EndsWith(suffix)\n\n/**\n * @template T\n * @template {T} U\n * @template [I=unknown]\n * @extends {API<U, I, { base: Schema.Reader<T, I>, schema: Schema.Reader<U, T> }>}\n * @implements {Schema.Schema<U, I>}\n */\n\nclass Refine extends API {\n  /**\n   * @param {I} input\n   * @param {{ base: Schema.Reader<T, I>, schema: Schema.Reader<U, T> }} settings\n   */\n  readWith(input, { base, schema }) {\n    const result = base.read(input)\n    return result.error ? result : schema.read(result.ok)\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`\n  }\n}\n\n/**\n * @template T\n * @template {T} U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} base\n * @param {Schema.Reader<U, T>} schema\n * @returns {Schema.Schema<U, I>}\n */\nexport const refine = (base, schema) => new Refine({ base, schema })\n\n/**\n * @template {null|boolean|string|number} T\n * @template [I=unknown]\n * @extends {API<T, I, T>}\n * @implements {Schema.LiteralSchema<T, I>}\n */\nclass Literal extends API {\n  /**\n   * @param {I} input\n   * @param {T} expect\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, expect) {\n    return input !== /** @type {unknown} */ (expect)\n      ? { error: new LiteralError({ expect, actual: input }) }\n      : { ok: expect }\n  }\n  get value() {\n    return /** @type {Exclude<T, undefined>} */ (this.settings)\n  }\n  /**\n   * @template {Schema.NotUndefined<T>} U\n   * @param {U} value\n   */\n  default(value = /** @type {U} */ (this.value)) {\n    return super.default(value)\n  }\n  toString() {\n    return `literal(${toString(this.value)})`\n  }\n}\n\n/**\n * @template {null|boolean|string|number} T\n * @template [I=unknown]\n * @param {T} value\n * @returns {Schema.LiteralSchema<T, I>}\n */\nexport const literal = value => new Literal(value)\n\n/**\n * @template {{[key:string]: Schema.Reader}} U\n * @template [I=unknown]\n * @extends {API<Schema.InferStruct<U>, I, U>}\n */\nclass Struct extends API {\n  /**\n   * @param {I} input\n   * @param {U} shape\n   * @returns {Schema.ReadResult<Schema.InferStruct<U>>}\n   */\n  readWith(input, shape) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'object',\n        actual: input,\n      })\n    }\n\n    const source = /** @type {{[K in keyof U]: unknown}} */ (input)\n\n    const struct = /** @type {{[K in keyof U]: Schema.Infer<U[K]>}} */ ({})\n    const entries =\n      /** @type {{[K in keyof U]: [K & string, U[K]]}[keyof U][]} */ (\n        Object.entries(shape)\n      )\n\n    for (const [at, reader] of entries) {\n      const result = reader.read(source[at])\n      if (result.error) {\n        return memberError({ at, cause: result.error })\n      }\n      // skip undefined because they mess up CBOR and are generally useless.\n      else if (result.ok !== undefined) {\n        struct[at] = /** @type {Schema.Infer<U[typeof at]>} */ (result.ok)\n      }\n    }\n\n    return { ok: struct }\n  }\n\n  /**\n   * @returns {Schema.MapRepresentation<Partial<Schema.InferStruct<U>>> & Schema.StructSchema}\n   */\n  partial() {\n    return new Struct(\n      Object.fromEntries(\n        Object.entries(this.shape).map(([key, value]) => [key, optional(value)])\n      )\n    )\n  }\n\n  /** @type {U} */\n  get shape() {\n    // @ts-ignore - We declared `settings` private but we access it here\n    return this.settings\n  }\n\n  toString() {\n    return [\n      `struct({ `,\n      ...Object.entries(this.shape)\n        .map(([key, schema]) => `${key}: ${schema}`)\n        .join(', '),\n      ` })`,\n    ].join('')\n  }\n\n  /**\n   * @param {Schema.InferStructSource<U>} data\n   */\n  create(data) {\n    return this.from(data || {})\n  }\n\n  /**\n   * @template {{[key:string]: Schema.Reader}} E\n   * @param {E} extension\n   * @returns {Schema.StructSchema<U & E, I>}\n   */\n  extend(extension) {\n    return new Struct({ ...this.shape, ...extension })\n  }\n}\n\n/**\n * @template {null|boolean|string|number} T\n * @template {{[key:string]: T|Schema.Reader}} U\n * @template {{[K in keyof U]: U[K] extends Schema.Reader ? U[K] : Schema.LiteralSchema<U[K] & T>}} V\n * @template [I=unknown]\n * @param {U} fields\n * @returns {Schema.StructSchema<V, I>}\n */\nexport const struct = fields => {\n  const shape =\n    /** @type {{[K in keyof U]: Schema.Reader<unknown, unknown>}} */ ({})\n  /** @type {[keyof U & string, T|Schema.Reader][]} */\n  const entries = Object.entries(fields)\n\n  for (const [key, field] of entries) {\n    switch (typeof field) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n        shape[key] = literal(field)\n        break\n      case 'object':\n        shape[key] = field === null ? literal(null) : field\n        break\n      default:\n        throw new Error(\n          `Invalid struct field \"${key}\", expected schema or literal, instead got ${typeof field}`\n        )\n    }\n  }\n\n  return new Struct(/** @type {V} */ (shape))\n}\n\n/**\n * @template {Schema.VariantChoices} U\n * @template [I=unknown]\n * @extends {API<Schema.InferVariant<U>, I, U>}\n * @implements {Schema.VariantSchema<U, I>}\n */\nclass Variant extends API {\n  /**\n   * @param {I} input\n   * @param {U} variants\n   * @returns {Schema.ReadResult<Schema.InferVariant<U>>}\n   */\n  readWith(input, variants) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'object',\n        actual: input,\n      })\n    }\n\n    const keys = /** @type {Array<keyof input & keyof variants & string>} */ (\n      Object.keys(input)\n    )\n\n    const [key] = keys.length === 1 ? keys : []\n    const reader = key ? variants[key] : undefined\n\n    if (reader) {\n      const result = reader.read(input[key])\n      return result.error\n        ? memberError({ at: key, cause: result.error })\n        : { ok: /** @type {Schema.InferVariant<U>} */ ({ [key]: result.ok }) }\n    } else if (variants._) {\n      const result = variants._.read(input)\n      return result.error\n        ? result\n        : { ok: /** @type {Schema.InferVariant<U>} */ ({ _: result.ok }) }\n    } else if (key) {\n      return error(\n        `Expected an object with one of the these keys: ${Object.keys(variants)\n          .sort()\n          .join(', ')} instead got object with key ${key}`\n      )\n    } else {\n      return error(\n        'Expected an object with a single key instead got object with keys ' +\n          keys.sort().join(', ')\n      )\n    }\n  }\n\n  /**\n   * @template [E=never]\n   * @param {I} input\n   * @param {E} [fallback]\n   */\n  match(input, fallback) {\n    const result = this.read(input)\n    if (result.error) {\n      if (fallback !== undefined) {\n        return [null, fallback]\n      } else {\n        throw result.error\n      }\n    } else {\n      const [key] = Object.keys(result.ok)\n      const value = result.ok[key]\n      return /** @type {any} */ ([key, value])\n    }\n  }\n\n  /**\n   * @template {Schema.InferVariant<U>} O\n   * @param {O} source\n   * @returns {O}\n   */\n  create(source) {\n    return /** @type {O} */ (this.from(source))\n  }\n}\n\n/**\n * Defines a schema for the `Variant` type. It takes an object where\n * keys denote branches of the variant and values are schemas for the values of\n * those branches. The schema will only match objects with a single key and\n * value that matches the schema for that key. If the object has more than one\n * key or the key does not match any of the keys in the schema then the schema\n * will fail.\n *\n * The `_` branch is a special case. If such branch is present then it will be\n * used as a fallback for any object that does not match any of the variant\n * branches. The `_` branch will be used even if the object has more than one\n * key. Unlike other branches the `_` branch will receive the entire object as\n * input and not just the value of the key. Usually the `_` branch can be set\n * to `Schema.unknown` or `Schema.dictionary` to facilitate exhaustive matching.\n *\n * @example\n * ```ts\n * const Shape = Variant({\n *    circle: Schema.struct({ radius: Schema.integer() }),\n *    rectangle: Schema.struct({ width: Schema.integer(), height: Schema.integer() })\n * })\n *\n * const demo = (input:unknown) => {\n *   const [kind, value] = Schema.match(input)\n *   switch (kind) {\n *     case \"circle\":\n *       return `Circle with radius ${shape.radius}`\n *     case \"rectangle\":\n *       return `Rectangle with width ${shape.width} and height ${shape.height}`\n *    }\n * }\n *\n * const ExhaustiveShape = Variant({\n *   circle: Schema.struct({ radius: Schema.integer() }),\n *   rectangle: Schema.struct({ width: Schema.integer(), height: Schema.integer() }),\n *  _: Schema.dictionary({ value: Schema.unknown() })\n * })\n *\n * const exhastiveDemo = (input:unknown) => {\n *   const [kind, value] = Schema.match(input)\n *   switch (kind) {\n *     case \"circle\":\n *       return `Circle with radius ${shape.radius}`\n *     case \"rectangle\":\n *       return `Rectangle with width ${shape.width} and height ${shape.height}`\n *     case: \"_\":\n *       return `Unknown shape ${JSON.stringify(value)}`\n *    }\n * }\n * ```\n *\n * @template {Schema.VariantChoices} Choices\n * @template [In=unknown]\n * @param {Choices} variants\n * @returns {Schema.VariantSchema<Choices, In>}\n */\nexport const variant = variants => new Variant(variants)\n\n/**\n * @param {string} message\n * @returns {{error: Schema.Error, ok?: undefined}}\n */\nexport const error = message => ({ error: new SchemaError(message) })\n\nclass SchemaError extends Failure {\n  get name() {\n    return 'SchemaError'\n  }\n  /* c8 ignore next 3 */\n  describe() {\n    return this.name\n  }\n}\n\nclass TypeError extends SchemaError {\n  /**\n   * @param {{expect:string, actual:unknown}} data\n   */\n  constructor({ expect, actual }) {\n    super()\n    this.expect = expect\n    this.actual = actual\n  }\n  get name() {\n    return 'TypeError'\n  }\n  describe() {\n    return `Expected value of type ${this.expect} instead got ${toString(\n      this.actual\n    )}`\n  }\n}\n\n/**\n * @param {object} data\n * @param {string} data.expect\n * @param {unknown} data.actual\n * @returns {{ error: Schema.Error }}\n */\nexport const typeError = data => ({ error: new TypeError(data) })\n\n/**\n *\n * @param {unknown} value\n */\nexport const toString = value => {\n  const type = typeof value\n  switch (type) {\n    case 'boolean':\n    case 'string':\n      return JSON.stringify(value)\n    // if these types we do not want JSON.stringify as it may mess things up\n    // eg turn NaN and Infinity to null\n    case 'bigint':\n      return `${value}n`\n    case 'number':\n    case 'symbol':\n    case 'undefined':\n      return String(value)\n    case 'object':\n      return value === null\n        ? 'null'\n        : Array.isArray(value)\n        ? 'array'\n        : Symbol.toStringTag in /** @type {object} */ (value)\n        ? value[Symbol.toStringTag]\n        : 'object'\n    default:\n      return type\n  }\n}\n\nclass LiteralError extends SchemaError {\n  /**\n   * @param {{\n   * expect:string|number|boolean|null\n   * actual:unknown\n   * }} data\n   */\n  constructor({ expect, actual }) {\n    super()\n    this.expect = expect\n    this.actual = actual\n  }\n  get name() {\n    return 'LiteralError'\n  }\n  describe() {\n    return `Expected literal ${toString(this.expect)} instead got ${toString(\n      this.actual\n    )}`\n  }\n}\n\nclass ElementError extends SchemaError {\n  /**\n   * @param {{at:number, cause:Schema.Error}} data\n   */\n  constructor({ at, cause }) {\n    super()\n    this.at = at\n    this.cause = cause\n  }\n  get name() {\n    return 'ElementError'\n  }\n  describe() {\n    return [\n      `Array contains invalid element at ${this.at}:`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\nclass FieldError extends SchemaError {\n  /**\n   * @param {{at:string, cause:Schema.Error}} data\n   */\n  constructor({ at, cause }) {\n    super()\n    this.at = at\n    this.cause = cause\n  }\n  get name() {\n    return 'FieldError'\n  }\n  describe() {\n    return [\n      `Object contains invalid field \"${this.at}\":`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\n/**\n * @param {object} options\n * @param {string|number} options.at\n * @param {Schema.Error} options.cause\n * @returns {{error: Schema.Error}}\n */\nexport const memberError = ({ at, cause }) =>\n  typeof at === 'string'\n    ? { error: new FieldError({ at, cause }) }\n    : { error: new ElementError({ at, cause }) }\n\nclass UnionError extends SchemaError {\n  /**\n   * @param {{causes: Schema.Error[]}} data\n   */\n  constructor({ causes }) {\n    super()\n    this.causes = causes\n  }\n  get name() {\n    return 'UnionError'\n  }\n  describe() {\n    const { causes } = this\n    return [\n      `Value does not match any type of the union:`,\n      ...causes.map(cause => li(cause.message)),\n    ].join('\\n')\n  }\n}\n\nclass IntersectionError extends SchemaError {\n  /**\n   * @param {{causes: Schema.Error[]}} data\n   */\n  constructor({ causes }) {\n    super()\n    this.causes = causes\n  }\n  get name() {\n    return 'IntersectionError'\n  }\n  describe() {\n    const { causes } = this\n    return [\n      `Value does not match following types of the intersection:`,\n      ...causes.map(cause => li(cause.message)),\n    ].join('\\n')\n  }\n}\n\n/**\n * @param {string} message\n */\nconst indent = (message, indent = '  ') =>\n  `${indent}${message.split('\\n').join(`\\n${indent}`)}`\n\n/**\n * @param {string} message\n */\nconst li = message => indent(`- ${message}`)\n", "import * as API from '@ucanto/interface'\nimport { create, createLegacy, isLink, parse, base32 } from '../link.js'\nimport * as Schema from './schema.js'\n\nexport { create, createLegacy, isLink, parse }\n\n/**\n * @template {number} [Code=number]\n * @template {number} [Alg=number]\n * @template {1|0} [Version=0|1]\n * @typedef {{\n * code?:Code,\n * version?:Version\n * multihash?: {code?: Alg, digest?: Uint8Array}\n * }} Settings\n */\n\n/**\n * @template {number} Code\n * @template {number} Alg\n * @template {1|0} Version\n * @extends {Schema.API<API.Link<unknown, Code, Alg, Version>, unknown, Settings<Code, Alg, Version>>}\n */\nclass LinkSchema extends Schema.API {\n  /**\n   *\n   * @param {unknown} cid\n   * @param {Settings<Code, Alg, Version>} settings\n   * @returns {Schema.ReadResult<API.Link<unknown, Code, Alg, Version>>}\n   */\n  readWith(cid, { code, multihash = {}, version }) {\n    if (cid == null) {\n      return Schema.error(`Expected link but got ${cid} instead`)\n    } else {\n      if (!isLink(cid)) {\n        return Schema.error(`Expected link to be a CID instead of ${cid}`)\n      } else {\n        if (code != null && cid.code !== code) {\n          return Schema.error(\n            `Expected link to be CID with 0x${code.toString(16)} codec`\n          )\n        }\n\n        if (multihash.code != null && cid.multihash.code !== multihash.code)\n          return Schema.error(\n            `Expected link to be CID with 0x${multihash.code.toString(\n              16\n            )} hashing algorithm`\n          )\n\n        if (version != null && cid.version !== version) {\n          return Schema.error(\n            `Expected link to be CID version ${version} instead of ${cid.version}`\n          )\n        }\n\n        const [expectDigest, actualDigest] =\n          multihash.digest != null\n            ? [\n                base32.baseEncode(multihash.digest),\n                base32.baseEncode(cid.multihash.digest),\n              ]\n            : ['', '']\n\n        if (expectDigest !== actualDigest) {\n          return Schema.error(\n            `Expected link with \"${expectDigest}\" hash digest instead of \"${actualDigest}\"`\n          )\n        }\n\n        return {\n          ok: /** @type {API.Link<unknown, any, any, any>} */ (cid),\n        }\n      }\n    }\n  }\n}\n\n/** @type {Schema.Schema<API.Link<unknown, number, number, 0|1>, unknown>}  */\nexport const schema = new LinkSchema({})\n\nexport const link = () => schema\n\n/**\n * @template {number} Code\n * @template {number} Alg\n * @template {1|0} Version\n * @param {Settings<Code, Alg, Version>} options\n * @returns {Schema.Schema<API.Link<unknown, Code, Alg, Version>>}\n */\nexport const match = (options = {}) => new LinkSchema(options)\n\n/**\n * @param {unknown} input\n */\nexport const read = input => schema.read(input)\n\nexport const optional = () => schema.optional()\n", "import * as API from '@ucanto/interface'\nimport * as Schema from './schema.js'\n\n/**\n * @template {string} Method\n * @extends {Schema.API<API.DID<Method> & API.URI<\"did:\">, string, void|Method>}\n */\nclass DIDSchema extends Schema.API {\n  /**\n   * @param {string} source\n   * @param {void|Method} method\n   */\n  readWith(source, method) {\n    const prefix = method ? `did:${method}:` : `did:`\n    if (!source.startsWith(prefix)) {\n      return Schema.error(`Expected a ${prefix} but got \"${source}\" instead`)\n    } else {\n      return { ok: /** @type {API.DID<Method>} */ (source) }\n    }\n  }\n}\n\nconst schema = Schema.string().refine(new DIDSchema())\n\nexport const did = () => schema\n/**\n *\n * @param {unknown} input\n */\nexport const read = input => schema.read(input)\n\n/**\n * @template {string} Method\n * @param {{method?: Method}} options\n */\nexport const match = (options = {}) =>\n  /** @type {Schema.Schema<API.DID<Method> & API.URI<\"did:\">>} */ (\n    Schema.string().refine(new DIDSchema(options.method))\n  )\n\n/**\n * Create a DID string from any input (or throw)\n * @param {unknown} input\n */\nexport const from = input => match({}).from(input)\n", "import * as Schema from './schema.js'\n\nconst schema = Schema.string()\n\n/**\n * @param {{pattern: RegExp}} [options]\n */\nexport const match = options =>\n  options ? schema.refine(new Match(options.pattern)) : schema\n\nexport const text = match\n\n/**\n * @param {unknown} input\n */\nexport const read = input => schema.read(input)\n\n/**\n * @extends {Schema.API<string, string, RegExp>}\n */\nclass Match extends Schema.API {\n  /**\n   * @param {string} source\n   * @param {RegExp} pattern\n   */\n  readWith(source, pattern) {\n    if (!pattern.test(source)) {\n      return Schema.error(\n        `Expected to match ${pattern} but got \"${source}\" instead`\n      )\n    } else {\n      return { ok: source }\n    }\n  }\n}\n", "import * as API from '@ucanto/interface'\nimport { delegate, Delegation, isDelegation } from './delegation.js'\nimport * as DAG from './dag.js'\n\n/**\n * Takes invocation link or a reference and returns `true` if value\n * passed is a reference, returns `false` if value is a link.\n *\n * @param {API.Invocation | API.Link} value\n * @return {value is API.Invocation}\n */\nexport const isInvocation = value => isDelegation(value)\n\n/**\n * @template {API.Capability} Capability\n * @param {API.InvocationOptions<Capability>} options\n * @return {API.IssuedInvocationView<Capability>}\n */\nexport const invoke = options => new IssuedInvocation(options)\n\n/**\n * @template {API.Capability} C\n * @param {object} dag\n * @param {API.UCANBlock<[C]>} dag.root\n * @param {DAG.BlockStore} [dag.blocks]\n * @returns {API.Invocation<C>}\n */\nexport const create = ({ root, blocks }) => new Invocation(root, blocks)\n\n/**\n * Takes a link of the `root` block and a map of blocks and constructs an\n * `Invocation` from it. If `root` is not included in the provided blocks\n * provided fallback is returned and if not provided than throws an error.\n * If root points to wrong block (that is not an invocation) it will misbehave\n * and likely throw some errors on field access.\n *\n * @template {API.Capability} C\n * @template {API.Invocation} Invocation\n * @template [T=never]\n * @param {object} dag\n * @param {API.UCANLink<[C]>} dag.root\n * @param {DAG.BlockStore} dag.blocks\n * @param {T} [fallback]\n * @returns {API.Invocation<C>|T}\n */\nexport const view = ({ root, blocks }, fallback) => {\n  const block = DAG.get(root, blocks, null)\n  if (block == null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n\n  return /** @type {API.Invocation<C>} */ (create({ root: block, blocks }))\n}\n\n/**\n * @template {API.Capability} Capability\n * @implements {API.IssuedInvocationView<Capability>}\n * @implements {API.IssuedInvocation<Capability>}\n */\nclass IssuedInvocation {\n  /**\n   * @param {API.InvocationOptions<Capability>} data\n   */\n  constructor({\n    issuer,\n    audience,\n    capability,\n    proofs = [],\n    expiration,\n    lifetimeInSeconds,\n    notBefore,\n    nonce,\n    facts = [],\n  }) {\n    /** @readonly */\n    this.issuer = issuer\n    /** @readonly */\n    this.audience = audience\n    /** @readonly */\n    this.proofs = proofs\n\n    /**\n     * @readonly\n     * @type {[Capability]}\n     */\n    this.capabilities = [capability]\n\n    this.expiration = expiration\n    this.lifetimeInSeconds = lifetimeInSeconds\n    this.notBefore = notBefore\n    this.nonce = nonce\n    this.facts = facts\n\n    /** @type {API.BlockStore<unknown>} */\n    this.attachedBlocks = new Map()\n  }\n\n  /**\n   * @param {API.Block} block\n   */\n  attach(block) {\n    this.attachedBlocks.set(`${block.cid}`, block)\n  }\n\n  delegate() {\n    return delegate(this)\n  }\n\n  buildIPLDView() {\n    return delegate(this)\n  }\n\n  /**\n   * @template {API.InvocationService<Capability>} Service\n   * @param {API.ConnectionView<Service>} connection\n   * @returns {Promise<API.InferReceipt<Capability, Service>>}\n   */\n  async execute(connection) {\n    /** @type {API.ServiceInvocation<Capability, Service>} */\n    // @ts-expect-error - Our `API.InvocationService<Capability>` constraint\n    // does not seem to be enough to convince TS that `this` is valid\n    // `ServiceInvocations<Service>`.\n    const invocation = this\n    const [result] = await connection.execute(invocation)\n    return result\n  }\n}\n\n/**\n * @template {API.Capability} Capability\n * @implements {API.Invocation<Capability>}\n * @extends {Delegation<[Capability]>}\n */\nexport class Invocation extends Delegation {}\n", "import * as API from '@ucanto/interface'\nimport * as DAG from './dag.js'\nimport { Invocation, panic } from './lib.js'\nimport * as Receipt from './receipt.js'\nimport * as Schema from './schema.js'\n\nexport const MessageSchema = Schema.variant({\n  'ucanto/message@7.0.0': Schema.struct({\n    execute: Schema.link().array().optional(),\n    delegate: Schema.dictionary({\n      key: Schema.string(),\n      value: /** @type {API.Reader<API.Link<API.ReceiptModel>>} */ (\n        Schema.link()\n      ),\n    })\n      .array()\n      .optional(),\n  }),\n})\n\n/**\n * @template {API.Tuple<API.IssuedInvocation>} I\n * @template {API.Tuple<API.Receipt>} R\n * @param {object} source\n * @param {I} [source.invocations]\n * @param {R} [source.receipts]\n * @returns {Promise<API.AgentMessage<{ In: API.InferInvocations<I>, Out: R }>>}\n */\nexport const build = ({ invocations, receipts }) =>\n  new MessageBuilder({ invocations, receipts }).buildIPLDView()\n\n/**\n * @template [E=never]\n * @param {object} source\n * @param {API.Link} source.root\n * @param {DAG.BlockStore} source.store\n * @param {E} [fallback]\n * @returns {API.AgentMessage|E}\n */\nexport const view = ({ root, store }, fallback) => {\n  const block = DAG.get(root, store, null)\n  if (block === null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n  const data = DAG.CBOR.decode(block.bytes)\n  const [branch, value] = MessageSchema.match(data, fallback)\n  switch (branch) {\n    case 'ucanto/message@7.0.0':\n      return new Message({ root: { ...block, data }, store })\n    default:\n      return value\n  }\n}\n\n/**\n * @template {API.Tuple<API.IssuedInvocation>} I\n * @template {API.Tuple<API.Receipt>} R\n * @implements {API.AgentMessageBuilder<{In: API.InferInvocations<I>, Out: R }>}\n *\n */\nclass MessageBuilder {\n  /**\n   * @param {object} source\n   * @param {I} [source.invocations]\n   * @param {R} [source.receipts]\n   */\n  constructor({ invocations, receipts }) {\n    this.invocations = invocations\n    this.receipts = receipts\n  }\n  /**\n   *\n   * @param {API.BuildOptions} [options]\n   * @returns {Promise<Message<{ In: API.InferInvocations<I>, Out: R }>>}\n   */\n  async buildIPLDView(options) {\n    const store = new Map()\n\n    const { invocations, ...executeField } = await writeInvocations(\n      this.invocations || [],\n      store\n    )\n\n    const { receipts, ...receiptsField } = await writeReceipts(\n      this.receipts || [],\n      store\n    )\n\n    const root = await DAG.writeInto(\n      /** @type {API.AgentMessageModel<{ In: API.InferInvocations<I>, Out: R }>} */\n      ({\n        'ucanto/message@7.0.0': {\n          ...executeField,\n          ...receiptsField,\n        },\n      }),\n      store,\n      options\n    )\n\n    return new Message({ root, store }, { receipts, invocations })\n  }\n}\n\n/**\n *\n * @param {API.IssuedInvocation[]} run\n * @param {Map<string, API.Block>} store\n */\nconst writeInvocations = async (run, store) => {\n  const invocations = []\n  const execute = []\n  for (const invocation of run) {\n    const view = await invocation.buildIPLDView()\n    execute.push(view.link())\n    invocations.push(view)\n    for (const block of view.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block)\n    }\n  }\n\n  return { invocations, ...(execute.length > 0 ? { execute } : {}) }\n}\n\n/**\n * @param {API.Receipt[]} source\n * @param {Map<string, API.Block>} store\n */\nconst writeReceipts = async (source, store) => {\n  if (source.length === 0) {\n    return {}\n  }\n\n  const receipts = new Map()\n  /** @type {Record<API.ToString<API.ReceiptModel['ocm']['ran']>, API.Link<API.ReceiptModel>>} */\n  const report = {}\n\n  for (const [n, receipt] of source.entries()) {\n    const view = await receipt.buildIPLDView()\n    for (const block of view.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block)\n    }\n\n    const key = `${view.ran.link()}`\n    if (!(key in report)) {\n      report[key] = view.root.cid\n      receipts.set(key, view)\n    } else {\n      // In theory we could have gotten the same invocation twice and both\n      // should get same receipt. In legacy code we send tuple of results\n      // as opposed to a map keyed by invocation to keep old clients working\n      // we just stick the receipt in the map with a unique key so that when\n      // legacy encoder maps entries to array it will get both receipts in\n      // the right order.\n      receipts.set(`${key}@${n}`, view)\n    }\n  }\n\n  return { receipts, report }\n}\n\n/**\n * @template {{ In: API.Invocation[], Out: API.Receipt[] }} T\n * @implements {API.AgentMessage<T>}\n */\nclass Message {\n  /**\n   * @param {object} source\n   * @param {Required<API.Block<API.AgentMessageModel<T>>>} source.root\n   * @param {DAG.BlockStore} source.store\n   * @param {object} build\n   * @param {API.Invocation[]} [build.invocations]\n   * @param {Map<string, API.Receipt>} [build.receipts]\n   */\n  constructor({ root, store }, { invocations, receipts } = {}) {\n    this.root = root\n    this.store = store\n    this._invocations = invocations\n    this._receipts = receipts\n  }\n  *iterateIPLDBlocks() {\n    for (const invocation of this.invocations) {\n      yield* invocation.iterateIPLDBlocks()\n    }\n\n    for (const receipt of this.receipts.values()) {\n      yield* receipt.iterateIPLDBlocks()\n    }\n\n    yield this.root\n  }\n  /**\n   * @template [E=never]\n   * @param {API.Link} link\n   * @param {E} [fallback]\n   * @returns {API.Receipt|E}\n   */\n  get(link, fallback) {\n    const receipts = this.root.data['ucanto/message@7.0.0'].report || {}\n    const receipt = receipts[`${link}`]\n    if (receipt) {\n      return Receipt.view({ root: receipt, blocks: this.store })\n    } else {\n      return fallback !== undefined\n        ? fallback\n        : panic(`Message does not include receipt for ${link}`)\n    }\n  }\n\n  get invocationLinks() {\n    return this.root.data['ucanto/message@7.0.0'].execute || []\n  }\n\n  get invocations() {\n    let invocations = this._invocations\n    if (!invocations) {\n      invocations = this.invocationLinks.map(link => {\n        return Invocation.view({ root: link, blocks: this.store })\n      })\n    }\n\n    return invocations\n  }\n\n  get receipts() {\n    let receipts = this._receipts\n    if (!receipts) {\n      receipts = new Map()\n      const report = this.root.data['ucanto/message@7.0.0'].report || {}\n      for (const [key, link] of Object.entries(report)) {\n        const receipt = Receipt.view({ root: link, blocks: this.store })\n        receipts.set(`${receipt.ran.link()}`, receipt)\n      }\n    }\n\n    return receipts\n  }\n}\n", "import * as API from '@ucanto/interface'\nimport * as DID from '@ipld/dag-ucan/did'\nimport * as Invocation from './invocation.js'\nimport * as Delegation from './delegation.js'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport * as DAG from './dag.js'\nimport * as CBOR from './cbor.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\n/**\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template [E=never]\n * @param {object} input\n * @param {API.Link<API.ReceiptModel<Ok, Error, Ran>>} input.root\n * @param {DAG.BlockStore} input.blocks\n * @param {E} [fallback]\n */\nexport const view = ({ root, blocks }, fallback) => {\n  const block = DAG.get(root, blocks, null)\n  if (block == null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n  const data = CBOR.decode(block.bytes)\n\n  return new Receipt({ root: { ...block, data }, store: blocks })\n}\n\n/**\n * Represents a UCAN invocation receipt view over some block store e.g. in\n * memory CAR. It incrementally decodes proofs, ran invocation etc. on access\n * which reduces overhead but potentially defers errors if references blocks\n * do not conform to the expected IPLD schema.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} [SigAlg=API.SigAlg]\n * @implements {API.Receipt<Ok, Error, Ran, SigAlg>}\n */\nclass Receipt {\n  /**\n   * @param {object} input\n   * @param {Required<API.Block<API.ReceiptModel<Ok, Error, Ran>>>} input.root\n   * @param {DAG.BlockStore} input.store\n   * @param {API.Meta} [input.meta]\n   * @param {Ran|ReturnType<Ran['link']>} [input.ran]\n   * @param {API.EffectsModel} [input.fx]\n   * @param {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} [input.signature]\n   * @param {API.UCAN.Principal} [input.issuer]\n   * @param {API.Proof[]} [input.proofs]\n   */\n  constructor({ root, store, ran, issuer, signature, proofs }) {\n    this.store = store\n\n    this.root = root\n    this._ran = ran\n\n    // Field is materialized on demand when `fx` getter is first accessed.\n    /** @type {API.Effects|undefined} */\n    this._fx = undefined\n    this._signature = signature\n    this._proofs = proofs\n    this._issuer = issuer\n  }\n\n  /**\n   * @returns {Ran|ReturnType<Ran['link']>}\n   */\n  get ran() {\n    const ran = this._ran\n    if (!ran) {\n      const ran = /** @type {Ran} */ (\n        Invocation.view(\n          {\n            root: this.root.data.ocm.ran,\n            blocks: this.store,\n          },\n          this.root.data.ocm.ran\n        )\n      )\n      this._ran = ran\n      return ran\n    } else {\n      return ran\n    }\n  }\n  get proofs() {\n    const proofs = this._proofs\n    if (proofs) {\n      return proofs\n    } else {\n      const { store, root } = this\n      const { prf } = root.data.ocm\n      const proofs = []\n      if (prf) {\n        for (const link of prf) {\n          const proof = Delegation.view({ root: link, blocks: store }, link)\n          proofs.push(proof)\n        }\n      }\n\n      this._proofs = proofs\n      return proofs\n    }\n  }\n  link() {\n    return this.root.cid\n  }\n  get meta() {\n    return this.root.data.ocm.meta\n  }\n  get issuer() {\n    const issuer = this._issuer\n    if (issuer) {\n      return issuer\n    } else {\n      const { iss } = this.root.data.ocm\n      if (iss) {\n        const issuer = DID.parse(iss)\n        this._issuer = issuer\n        return issuer\n      }\n    }\n  }\n\n  get out() {\n    return this.root.data.ocm.out\n  }\n\n  get fx() {\n    let fx = this._fx\n    if (!fx) {\n      const { store: blocks } = this\n      const { fork, join } = this.root.data.ocm.fx\n\n      fx = {\n        fork: fork.map(root => Invocation.view({ root, blocks }, root)),\n      }\n\n      if (join) {\n        fx.join = Invocation.view({ root: join, blocks }, join)\n      }\n\n      this._fx = fx\n    }\n    return fx\n  }\n\n  get signature() {\n    const signature = this._signature\n    if (signature) {\n      return signature\n    } else {\n      const signature =\n        /** @type {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} */ (\n          Signature.view(this.root.data.sig)\n        )\n      this._signature = signature\n      return signature\n    }\n  }\n\n  /**\n   * @param {API.Crypto.Verifier} signingPrincipal\n   */\n  verifySignature(signingPrincipal) {\n    return this.signature.verify(\n      signingPrincipal,\n      CBOR.encode(this.root.data.ocm)\n    )\n  }\n\n  buildIPLDView() {\n    return this\n  }\n\n  *iterateIPLDBlocks() {\n    const { ran, fx, proofs, root } = this\n\n    yield* DAG.iterate(ran)\n\n    for (const fork of fx.fork) {\n      yield* DAG.iterate(fork)\n    }\n\n    if (fx.join) {\n      yield* DAG.iterate(fx.join)\n    }\n\n    for (const proof of proofs) {\n      yield* DAG.iterate(proof)\n    }\n\n    yield root\n  }\n}\n\n/**\n * Represents a receipt builder that can be used to create a receipt that later\n * can be encoded into desired IPLD codec and hasher. In the future we may make\n * this an incremental builder so you could set some fields later on.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} SigAlg\n * @implements {API.IPLDViewBuilder<API.Receipt<Ok, Error, Ran, SigAlg>>}\n */\nclass ReceptBuilder {\n  /**\n   * @param {object} options\n   * @param {API.Signer<API.DID, SigAlg>} options.issuer\n   * @param {Ran|ReturnType<Ran['link']>} options.ran\n   * @param {API.Result<Ok, Error>} options.result\n   * @param {API.Effects} [options.fx]\n   * @param {API.Proof[]} [options.proofs]\n   * @param {Record<string, unknown>} [options.meta]\n   */\n  constructor({ issuer, result, ran, fx = NOFX, proofs = [], meta = {} }) {\n    this.issuer = issuer\n    this.result = result\n    this.ran = ran\n    this.fx = fx\n    this.proofs = proofs\n    this.meta = meta\n  }\n  async buildIPLDView({ hasher = sha256, codec = CBOR } = {}) {\n    const store = DAG.createStore()\n\n    // copy invocation blocks int\n    DAG.addEveryInto(DAG.iterate(this.ran), store)\n\n    // copy proof blocks into store\n    const prf = []\n    for (const proof of this.proofs) {\n      DAG.addEveryInto(DAG.iterate(proof), store)\n      prf.push(proof.link())\n    }\n\n    // copy blocks from the embedded fx\n    /** @type {{fork: API.Run[], join?:API.Run}}  */\n    const fx = { fork: [] }\n    for (const fork of this.fx.fork) {\n      DAG.addEveryInto(DAG.iterate(fork), store)\n      fx.fork.push(fork.link())\n    }\n\n    if (this.fx.join) {\n      DAG.addEveryInto(DAG.iterate(this.fx.join), store)\n      fx.join = this.fx.join.link()\n    }\n\n    /** @type {API.OutcomeModel<Ok, Error, Ran>} */\n    const outcome = {\n      ran: /** @type {ReturnType<Ran['link']>} */ (this.ran.link()),\n      out: this.result,\n      fx,\n      meta: this.meta,\n      iss: this.issuer.did(),\n      prf,\n    }\n\n    const signature = await this.issuer.sign(CBOR.encode(outcome))\n\n    /** @type {API.ReceiptModel<Ok, Error, Ran>} */\n    const model = {\n      ocm: outcome,\n      sig: signature,\n    }\n    const root = await DAG.writeInto(model, store, {\n      hasher,\n      codec,\n    })\n\n    return new Receipt({\n      root,\n      store,\n      signature,\n      proofs: this.proofs,\n      ran: this.ran,\n    })\n  }\n}\n\nconst NOFX = Object.freeze({ fork: Object.freeze([]) })\n\n/**\n * Creates a receipt in CBOR with sha256 hashed links.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} SigAlg\n * @param {object} options\n * @param {API.Signer<API.DID, SigAlg>} options.issuer\n * @param {Ran|ReturnType<Ran['link']>} options.ran\n * @param {API.Result<Ok, Error>} options.result\n * @param {API.Effects} [options.fx]\n * @param {API.Proof[]} [options.proofs]\n * @param {Record<string, unknown>} [options.meta]\n * @returns {Promise<API.Receipt<Ok, Error, Ran, SigAlg>>}\n */\nexport const issue = options => new ReceptBuilder(options).buildIPLDView()\n", "import * as API from '@ucanto/interface'\nimport { Signature, Message, Receipt, sha256 } from '@ucanto/core'\n\n/**\n * Creates a connection to a service.\n *\n * @template {Record<string, any>} T\n * @param {API.ConnectionOptions<T>} options\n * @returns {API.ConnectionView<T>}\n */\nexport const connect = options => new Connection(options)\n\n/**\n * @template {Record<string, any>} T\n * @implements {API.ConnectionView<T>}\n */\nclass Connection {\n  /**\n   * @param {API.ConnectionOptions<T>} options\n   */\n  constructor(options) {\n    this.id = options.id\n    this.options = options\n    this.codec = options.codec\n    this.channel = options.channel\n    this.hasher = options.hasher || sha256\n  }\n  /**\n   * Execute invocations.\n   *\n   * @template {API.Capability} C\n   * @template {API.Tuple<API.ServiceInvocation<C, T>>} I\n   * @param {I} invocations\n   * @returns {Promise<API.InferReceipts<I, T>>}\n   */\n  async execute(...invocations) {\n    return execute(invocations, this)\n  }\n}\n\n/**\n * @template {API.Capability} C\n * @template {Record<string, any>} T\n * @template {API.Tuple<API.ServiceInvocation<C, T>>} I\n * @param {API.Connection<T>} connection\n * @param {I} invocations\n * @returns {Promise<API.InferReceipts<I, T>>}\n */\nexport const execute = async (invocations, connection) => {\n  const input = await Message.build({ invocations })\n  const request = await connection.codec.encode(input, connection)\n  const response = await connection.channel.request(request)\n  // We may fail to decode the response if content type is not supported\n  // or if data was corrupted. We do not want to throw in such case however,\n  // because client will get an Error object as opposed to a receipt, to retain\n  // consistent client API with two kinds of errors we encode caught error as\n  // a receipts per workflow invocation.\n  try {\n    const output = await connection.codec.decode(response)\n    const receipts = input.invocationLinks.map(link => output.get(link))\n    return /** @type {API.InferReceipts<I, T>} */ (receipts)\n  } catch (error) {\n    // No third party code is run during decode and we know\n    // we only throw an Error\n    const { message, name = 'Error', ...cause } = /** @type {Error} */ (error)\n    const receipts = []\n    for await (const ran of input.invocationLinks) {\n      const receipt = await Receipt.issue({\n        ran,\n        result: { error: { ...cause, name, message } },\n        // @ts-expect-error - we can not really sign a receipt without having\n        // an access to a signer which client does not have. In the future\n        // we will change client API requiring a signer to be passed in but\n        // for now we just use a dummy signer.\n        issuer: {\n          did() {\n            return connection.id.did()\n          },\n          sign() {\n            return Signature.createNonStandard('', new Uint8Array())\n          },\n        },\n      })\n\n      receipts.push(receipt)\n    }\n\n    return /** @type {API.InferReceipts<I, T>} */ (receipts)\n  }\n}\n", "export * from './connection.js'\n\nexport * from '@ucanto/interface'\nimport { Delegation, invoke, Schema, DAG, ok, error } from '@ucanto/core'\n\nexport const delegate = Delegation.delegate\nexport { invoke, ok, error, Schema, DAG }\n", "import { CAR } from '@ucanto/core'\nimport * as request from './car/request.js'\nimport * as response from './car/response.js'\nimport * as Codec from './codec.js'\n\nexport { CAR as codec, request, response }\n\nexport const contentType = CAR.contentType\n\nexport const inbound = Codec.inbound({\n  decoders: {\n    [request.contentType]: request,\n  },\n  encoders: {\n    [response.contentType]: response,\n  },\n})\n\nexport const outbound = Codec.outbound({\n  encoders: {\n    [request.contentType]: request,\n  },\n  decoders: {\n    [response.contentType]: response,\n  },\n})\n", "import * as API from '@ucanto/interface'\nimport { CAR, Message } from '@ucanto/core'\n\nexport { CAR as codec }\n\nexport const contentType = CAR.contentType\n\nconst HEADERS = Object.freeze({\n  'content-type': contentType,\n  // We will signal that we want to receive a CAR file in the response\n  accept: contentType,\n})\n\n/**\n * Encodes `AgentMessage` into an `HTTPRequest`.\n *\n * @template {API.AgentMessage} Message\n * @param {Message} message\n * @param {API.EncodeOptions & { headers?: Record<string, string> }} [options]\n * @returns {API.HTTPRequest<Message>}\n */\nexport const encode = (message, options) => {\n  const blocks = new Map()\n  for (const block of message.iterateIPLDBlocks()) {\n    blocks.set(`${block.cid}`, block)\n  }\n\n  /**\n   * Cast to Uint8Array to remove phantom type set by the\n   * CAR encoder which is too specific.\n   *\n   * @type {Uint8Array}\n   */\n  const body = CAR.encode({\n    roots: [message.root],\n    blocks,\n  })\n\n  return {\n    headers: options?.headers || { ...HEADERS },\n    body,\n  }\n}\n\n/**\n * Decodes `AgentMessage` from the received `HTTPRequest`.\n *\n * @template {API.AgentMessage} Message\n * @param {API.HTTPRequest<Message>} request\n * @returns {Promise<Message>}\n */\nexport const decode = async ({ headers, body }) => {\n  const { roots, blocks } = CAR.decode(/** @type {Uint8Array} */ (body))\n  const message = Message.view({ root: roots[0].cid, store: blocks })\n  return /** @type {Message} */ (message)\n}\n", "import * as API from '@ucanto/interface'\nimport { CAR, Message } from '@ucanto/core'\nexport { CAR as codec }\n\nexport const contentType = CAR.contentType\n\nconst HEADERS = Object.freeze({\n  'content-type': contentType,\n})\n\n/**\n * Encodes `AgentMessage` into an `HTTPRequest`.\n *\n * @template {API.AgentMessage} Message\n * @param {Message} message\n * @param {API.EncodeOptions} [options]\n * @returns {API.HTTPResponse<Message>}\n */\nexport const encode = (message, options) => {\n  const blocks = new Map()\n  for (const block of message.iterateIPLDBlocks()) {\n    blocks.set(`${block.cid}`, block)\n  }\n\n  /**\n   * Cast to Uint8Array to remove phantom type set by the\n   * CAR encoder which is too specific.\n   *\n   * @type {Uint8Array}\n   */\n  const body = CAR.encode({\n    roots: [message.root],\n    blocks,\n  })\n\n  return {\n    headers: { ...HEADERS },\n    body,\n  }\n}\n\n/**\n * Decodes `AgentMessage` from the received `HTTPResponse`.\n *\n * @template {API.AgentMessage} Message\n * @param {API.HTTPResponse<Message>} response\n * @returns {Promise<Message>}\n */\nexport const decode = async ({ headers, body }) => {\n  const { roots, blocks } = CAR.decode(/** @type {Uint8Array} */ (body))\n  const message = Message.view({ root: roots[0].cid, store: blocks })\n  return /** @type {Message} */ (message)\n}\n", "import * as API from '@ucanto/interface'\n\n/**\n * @typedef {`${Lowercase<string>}/${Lowercase<string>}`|`${Lowercase<string>}/${Lowercase<string>}+${Lowercase<string>}`} ContentType\n * @typedef {`${Lowercase<string>}/${Lowercase<string>}`|`${Lowercase<string>}/${Lowercase<string>};q=${number}.${number}`} MediaType\n * @param {object} source\n * @param {Record<ContentType, API.Transport.RequestDecoder>} source.decoders\n * @param {Record<MediaType, API.Transport.ResponseEncoder>} source.encoders\n * @returns {API.InboundCodec}\n */\nexport const inbound = source => new Inbound(source)\n\n/**\n * @implements {API.InboundCodec}\n */\nclass Inbound {\n  /**\n   * @param {API.HTTPRequest} request\n   * @returns {API.Result<API.InboundAcceptCodec, API.HTTPError>} transport\n   */\n  accept({ headers }) {\n    const contentType = headers['content-type'] || headers['Content-Type']\n    const decoder = this.decoders[contentType]\n    if (!decoder) {\n      return {\n        error: {\n          status: 415,\n          message: `The server cannot process the request because the payload format is not supported. Please check the content-type header and try again with a supported media type.`,\n          headers: {\n            accept: Object.keys(this.decoders).join(', '),\n          },\n        },\n      }\n    }\n\n    const accept = parseAcceptHeader(headers.accept || headers.Accept || '*/*')\n    for (const { category, type } of accept) {\n      for (const encoder of this.encoders) {\n        const select =\n          (category === '*' || category === encoder.category) &&\n          (type === '*' || type === encoder.type)\n\n        if (select) {\n          return { ok: { ...encoder, decoder } }\n        }\n      }\n    }\n\n    return {\n      error: {\n        status: 406,\n        message: `The requested resource cannot be served in the requested content type. Please specify a supported content type using the Accept header.`,\n        headers: {\n          accept: formatAcceptHeader(Object.values(this.encoders)),\n        },\n      },\n    }\n  }\n\n  /**\n   * @param {object} source\n   * @param {Record<string, API.Transport.RequestDecoder>} source.decoders\n   * @param {Record<string, API.Transport.ResponseEncoder>} source.encoders\n   */\n  constructor({ decoders = {}, encoders = {} }) {\n    this.decoders = decoders\n\n    if (Object.keys(decoders).length === 0) {\n      throw new Error('At least one decoder MUST be provided')\n    }\n\n    // We sort the encoders by preference, so that we can pick the most\n    // preferred one when client accepts multiple content types.\n    this.encoders = Object.entries(encoders)\n      .map(([mediaType, encoder]) => {\n        return { ...parseMediaType(mediaType), encoder }\n      })\n      .sort((a, b) => b.preference - a.preference)\n\n    if (this.encoders.length === 0) {\n      throw new Error('At least one encoder MUST be provided')\n    }\n  }\n}\n\n/**\n * @param {object} source\n * @param {Record<MediaType, API.Transport.RequestEncoder>} source.encoders\n * @param {Record<ContentType, API.Transport.ResponseDecoder>} source.decoders\n * @returns {API.OutboundCodec}\n */\nexport const outbound = source => new Outbound(source)\n\n/**\n * @implements {API.OutboundCodec}\n */\nclass Outbound {\n  /**\n   * @param {object} source\n   * @param {Record<string, API.Transport.RequestEncoder>} source.encoders\n   * @param {Record<string, API.Transport.ResponseDecoder>} source.decoders\n   */\n  constructor({ decoders = {}, encoders = {} }) {\n    this.decoders = decoders\n\n    if (Object.keys(decoders).length === 0) {\n      throw new Error('At least one decoder MUST be provided')\n    }\n\n    // We sort the encoders by preference, so that we can pick the most\n    // preferred one when client accepts multiple content types.\n    this.encoders = Object.entries(encoders)\n      .map(([mediaType, encoder]) => {\n        return { ...parseMediaType(mediaType), encoder }\n      })\n      .sort((a, b) => b.preference - a.preference)\n\n    this.acceptType = formatAcceptHeader(this.encoders)\n\n    if (this.encoders.length === 0) {\n      throw new Error('At least one encoder MUST be provided')\n    }\n\n    this.encoder = this.encoders[0].encoder\n  }\n\n  /**\n   * @template {API.AgentMessage} Message\n   * @param {Message} message\n   */\n  encode(message) {\n    return this.encoder.encode(message, {\n      accept: this.acceptType,\n    })\n  }\n  /**\n   * @template {API.AgentMessage} Message\n   * @param {API.HTTPResponse<Message>} response\n   * @returns {API.Await<Message>}\n   */\n  decode(response) {\n    const { headers } = response\n    const contentType = headers['content-type'] || headers['Content-Type']\n    const decoder = this.decoders[contentType] || this.decoders['*/*']\n    switch (response.status) {\n      case 415:\n      case 406:\n        throw Object.assign(\n          new RangeError(new TextDecoder().decode(response.body)),\n          {\n            status: response.status,\n            headers: response.headers,\n          }\n        )\n    }\n    if (!decoder) {\n      throw Object.assign(\n        TypeError(\n          `Can not decode response with content-type '${contentType}' because no matching transport decoder is configured.`\n        ),\n        {\n          error: true,\n        }\n      )\n    }\n\n    return decoder.decode(response)\n  }\n}\n\n/**\n * @typedef {{ category: string, type: string, preference: number }} Media\n * @param {string} source\n * @returns {Media}\n */\nexport const parseMediaType = source => {\n  const [mediaType = '*/*', mediaRange = ''] = source.trim().split(';')\n  const [category = '*', type = '*'] = mediaType.split('/')\n  const params = new URLSearchParams(mediaRange)\n  const preference = parseFloat(params.get('q') || '0')\n  return {\n    category,\n    type,\n    /* c8 ignore next */\n    preference: isNaN(preference) ? 0 : preference,\n  }\n}\n\n/**\n * @param {Media} media\n */\nexport const formatMediaType = ({ category, type, preference }) =>\n  /** @type {MediaType}  */ (\n    `${category}/${type}${preference ? `;q=${preference}` : ''}`\n  )\n\n/**\n * @param {string} source\n */\nexport const parseAcceptHeader = source =>\n  source\n    .split(',')\n    .map(parseMediaType)\n    .sort((a, b) => b.preference - a.preference)\n\n/**\n * @param {Media[]} source\n */\nexport const formatAcceptHeader = source =>\n  source.map(formatMediaType).join(', ')\n", "import * as API from '@ucanto/interface'\n\n/**\n * @typedef {{\n * ok: boolean\n * arrayBuffer():API.Await<ArrayBuffer>\n * headers: {\n *  entries?: () => Iterable<[string, string]>\n * } | Headers\n * status?: number\n * statusText?: string\n * url?: string\n * }} FetchResponse\n * @typedef {(url:string, init:API.HTTPRequest) => API.Await<FetchResponse>} Fetcher\n */\n/**\n * @template S\n * @param {object} options\n * @param {URL} options.url\n * @param {(url:string, init:API.HTTPRequest) => API.Await<FetchResponse>} [options.fetch]\n * @param {string} [options.method]\n * @returns {API.Channel<S>}\n */\nexport const open = ({ url, method = 'POST', fetch }) => {\n  /* c8 ignore next 9 */\n  if (!fetch) {\n    if (typeof globalThis.fetch !== 'undefined') {\n      fetch = globalThis.fetch.bind(globalThis)\n    } else {\n      throw new TypeError(\n        `ucanto HTTP transport got undefined \\`fetch\\`. Try passing in a \\`fetch\\` implementation explicitly.`\n      )\n    }\n  }\n  return new Channel({ url, method, fetch })\n}\n\n/**\n * @template {Record<string, any>} S\n * @implements {API.Channel<S>}\n */\nclass Channel {\n  /**\n   * @param {object} options\n   * @param {URL} options.url\n   * @param {Fetcher} options.fetch\n   * @param {string} [options.method]\n   */\n  constructor({ url, fetch, method }) {\n    this.fetch = fetch\n    this.method = method\n    this.url = url\n  }\n  /**\n   * @template {API.Tuple<API.ServiceInvocation<API.Capability, S>>} I\n   * @param {API.HTTPRequest<API.AgentMessage<{ In: API.InferInvocations<I>, Out: API.Tuple<API.Receipt> }>>} request\n   * @returns {Promise<API.HTTPResponse<API.AgentMessage<{ Out: API.InferReceipts<I, S>, In: API.Tuple<API.Invocation> }>>>}\n   */\n  async request({ headers, body }) {\n    const response = await this.fetch(this.url.href, {\n      headers,\n      body,\n      method: this.method,\n    })\n\n    const buffer = response.ok\n      ? await response.arrayBuffer()\n      : HTTPError.throw(`HTTP Request failed. ${this.method} ${this.url.href} \u2192 ${response.status}`, response)\n\n    return {\n      headers: response.headers.entries\n        ? Object.fromEntries(response.headers.entries())\n        : /* c8 ignore next */\n          {},\n      body: new Uint8Array(buffer),\n    }\n  }\n}\n\n/**\n * @typedef {{\n * status?: number\n * statusText?: string\n * url?: string\n * }} Options\n */\nclass HTTPError extends Error {\n  /**\n   * @param {string} message\n   * @param {Options} options\n   * @returns {never}\n   */\n  static throw(message, options) {\n    throw new this(message, options)\n  }\n  /**\n   * @param {string} message\n   * @param {Options} options\n   */\n  constructor(message, { url, status = 500, statusText = 'Server error' }) {\n    super(message)\n    /** @type {'HTTPError'} */\n    this.name = 'HTTPError'\n    this.url = url\n    this.status = status\n    this.statusText = statusText\n  }\n}\n", "export const encoder = new TextEncoder()\nexport const decoder = new TextDecoder()\n\n/**\n * @param {string} text\n * @returns {Uint8Array}\n */\nexport const encode = text => encoder.encode(text)\n\n/**\n *\n * @param {Uint8Array} bytes\n * @returns {string}\n */\nexport const decode = bytes => decoder.decode(bytes)\n", "import * as API from '@ucanto/interface'\nimport * as CBOR from '@ucanto/core/cbor'\nexport const contentType = 'application/cbor'\n\nconst HEADERS = Object.freeze({\n  'content-type': contentType,\n})\n\n/**\n * Encodes `AgentMessage` into a legacy CBOR representation.\n *\n * @template {API.AgentMessage} Message\n * @param {Message} message\n * @param {API.EncodeOptions} [options]\n * @returns {API.HTTPResponse<Message>}\n */\nexport const encode = (message, options) => {\n  const legacyResults = []\n  for (const receipt of message.receipts.values()) {\n    const result = receipt.out\n    if (result.ok) {\n      legacyResults.push(result.ok)\n    } else {\n      legacyResults.push({\n        ...result.error,\n        error: true,\n      })\n    }\n  }\n\n  /** @type {Uint8Array} */\n  const body = CBOR.encode(legacyResults)\n\n  return /** @type {API.HTTPResponse<Message>} */ ({\n    headers: HEADERS,\n    body,\n  })\n}\n", "import * as CAR from '@ucanto/core/car'\nimport * as API from '@ucanto/interface'\nimport { Invocation, Message } from '@ucanto/core'\n\nexport const contentType = 'application/car'\n\n/**\n * @template {API.AgentMessage} Message\n * @param {API.HTTPRequest<Message>} request\n */\nexport const decode = async ({ body }) => {\n  const { roots, blocks } = CAR.decode(/** @type {Uint8Array} */ (body))\n  /** @type {API.IssuedInvocation[]} */\n  const run = []\n  for (const { cid } of roots) {\n    // We don't have a way to know if the root matches a ucan link.\n    const invocation = Invocation.view({\n      root: /** @type {API.Link} */ (cid),\n      blocks,\n    })\n    run.push(invocation)\n  }\n\n  const message = await Message.build({\n    invocations: /** @type {API.Tuple<API.IssuedInvocation>} */ (run),\n  })\n\n  return /** @type {Message} */ (message)\n}\n", "import * as Codec from './codec.js'\nimport * as CAR from './car.js'\nimport * as response from './legacy/response.js'\nimport * as request from './legacy/request.js'\n\nexport const { contentType } = request\nexport { request, response }\n\n/**\n * This is an inbound codec designed to support legacy clients and encode\n * responses in a legacy (CBOR) format.\n */\nexport const inbound = Codec.inbound({\n  decoders: {\n    [contentType]: request,\n    [CAR.contentType]: CAR.request,\n  },\n  encoders: {\n    // Here we configure encoders such that if accept header is `*/*` (which is\n    // the default if omitted) we will encode the response in CBOR. If\n    // `application/vnd.ipld.car` is set we will encode the response in current\n    // format.\n    // Here we exploit the fact that legacy clients do not send an accept header\n    // and therefore will get response in legacy format. New clients on the other\n    // hand will send `application/vnd.ipld.car` and consequently get response\n    // in current format.\n    '*/*;q=0.1': response,\n    [CAR.contentType]: CAR.response,\n  },\n})\n", "/**\n * @template {string|boolean|number|[unknown, ...unknown[]]} T\n * @param {T} value\n * @returns {T}\n */\nexport const the = value => value\n\n/**\n * @template {{}} O\n * @param {O} object\n * @returns {({ [K in keyof O]: [K, O[K]][] }[keyof O])|[[never, never]]}\n */\n\nexport const entries = object => /** @type {any} */ (Object.entries(object))\n\n/**\n * @template T\n * @param {T[][]} dataset\n * @returns {T[][]}\n */\nexport const combine = ([first, ...rest]) => {\n  const results = first.map(value => [value])\n  for (const values of rest) {\n    const tuples = results.splice(0)\n    for (const value of values) {\n      for (const tuple of tuples) {\n        results.push([...tuple, value])\n      }\n    }\n  }\n  return results\n}\n\n/**\n * @template T\n * @param {T[]} left\n * @param {T[]} right\n * @returns {T[]}\n */\nexport const intersection = (left, right) => {\n  const [result, other] =\n    left.length < right.length\n      ? [new Set(left), new Set(right)]\n      : [new Set(right), new Set(left)]\n\n  for (const item of result) {\n    if (!other.has(item)) {\n      result.delete(item)\n    }\n  }\n\n  return [...result]\n}\n", "import * as API from '@ucanto/interface'\nimport { the } from './util.js'\nimport { isLink } from '@ucanto/core/link'\nimport { fail, Failure } from '@ucanto/core/result'\n\nexport { Failure, fail }\n\nexport class EscalatedCapability extends Failure {\n  /**\n   * @param {API.ParsedCapability} claimed\n   * @param {object} delegated\n   * @param {API.Failure} cause\n   */\n  constructor(claimed, delegated, cause) {\n    super()\n    this.claimed = claimed\n    this.delegated = delegated\n    this.cause = cause\n    this.name = the('EscalatedCapability')\n  }\n  describe() {\n    return `Constraint violation: ${this.cause.message}`\n  }\n}\n\n/**\n * @implements {API.DelegationError}\n */\nexport class DelegationError extends Failure {\n  /**\n   * @param {(API.InvalidCapability | API.EscalatedDelegation | API.DelegationError)[]} causes\n   * @param {object} context\n   */\n  constructor(causes, context) {\n    super()\n    this.name = the('InvalidClaim')\n    this.causes = causes\n    this.context = context\n  }\n  describe() {\n    return [\n      `Can not derive ${this.context} from delegated capabilities:`,\n      ...this.causes.map(cause => li(cause.message)),\n    ].join('\\n')\n  }\n\n  /**\n   * @type {API.InvalidCapability | API.EscalatedDelegation | API.DelegationError}\n   */\n  get cause() {\n    /* c8 ignore next 9 */\n    if (this.causes.length !== 1) {\n      return this\n    } else {\n      const [cause] = this.causes\n      const value = cause.name === 'InvalidClaim' ? cause.cause : cause\n      Object.defineProperties(this, { cause: { value } })\n      return value\n    }\n  }\n}\n\n/**\n * @implements {API.SessionEscalation}\n */\nexport class SessionEscalation extends Failure {\n  /**\n   * @param {object} source\n   * @param {API.Delegation} source.delegation\n   * @param {API.Failure} source.cause\n   */\n  constructor({ delegation, cause }) {\n    super()\n    this.name = the('SessionEscalation')\n    this.delegation = delegation\n    this.cause = cause\n  }\n  describe() {\n    const issuer = this.delegation.issuer.did()\n    return [\n      `Delegation ${this.delegation.cid} issued by ${issuer} has an invalid session`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\n/**\n * @implements {API.InvalidSignature}\n */\nexport class InvalidSignature extends Failure {\n  /**\n   * @param {API.Delegation} delegation\n   * @param {API.Verifier} verifier\n   */\n  constructor(delegation, verifier) {\n    super()\n    this.name = the('InvalidSignature')\n    this.delegation = delegation\n    this.verifier = verifier\n  }\n  get issuer() {\n    return this.delegation.issuer\n  }\n  get audience() {\n    return this.delegation.audience\n  }\n  get key() {\n    return this.verifier.toDIDKey()\n  }\n  describe() {\n    const issuer = this.issuer.did()\n    const key = this.key\n    return (\n      issuer.startsWith('did:key')\n        ? [\n            `Proof ${this.delegation.cid} does not has a valid signature from ${key}`,\n          ]\n        : [\n            `Proof ${this.delegation.cid} issued by ${issuer} does not has a valid signature from ${key}`,\n            `  \u2139\uFE0F Probably issuer signed with a different key, which got rotated, invalidating delegations that were issued with prior keys`,\n          ]\n    ).join('\\n')\n  }\n}\n\n/**\n * @implements {API.UnavailableProof}\n */\nexport class UnavailableProof extends Failure {\n  /**\n   * @param {API.UCAN.Link} link\n   * @param {Error} [cause]\n   */\n  constructor(link, cause) {\n    super()\n    this.name = the('UnavailableProof')\n    this.link = link\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Linked proof '${this.link}' is not included and could not be resolved`,\n      ...(this.cause\n        ? [li(`Proof resolution failed with: ${this.cause.message}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\nexport class DIDKeyResolutionError extends Failure {\n  /**\n   * @param {API.UCAN.DID} did\n   * @param {API.Failure} [cause]\n   */\n  constructor(did, cause) {\n    super()\n    this.name = the('DIDKeyResolutionError')\n    this.did = did\n    this.cause = cause\n  }\n  describe() {\n    return `Unable to resolve '${this.did}' key`\n  }\n}\n\n/**\n * @implements {API.InvalidAudience}\n */\nexport class PrincipalAlignmentError extends Failure {\n  /**\n   * @param {API.UCAN.Principal} audience\n   * @param {API.Delegation} delegation\n   */\n  constructor(audience, delegation) {\n    super()\n    this.name = the('InvalidAudience')\n    this.audience = audience\n    this.delegation = delegation\n  }\n  describe() {\n    return `Delegation audience is '${this.delegation.audience.did()}' instead of '${this.audience.did()}'`\n  }\n  toJSON() {\n    const { name, audience, message, stack } = this\n    return {\n      name,\n      audience: audience.did(),\n      delegation: { audience: this.delegation.audience.did() },\n      message,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.MalformedCapability}\n */\nexport class MalformedCapability extends Failure {\n  /**\n   * @param {API.Capability} capability\n   * @param {API.Failure} cause\n   */\n  constructor(capability, cause) {\n    super()\n    this.name = the('MalformedCapability')\n    this.capability = capability\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Encountered malformed '${this.capability.can}' capability: ${format(\n        this.capability\n      )}`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\nexport class UnknownCapability extends Failure {\n  /**\n   * @param {API.Capability} capability\n   */\n  constructor(capability) {\n    super()\n    this.name = the('UnknownCapability')\n    this.capability = capability\n  }\n  /* c8 ignore next 3 */\n  describe() {\n    return `Encountered unknown capability: ${format(this.capability)}`\n  }\n}\n\nexport class Expired extends Failure {\n  /**\n   * @param {API.Delegation & { expiration: number }} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('Expired')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} has expired on ${new Date(\n      this.delegation.expiration * 1000\n    )}`\n  }\n  get expiredAt() {\n    return this.delegation.expiration\n  }\n  toJSON() {\n    const { name, expiredAt, message, stack } = this\n    return {\n      name,\n      message,\n      expiredAt,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.Revoked}\n */\nexport class Revoked extends Failure {\n  /**\n   * @param {API.Delegation} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('Revoked')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} has been revoked`\n  }\n  toJSON() {\n    const { name, message, stack } = this\n    return {\n      name,\n      message,\n      stack,\n    }\n  }\n}\n\nexport class NotValidBefore extends Failure {\n  /**\n   * @param {API.Delegation & { notBefore: number }} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('NotValidBefore')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} is not valid before ${new Date(\n      this.delegation.notBefore * 1000\n    )}`\n  }\n  get validAt() {\n    return this.delegation.notBefore\n  }\n  toJSON() {\n    const { name, validAt, message, stack } = this\n    return {\n      name,\n      message,\n      validAt,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.Unauthorized}\n */\n\nexport class Unauthorized extends Failure {\n  /**\n   * @param {{\n   * capability: API.CapabilityParser\n   * delegationErrors: API.DelegationError[]\n   * unknownCapabilities: API.Capability[]\n   * invalidProofs: API.InvalidProof[]\n   * failedProofs: API.InvalidClaim[]\n   * }} cause\n   */\n  constructor({\n    capability,\n    delegationErrors,\n    unknownCapabilities,\n    invalidProofs,\n    failedProofs,\n  }) {\n    super()\n    /** @type {\"Unauthorized\"} */\n    this.name = 'Unauthorized'\n    this.capability = capability\n    this.delegationErrors = delegationErrors\n    this.unknownCapabilities = unknownCapabilities\n    this.invalidProofs = invalidProofs\n    this.failedProofs = failedProofs\n  }\n\n  describe() {\n    const errors = [\n      ...this.failedProofs.map(error => li(error.message)),\n      ...this.delegationErrors.map(error => li(error.message)),\n      ...this.invalidProofs.map(error => li(error.message)),\n    ]\n\n    const unknown = this.unknownCapabilities.map(c => li(JSON.stringify(c)))\n\n    return [\n      `Claim ${this.capability} is not authorized`,\n      ...(errors.length > 0\n        ? errors\n        : [li(`No matching delegated capability found`)]),\n      ...(unknown.length > 0\n        ? [li(`Encountered unknown capabilities\\n${unknown.join('\\n')}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\n/**\n * @param {unknown} capability\n * @param {string|number} [space]\n */\n\nconst format = (capability, space) =>\n  JSON.stringify(\n    capability,\n    (_key, value) => {\n      /* c8 ignore next 2 */\n      if (isLink(value)) {\n        return value.toString()\n      } else {\n        return value\n      }\n    },\n    space\n  )\n\n/**\n * @param {string} message\n */\nexport const indent = (message, indent = '  ') =>\n  `${indent}${message.split('\\n').join(`\\n${indent}`)}`\n\n/**\n * @param {string} message\n */\nexport const li = message => indent(`- ${message}`)\n", "import * as API from '@ucanto/interface'\nimport { entries, combine, intersection } from './util.js'\nimport {\n  EscalatedCapability,\n  MalformedCapability,\n  UnknownCapability,\n  DelegationError as MatchError,\n} from './error.js'\nimport { invoke, delegate, Schema } from '@ucanto/core'\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @typedef {{\n * can: A\n * with: API.Reader<R, API.Resource, API.Failure>\n * nb?: Schema.MapRepresentation<C, unknown>\n * derives?: (claim: {can:A, with: R, nb: C}, proof:{can:A, with:R, nb:C}) => API.Result<{}, API.Failure>\n * }} Descriptor\n */\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} [C={}]\n * @param {Descriptor<A, R, C>} descriptor\n \n * @returns {API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>}\n */\nexport const capability = ({\n  derives = defaultDerives,\n  nb = defaultNBSchema,\n  ...etc\n}) => new Capability({ derives, nb, ...etc })\n\nconst defaultNBSchema =\n  /** @type {Schema.MapRepresentation<any>} */\n  (Schema.struct({}))\n\n/**\n * @template {API.Match} M\n * @template {API.Match} W\n * @param {API.Matcher<M>} left\n * @param {API.Matcher<W>} right\n * @returns {API.CapabilityParser<M|W>}\n */\nexport const or = (left, right) => new Or(left, right)\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @param {Selectors} selectors\n * @returns {API.CapabilitiesParser<API.InferMembers<Selectors>>}\n */\nexport const and = (...selectors) => new And(selectors)\n\n/**\n * @template {API.Match} M\n * @template {API.ParsedCapability} T\n * @param {object} source\n * @param {API.MatchSelector<M>} source.from\n * @param {API.TheCapabilityParser<API.DirectMatch<T>>} source.to\n * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} source.derives\n \n * @returns {API.TheCapabilityParser<API.DerivedMatch<T, M>>}\n */\nexport const derive = ({ from, to, derives }) => new Derive(from, to, derives)\n\n/**\n * @template {API.Match} M\n * @implements {API.View<M>}\n */\nclass View {\n  /**\n   * @param {API.Source} source\n   * @returns {API.MatchResult<M>}\n   */\n  /* c8 ignore next 3 */\n  match(source) {\n    return { error: new UnknownCapability(source.capability) }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   * @returns {API.Select<M>}\n   */\n  select(capabilities) {\n    return select(this, capabilities)\n  }\n\n  /**\n   * @template {API.ParsedCapability} U\n   * @param {object} source\n   * @param {API.TheCapabilityParser<API.DirectMatch<U>>} source.to\n   * @param {API.Derives<U, API.InferDeriveProof<M['value']>>} source.derives\n   * @returns {API.TheCapabilityParser<API.DerivedMatch<U, M>>}\n   */\n  derive({ derives, to }) {\n    return derive({ derives, to, from: this })\n  }\n}\n\n/**\n * @template {API.Match} M\n * @implements {API.CapabilityParser<M>}\n * @extends {View<M>}\n */\nclass Unit extends View {\n  /**\n   * @template {API.Match} W\n   * @param {API.MatchSelector<W>} other\n   * @returns {API.CapabilityParser<M | W>}\n   */\n  or(other) {\n    return or(this, other)\n  }\n\n  /**\n   * @template {API.Match} W\n   * @param {API.CapabilityParser<W>} other\n   * @returns {API.CapabilitiesParser<[M, W]>}\n   */\n  and(other) {\n    return and(/** @type {API.CapabilityParser<M>} */ (this), other)\n  }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @implements {API.TheCapabilityParser<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n * @extends {Unit<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n */\nclass Capability extends Unit {\n  /**\n   * @param {Required<Descriptor<A, R, C>>} descriptor\n   */\n  constructor(descriptor) {\n    super()\n    this.descriptor = descriptor\n    this.schema = Schema.struct({\n      can: Schema.literal(descriptor.can),\n      with: descriptor.with,\n      nb: descriptor.nb,\n    })\n  }\n\n  /**\n   * @param {API.InferCreateOptions<R, C>} options\n   */\n  create(options) {\n    const { descriptor, can } = this\n    const decoders = descriptor.nb\n    const data = /** @type {C} */ (options.nb || {})\n\n    const resource = descriptor.with.read(options.with)\n    if (resource.error) {\n      throw Object.assign(\n        new Error(`Invalid 'with' - ${resource.error.message}`),\n        {\n          cause: resource,\n        }\n      )\n    }\n\n    const nb = descriptor.nb.read(data)\n    if (nb.error) {\n      throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {\n        cause: nb,\n      })\n    }\n\n    return createCapability({ can, with: resource.ok, nb: nb.ok })\n  }\n\n  /**\n   * @param {API.InferInvokeOptions<R, C>} options\n   */\n  invoke({ with: with_, nb, ...options }) {\n    return invoke({\n      ...options,\n      capability: this.create(\n        /** @type {API.InferCreateOptions<R, C>} */\n        ({ with: with_, nb })\n      ),\n    })\n  }\n\n  /**\n   * @param {API.InferDelegationOptions<R, C>} options\n   * @returns {Promise<API.Delegation<[API.InferDelegatedCapability<API.ParsedCapability<A, R, C>>]>>}\n   */\n  async delegate({ nb: input = {}, with: with_, ...options }) {\n    const { descriptor, can } = this\n    const readers = descriptor.nb\n\n    const resource = descriptor.with.read(with_)\n    if (resource.error) {\n      throw Object.assign(\n        new Error(`Invalid 'with' - ${resource.error.message}`),\n        {\n          cause: resource,\n        }\n      )\n    }\n\n    const nb = descriptor.nb.partial().read(input)\n    if (nb.error) {\n      throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {\n        cause: nb,\n      })\n    }\n\n    return delegate({\n      capabilities: [createCapability({ can, with: resource.ok, nb: nb.ok })],\n      ...options,\n    })\n  }\n\n  get can() {\n    return this.descriptor.can\n  }\n\n  /**\n   * @param {API.Source} source\n   * @returns {API.MatchResult<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n   */\n  match(source) {\n    const result = parseCapability(this.descriptor, source)\n    return result.error\n      ? result\n      : { ok: new Match(source, result.ok, this.descriptor) }\n  }\n  toString() {\n    return JSON.stringify({ can: this.descriptor.can })\n  }\n}\n\n/**\n * Normalizes capability by removing empty nb field.\n *\n * @template {API.ParsedCapability} T\n * @param {T} source\n */\n\nconst createCapability = ({ can, with: with_, nb }) =>\n  /** @type {API.InferCapability<T>} */ ({\n    can,\n    with: with_,\n    ...(isEmpty(nb) ? {} : { nb }),\n  })\n\n/**\n * @param {object} object\n * @returns {object is {}}\n */\nconst isEmpty = object => {\n  for (const _ in object) {\n    return false\n  }\n  return true\n}\n\n/**\n * @template {API.Match} M\n * @template {API.Match} W\n * @implements {API.CapabilityParser<M|W>}\n * @extends {Unit<M|W>}\n */\nclass Or extends Unit {\n  /**\n   * @param {API.Matcher<M>} left\n   * @param {API.Matcher<W>} right\n   */\n  constructor(left, right) {\n    super()\n    this.left = left\n    this.right = right\n  }\n\n  /**\n   * @param {API.Source} capability\n   * @return {API.MatchResult<M|W>}\n   */\n  match(capability) {\n    const left = this.left.match(capability)\n    if (left.error) {\n      const right = this.right.match(capability)\n      if (right.error) {\n        return right.error.name === 'MalformedCapability'\n          ? //\n            right\n          : //\n            left\n      } else {\n        return right\n      }\n    } else {\n      return left\n    }\n  }\n\n  toString() {\n    return `${this.left.toString()}|${this.right.toString()}`\n  }\n}\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @implements {API.CapabilitiesParser<API.InferMembers<Selectors>>}\n * @extends {View<API.Amplify<API.InferMembers<Selectors>>>}\n */\nclass And extends View {\n  /**\n   * @param {Selectors} selectors\n   */\n  constructor(selectors) {\n    super()\n    this.selectors = selectors\n  }\n  /**\n   * @param {API.Source} capability\n   * @returns {API.MatchResult<API.Amplify<API.InferMembers<Selectors>>>}\n   */\n  match(capability) {\n    const group = []\n    for (const selector of this.selectors) {\n      const result = selector.match(capability)\n      if (result.error) {\n        return result\n      } else {\n        group.push(result.ok)\n      }\n    }\n\n    return {\n      ok: new AndMatch(/** @type {API.InferMembers<Selectors>} */ (group)),\n    }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    return selectGroup(this, capabilities)\n  }\n  /**\n   * @template E\n   * @template {API.Match} X\n   * @param {API.MatchSelector<API.Match<E, X>>} other\n   * @returns {API.CapabilitiesParser<[...API.InferMembers<Selectors>, API.Match<E, X>]>}\n   */\n  and(other) {\n    return new And([...this.selectors, other])\n  }\n  toString() {\n    return `[${this.selectors.map(String).join(', ')}]`\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.Match} M\n * @implements {API.TheCapabilityParser<API.DerivedMatch<T, M>>}\n * @extends {Unit<API.DerivedMatch<T, M>>}\n */\n\nclass Derive extends Unit {\n  /**\n   * @param {API.MatchSelector<M>} from\n   * @param {API.TheCapabilityParser<API.DirectMatch<T>>} to\n   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives\n   */\n  constructor(from, to, derives) {\n    super()\n    this.from = from\n    this.to = to\n    this.derives = derives\n  }\n\n  /**\n   * @type {typeof this.to['create']}\n   */\n  create(options) {\n    return this.to.create(options)\n  }\n  /**\n   * @type {typeof this.to['invoke']}\n   */\n  invoke(options) {\n    return this.to.invoke(options)\n  }\n  /**\n   * @type {typeof this.to['delegate']}\n   */\n  delegate(options) {\n    return this.to.delegate(options)\n  }\n  get can() {\n    return this.to.can\n  }\n  /**\n   * @param {API.Source} capability\n   * @returns {API.MatchResult<API.DerivedMatch<T, M>>}\n   */\n  match(capability) {\n    const match = this.to.match(capability)\n    if (match.error) {\n      return match\n    } else {\n      return { ok: new DerivedMatch(match.ok, this.from, this.derives) }\n    }\n  }\n  toString() {\n    return this.to.toString()\n  }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @implements {API.DirectMatch<API.ParsedCapability<A, R, C>>}\n */\nclass Match {\n  /**\n   * @param {API.Source} source\n   * @param {API.ParsedCapability<A, R, C>} value\n   * @param {Required<Descriptor<A, R, C>>} descriptor\n   */\n  constructor(source, value, descriptor) {\n    this.source = [source]\n    this.value = value\n    this.descriptor = descriptor\n  }\n  get can() {\n    return this.value.can\n  }\n\n  get proofs() {\n    const proofs = [this.source[0].delegation]\n    Object.defineProperties(this, {\n      proofs: { value: proofs },\n    })\n    return proofs\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   * @returns {API.DirectMatch<API.ParsedCapability<A, R, C>>|null}\n   */\n  prune(context) {\n    if (context.canIssue(this.value, this.source[0].delegation.issuer.did())) {\n      return null\n    } else {\n      return this\n    }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   * @returns {API.Select<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n   */\n  select(capabilities) {\n    const unknown = []\n    const errors = []\n    const matches = []\n    for (const capability of capabilities) {\n      const result = resolveCapability(this.descriptor, this.value, capability)\n      if (result.ok) {\n        const claim = this.descriptor.derives(this.value, result.ok)\n        if (claim.error) {\n          errors.push(\n            new MatchError(\n              [new EscalatedCapability(this.value, result.ok, claim.error)],\n              this\n            )\n          )\n        } else {\n          matches.push(new Match(capability, result.ok, this.descriptor))\n        }\n      } else {\n        switch (result.error.name) {\n          case 'UnknownCapability':\n            unknown.push(result.error.capability)\n            break\n          case 'MalformedCapability':\n          default:\n            errors.push(new MatchError([result.error], this))\n        }\n      }\n    }\n\n    return { matches, unknown, errors }\n  }\n  toString() {\n    const { nb } = this.value\n    return JSON.stringify({\n      can: this.descriptor.can,\n      with: this.value.with,\n      nb: nb && Object.keys(nb).length > 0 ? nb : undefined,\n    })\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.Match} M\n * @implements {API.DerivedMatch<T, M>}\n */\n\nclass DerivedMatch {\n  /**\n   * @param {API.DirectMatch<T>} selected\n   * @param {API.MatchSelector<M>} from\n   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives\n   */\n  constructor(selected, from, derives) {\n    this.selected = selected\n    this.from = from\n    this.derives = derives\n  }\n  get can() {\n    return this.value.can\n  }\n  get source() {\n    return this.selected.source\n  }\n  get proofs() {\n    const proofs = []\n    for (const { delegation } of this.selected.source) {\n      proofs.push(delegation)\n    }\n    Object.defineProperties(this, { proofs: { value: proofs } })\n    return proofs\n  }\n  get value() {\n    return this.selected.value\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   */\n  prune(context) {\n    const selected =\n      /** @type {API.DirectMatch<T>|null} */\n      (this.selected.prune(context))\n    return selected ? new DerivedMatch(selected, this.from, this.derives) : null\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    const { derives, selected, from } = this\n    const { value } = selected\n\n    const direct = selected.select(capabilities)\n\n    const derived = from.select(capabilities)\n    const matches = []\n    const errors = []\n    for (const match of derived.matches) {\n      // If capability can not be derived it escalates\n      const result = derives(value, match.value)\n      if (result.error) {\n        errors.push(\n          new MatchError(\n            [new EscalatedCapability(value, match.value, result.error)],\n            this\n          )\n        )\n      } else {\n        matches.push(match)\n      }\n    }\n\n    return {\n      unknown: intersection(direct.unknown, derived.unknown),\n      errors: [\n        ...errors,\n        ...direct.errors,\n        ...derived.errors.map(error => new MatchError([error], this)),\n      ],\n      matches: [\n        ...direct.matches.map(match => new DerivedMatch(match, from, derives)),\n        ...matches,\n      ],\n    }\n  }\n\n  toString() {\n    return this.selected.toString()\n  }\n}\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @implements {API.Amplify<API.InferMembers<Selectors>>}\n */\nclass AndMatch {\n  /**\n   * @param {API.Match[]} matches\n   */\n  constructor(matches) {\n    this.matches = matches\n  }\n  get selectors() {\n    return this.matches\n  }\n  /**\n   * @returns {API.Source[]}\n   */\n  get source() {\n    const source = []\n\n    for (const match of this.matches) {\n      source.push(...match.source)\n    }\n    Object.defineProperties(this, { source: { value: source } })\n    return source\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   */\n  prune(context) {\n    const matches = []\n    for (const match of this.matches) {\n      const pruned = match.prune(context)\n      if (pruned) {\n        matches.push(pruned)\n      }\n    }\n    return matches.length === 0 ? null : new AndMatch(matches)\n  }\n\n  get proofs() {\n    const proofs = []\n\n    for (const { delegation } of this.source) {\n      proofs.push(delegation)\n    }\n\n    Object.defineProperties(this, { proofs: { value: proofs } })\n    return proofs\n  }\n  /**\n   * @type {API.InferValue<API.InferMembers<Selectors>>}\n   */\n  get value() {\n    const value = []\n\n    for (const match of this.matches) {\n      value.push(match.value)\n    }\n    Object.defineProperties(this, { value: { value } })\n    return /** @type {any} */ (value)\n  }\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    return selectGroup(this, capabilities)\n  }\n  toString() {\n    return `[${this.matches.map(match => match.toString()).join(', ')}]`\n  }\n}\n\n/**\n * Resolves ability `pattern` of the delegated capability from the ability\n * of the claimed capability. If pattern matches returns claimed ability\n * otherwise returns given `fallback`.\n *\n * @example\n * ```js\n * resolveAbility('*', 'store/add', null) // => 'store/add'\n * resolveAbility('store/*', 'store/add', null) // => 'store/add'\n * resolveAbility('store/add', 'store/add', null) // => 'store/add'\n * resolveAbility('store/', 'store/add', null) // => null\n * resolveAbility('store/a*', 'store/add', null) // => null\n * resolveAbility('store/list', 'store/add', null) // => null\n * ```\n *\n * @template {API.Ability} T\n * @template U\n * @param {string} pattern\n * @param {T} can\n * @param {U} fallback\n * @returns {T|U}\n */\nconst resolveAbility = (pattern, can, fallback) => {\n  switch (pattern) {\n    case can:\n    case '*':\n      return can\n    default:\n      return pattern.endsWith('/*') && can.startsWith(pattern.slice(0, -1))\n        ? can\n        : fallback\n  }\n}\n\n/**\n * Resolves `source` resource of the delegated capability from the resource\n * `uri` of the claimed capability. If `source` is `\"ucan:*\"\"` or matches `uri`\n * then it returns `uri` back otherwise it returns `fallback`.\n *\n * @example\n * ```js\n * resolveResource('ucan:*', 'did:key:zAlice', null) // => 'did:key:zAlice'\n * resolveAbility('ucan:*', 'https://example.com', null) // => 'https://example.com'\n * resolveAbility('did:*', 'did:key:zAlice', null) // => null\n * resolveAbility('did:key:zAlice', 'did:key:zAlice', null) // => did:key:zAlice\n * ```\n * @template {string} T\n * @template U\n * @param {T} uri\n * @param {string} source\n * @param {U} fallback\n * @returns {T|U}\n */\nconst resolveResource = (source, uri, fallback) => {\n  switch (source) {\n    case uri:\n    case 'ucan:*':\n      return uri\n    default:\n      return fallback\n  }\n}\n\n/**\n * Parses capability from the `source` using a provided `parser`.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {Required<Descriptor<A, R, C>>} descriptor\n * @param {API.Source} source\n * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}\n */\nconst parseCapability = (descriptor, source) => {\n  const { delegation } = source\n  const capability = /** @type {API.Capability<A, R, C>} */ (source.capability)\n\n  if (descriptor.can !== capability.can) {\n    return { error: new UnknownCapability(capability) }\n  }\n\n  const uri = descriptor.with.read(capability.with)\n  if (uri.error) {\n    return { error: new MalformedCapability(capability, uri.error) }\n  }\n\n  const nb = descriptor.nb.read(capability.nb || {})\n  if (nb.error) {\n    return { error: new MalformedCapability(capability, nb.error) }\n  }\n\n  return { ok: new CapabilityView(descriptor.can, uri.ok, nb.ok, delegation) }\n}\n\n/**\n * Resolves delegated capability `source` from the `claimed` capability using\n * provided capability `parser`. It is similar to `parseCapability` except\n * `source` here is treated as capability pattern which is matched against the\n * `claimed` capability. This means we resolve `can` and `with` fields from the\n * `claimed` capability and inherit all missing `nb` fields from the claimed\n * capability.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {Required<Descriptor<A, R, C>>} descriptor\n * @param {API.ParsedCapability<A, R, C>} claimed\n * @param {API.Source} source\n * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}\n */\n\nconst resolveCapability = (descriptor, claimed, { capability, delegation }) => {\n  const can = resolveAbility(capability.can, claimed.can, null)\n  if (can == null) {\n    return { error: new UnknownCapability(capability) }\n  }\n\n  const resource = resolveResource(\n    capability.with,\n    claimed.with,\n    capability.with\n  )\n  const uri = descriptor.with.read(resource)\n  if (uri.error) {\n    return { error: new MalformedCapability(capability, uri.error) }\n  }\n\n  const nb = descriptor.nb.read({\n    ...claimed.nb,\n    ...capability.nb,\n  })\n\n  if (nb.error) {\n    return { error: new MalformedCapability(capability, nb.error) }\n  }\n\n  return { ok: new CapabilityView(can, uri.ok, nb.ok, delegation) }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template C\n */\nclass CapabilityView {\n  /**\n   * @param {A} can\n   * @param {R} with_\n   * @param {C} nb\n   * @param {API.Delegation} delegation\n   */\n  constructor(can, with_, nb, delegation) {\n    this.can = can\n    this.with = with_\n    this.delegation = delegation\n    this.nb = nb\n  }\n}\n\n/**\n * @template {API.Match} M\n * @param {API.Matcher<M>} matcher\n * @param {API.Source[]} capabilities\n * @returns {API.Select<M>}\n */\n\nconst select = (matcher, capabilities) => {\n  const unknown = []\n  const matches = []\n  const errors = []\n  for (const capability of capabilities) {\n    const result = matcher.match(capability)\n    if (result.error) {\n      switch (result.error.name) {\n        case 'UnknownCapability':\n          unknown.push(result.error.capability)\n          break\n        case 'MalformedCapability':\n        default:\n          errors.push(new MatchError([result.error], result.error.capability))\n      }\n    } else {\n      matches.push(result.ok)\n    }\n  }\n\n  return { matches, errors, unknown }\n}\n\n/**\n * @template {API.Selector<API.Match>[]} S\n * @param {{selectors:S}} self\n * @param {API.Source[]} capabilities\n */\n\nconst selectGroup = (self, capabilities) => {\n  let unknown\n  const data = []\n  const errors = []\n  for (const selector of self.selectors) {\n    const selected = selector.select(capabilities)\n    unknown = unknown\n      ? intersection(unknown, selected.unknown)\n      : selected.unknown\n\n    for (const error of selected.errors) {\n      errors.push(new MatchError([error], self))\n    }\n\n    data.push(selected.matches)\n  }\n\n  const matches = combine(data).map(group => new AndMatch(group))\n\n  return {\n    unknown:\n      /* c8 ignore next */\n      unknown || [],\n    errors,\n    matches,\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.ParsedCapability} U\n * @param {T} claimed\n * @param {U} delegated\n * @return {API.Result<true, API.Failure>}\n */\nconst defaultDerives = (claimed, delegated) => {\n  if (delegated.with.endsWith('*')) {\n    if (!claimed.with.startsWith(delegated.with.slice(0, -1))) {\n      return Schema.error(\n        `Resource ${claimed.with} does not match delegated ${delegated.with} `\n      )\n    }\n  } else if (delegated.with !== claimed.with) {\n    return Schema.error(\n      `Resource ${claimed.with} is not contained by ${delegated.with}`\n    )\n  }\n\n  /* c8 ignore next 2 */\n  const caveats = delegated.nb || {}\n  const nb = claimed.nb || {}\n  const kv = entries(caveats)\n\n  for (const [name, value] of kv) {\n    if (nb[name] != value) {\n      return Schema.error(`${String(name)}: ${nb[name]} violates ${value}`)\n    }\n  }\n\n  return { ok: true }\n}\n", "import { Schema } from '@ucanto/validator'\n\n/**\n * @see https://github.com/filecoin-project/FIPs/pull/758/files\n */\nconst FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE = /** @type {const} */ (0x1011)\n/**\n * @see https://github.com/filecoin-project/FIPs/pull/758/files\n */\nconst RAW_CODE = /** @type {const} */ (0x55)\n\nexport const PieceLink = /** @type {import('../types.js').PieceLinkSchema} */ (\n  Schema.link({\n    code: RAW_CODE,\n    version: 1,\n    multihash: {\n      code: FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE,\n    },\n  })\n)\n", "/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals (a: Uint8Array, b: Uint8Array): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n", "import { DID, Schema, fail, ok } from '@ucanto/validator'\n// eslint-disable-next-line no-unused-vars\nimport * as Types from '@ucanto/interface'\n\nimport { equals } from 'uint8arrays/equals'\n\n// e.g. did:web:web3.storage or did:web:staging.web3.storage\nexport const ProviderDID = DID.match({ method: 'web' })\n\nexport const SpaceDID = DID.match({ method: 'key' })\n\nexport const AccountDID = DID.match({ method: 'mailto' })\n\nexport const Await = Schema.struct({\n  'ucan/await': Schema.tuple([Schema.string(), Schema.link()]),\n})\n\n/**\n * Check URI can be delegated.\n *\n * @param {string} [child]\n * @param {string} [parent]\n */\nexport function canDelegateURI(child, parent) {\n  if (parent === undefined) {\n    return ok({})\n  }\n  if (child !== undefined && parent.endsWith('*')) {\n    return child.startsWith(parent.slice(0, -1))\n      ? ok({})\n      : fail(`${child} does not match ${parent}`)\n  }\n\n  return child === parent\n    ? ok({})\n    : fail(`${child} is different from ${parent}`)\n}\n\n/**\n * Checks that `with` on claimed capability is the same as `with`\n * in delegated capability. Note this will ignore `can` field.\n *\n * @param {Types.ParsedCapability} child\n * @param {Types.ParsedCapability} parent\n */\nexport function equalWith(child, parent) {\n  return child.with === parent.with\n    ? ok({})\n    : fail(`Can not derive ${child.can} with ${child.with} from ${parent.with}`)\n}\n\n/**\n * @param {unknown} child\n * @param {unknown} parent\n * @param {string} constraint\n */\nexport function equal(child, parent, constraint) {\n  if (parent === undefined || parent === '*') {\n    return ok({})\n  } else if (String(child) === String(parent)) {\n    return ok({})\n  } else {\n    return fail(\n      `Constrain violation: ${child} violates imposed ${constraint} constraint ${parent}`\n    )\n  }\n}\n\n/**\n * @template {Types.ParsedCapability<\"store/add\"|\"store/get\"|\"store/remove\", Types.URI<'did:'>, {link?: Types.Link<unknown, number, number, 0|1>}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalLink = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(\n      `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n    )\n  } else if (\n    delegated.nb.link &&\n    `${delegated.nb.link}` !== `${claimed.nb.link}`\n  ) {\n    return fail(\n      `Link ${claimed.nb.link ? `${claimed.nb.link}` : ''} violates imposed ${\n        delegated.nb.link\n      } constraint.`\n    )\n  } else {\n    return ok({})\n  }\n}\n\n/**\n * @template {Types.ParsedCapability<\"space/blob/add\"|\"space/blob/remove\"|\"web3.storage/blob/allocate\"|\"web3.storage/blob/accept\", Types.URI<'did:'>, {blob: { digest: Uint8Array, size: number }}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalBlob = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(\n      `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n    )\n  } else if (\n    delegated.nb.blob.digest &&\n    !equals(delegated.nb.blob.digest, claimed.nb.blob.digest)\n  ) {\n    return fail(\n      `Link ${\n        claimed.nb.blob.digest ? `${claimed.nb.blob.digest}` : ''\n      } violates imposed ${delegated.nb.blob.digest} constraint.`\n    )\n  } else if (\n    claimed.nb.blob.size !== undefined &&\n    delegated.nb.blob.size !== undefined\n  ) {\n    return claimed.nb.blob.size > delegated.nb.blob.size\n      ? fail(\n          `Size constraint violation: ${claimed.nb.blob.size} > ${delegated.nb.blob.size}`\n        )\n      : ok({})\n  } else {\n    return ok({})\n  }\n}\n\n/**\n * @template {Types.ParsedCapability<\"http/put\", Types.URI<'did:'>, {body: { digest: Uint8Array, size: number }}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalBody = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(\n      `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n    )\n  } else if (\n    delegated.nb.body.digest &&\n    !equals(delegated.nb.body.digest, claimed.nb.body.digest)\n  ) {\n    return fail(\n      `Link ${\n        claimed.nb.body.digest ? `${claimed.nb.body.digest}` : ''\n      } violates imposed ${delegated.nb.body.digest} constraint.`\n    )\n  } else if (\n    claimed.nb.body.size !== undefined &&\n    delegated.nb.body.size !== undefined\n  ) {\n    return claimed.nb.body.size > delegated.nb.body.size\n      ? fail(\n          `Size constraint violation: ${claimed.nb.body.size} > ${delegated.nb.body.size}`\n        )\n      : ok({})\n  } else {\n    return ok({})\n  }\n}\n\n/**\n * @template {Types.ParsedCapability<\"blob/add\"|\"blob/remove\"|\"blob/allocate\"|\"blob/accept\"|\"http/put\", Types.URI<'did:'>, {content: Uint8Array}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalContent = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(\n      `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n    )\n  } else if (\n    delegated.nb.content &&\n    !equals(delegated.nb.content, claimed.nb.content)\n  ) {\n    return fail(\n      `Link ${\n        claimed.nb.content ? `${claimed.nb.content}` : ''\n      } violates imposed ${delegated.nb.content} constraint.`\n    )\n  } else {\n    return ok({})\n  }\n}\n\n/**\n * Checks that `claimed` {@link Types.Link} meets an `imposed` constraint.\n *\n * @param {Types.UnknownLink} claimed\n * @param {Types.UnknownLink|undefined} imposed\n * @param {string} at\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const checkLink = (claimed, imposed, at) => {\n  return equal(\n    String(claimed),\n    imposed === undefined ? undefined : String(imposed),\n    at\n  )\n}\n\n/**\n * @template T\n * @param {Types.Result<T , Types.Failure>} result\n * @returns {{error: Types.Failure, ok?:undefined}|undefined}\n */\nexport const and = (result) => (result.error ? result : undefined)\n\n/**\n *\n * @param {import('@ucanto/interface').Ability} ability\n */\nfunction parseAbility(ability) {\n  const [namespace, ...segments] = ability.split('/')\n  return { namespace, segments }\n}\n\n/**\n *\n * TODO: needs to account for caps derived from different namespaces like 'account/info' can be derived from 'store/add'\n *\n * @param {import('@ucanto/interface').Ability} parent\n * @param {import('@ucanto/interface').Ability} child\n */\nexport function canDelegateAbility(parent, child) {\n  const parsedParent = parseAbility(parent)\n  const parsedChild = parseAbility(child)\n\n  // Parent is wildcard\n  if (parsedParent.namespace === '*' && parsedParent.segments.length === 0) {\n    return true\n  }\n\n  // Child is wild card so it can not be delegated from anything\n  if (parsedChild.namespace === '*' && parsedChild.segments.length === 0) {\n    return false\n  }\n\n  // namespaces don't match\n  if (parsedParent.namespace !== parsedChild.namespace) {\n    return false\n  }\n\n  // given that namespaces match and parent first segment is wildcard\n  if (parsedParent.segments[0] === '*') {\n    return true\n  }\n\n  // Array equality\n  if (parsedParent.segments.length !== parsedChild.segments.length) {\n    return false\n  }\n\n  // all segments must match\n  return parsedParent.segments.reduce(\n    (acc, v, i) => acc && parsedChild.segments[i] === v,\n    true\n  )\n}\n", "/**\n * Filecoin Storefront Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Storefront from '@web3-storage/capabilities/filecoin/storefront'\n * ```\n *\n * @module\n */\n\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport { PieceLink } from './lib.js'\nimport { equalWith, checkLink, and } from '../utils.js'\n\n/**\n * Capability allowing an agent to _request_ storing a content piece in\n * Filecoin.\n */\nexport const filecoinOffer = capability({\n  can: 'filecoin/offer',\n  /**\n   * DID of the space the content is stored in.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the content that resulted in Filecoin piece.\n     */\n    content: Schema.link(),\n    /**\n     * CID of the piece.\n     */\n    piece: PieceLink,\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.content, from.nb.content, 'nb.content')) ||\n      and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability allowing a Storefront to signal that an offered piece has been\n * submitted to the filecoin storage pipeline.\n */\nexport const filecoinSubmit = capability({\n  can: 'filecoin/submit',\n  /**\n   * DID of the Storefront.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the content that resulted in Filecoin piece.\n     */\n    content: Schema.link(),\n    /**\n     * CID of the piece.\n     *\n     * @see https://github.com/filecoin-project/FIPs/pull/758/files\n     */\n    piece: PieceLink,\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.content, from.nb.content, 'nb.content')) ||\n      and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability allowing a Storefront to signal that a submitted piece has been\n * accepted in a Filecoin deal. The receipt contains the proof.\n */\nexport const filecoinAccept = capability({\n  can: 'filecoin/accept',\n  /**\n   * DID of the Storefront.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the content that resulted in Filecoin piece.\n     */\n    content: Schema.link(),\n    /**\n     * CID of the piece.\n     *\n     * @see https://github.com/filecoin-project/FIPs/pull/758/files\n     */\n    piece: PieceLink,\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.content, from.nb.content, 'nb.content')) ||\n      and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability allowing an agent to _request_ info about a content piece in\n * Filecoin deals.\n */\nexport const filecoinInfo = capability({\n  can: 'filecoin/info',\n  /**\n   * DID of the space the content is stored in.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the piece.\n     *\n     * @see https://github.com/filecoin-project/FIPs/pull/758/files\n     */\n    piece: PieceLink,\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n      ok({})\n    )\n  },\n})\n", null, "/**\n * Filecoin Aggregator Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Aggregator from '@web3-storage/capabilities/filecoin/aggregator'\n * ```\n *\n * @module\n */\n\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport { PieceLink } from './lib.js'\nimport { equal, equalWith, checkLink, and } from '../utils.js'\n\n/**\n * Capability that allows a Storefront to request that a piece be aggregated\n * for inclusion in an upcoming an Filecoin deal.\n */\nexport const pieceOffer = capability({\n  can: 'piece/offer',\n  /**\n   * DID of an authorized Storefront.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the piece.\n     */\n    piece: PieceLink,\n    /**\n     * Grouping of joining segments into an aggregate.\n     */\n    group: Schema.text(),\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n      and(equal(claim.nb.group, from.nb.group, 'nb.group')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability that allows an Aggregator to signal a piece has been accepted\n * or rejected for inclusion in an aggregate.\n */\nexport const pieceAccept = capability({\n  can: 'piece/accept',\n  /**\n   * DID of the Aggregator.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the piece.\n     *\n     * @see https://github.com/filecoin-project/FIPs/pull/758/files\n     */\n    piece: PieceLink,\n    /**\n     * Grouping of joining segments into an aggregate.\n     */\n    group: Schema.text(),\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n      and(equal(claim.nb.group, from.nb.group, 'nb.group')) ||\n      ok({})\n    )\n  },\n})\n", null, "/**\n * Filecoin Dealer Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Dealer from '@web3-storage/capabilities/filecoin/dealer'\n * ```\n *\n * @module\n */\n\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport { PieceLink } from './lib.js'\nimport { equalWith, checkLink, and } from '../utils.js'\n\n/**\n * Capability allowing an Aggregator to request an aggregate to be added to a\n * deal with a Storage Provider.\n */\nexport const aggregateOffer = capability({\n  can: 'aggregate/offer',\n  /**\n   * DID of an authorized Storefront.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * Commitment proof for the aggregate being offered.\n     */\n    aggregate: PieceLink,\n    /**\n     * CID of the DAG-CBOR encoded block with offer details.\n     * Service will queue given offer to be validated and handled.\n     */\n    pieces: Schema.link({ version: 1 }),\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.aggregate, from.nb.aggregate, 'nb.aggregate')) ||\n      and(checkLink(claim.nb.pieces, from.nb.pieces, 'nb.pieces')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability that allows a Dealer to signal an aggregate has been accepted\n * for inclusion in a Filecoin deal.\n */\nexport const aggregateAccept = capability({\n  can: 'aggregate/accept',\n  /**\n   * did:key identifier of the broker authority where offer is made available.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * Commitment proof for the aggregate being offered.\n     */\n    aggregate: PieceLink,\n    /**\n     * CID of the DAG-CBOR encoded block with offer details.\n     * Service will queue given offer to be validated and handled.\n     */\n    pieces: Schema.link(),\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.aggregate, from.nb.aggregate, 'nb.aggregate')) ||\n      and(checkLink(claim.nb.pieces, from.nb.pieces, 'nb.pieces')) ||\n      ok({})\n    )\n  },\n})\n", null, "/**\n * Filecoin Deal Tracker Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as DealTracker from '@web3-storage/capabilities/filecoin/deal-tracker'\n * ```\n *\n * @module\n */\n\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport { PieceLink } from './lib.js'\nimport { equalWith, checkLink, and } from '../utils.js'\n\n/**\n * Capability allowing a Storefront or Aggregator to obtain deal information\n * for a given aggregate piece.\n */\nexport const dealInfo = capability({\n  can: 'deal/info',\n  /**\n   * DID of the Storefront.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the piece.\n     *\n     * @see https://github.com/filecoin-project/FIPs/pull/758/files\n     */\n    piece: PieceLink,\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n      ok({})\n    )\n  },\n})\n", null, "// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n", "import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n", "import { base32 } from './bases/base32.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport * as varint from './varint.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  /**\n   * @returns {API.LinkJSON<this>}\n   */\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "import { CID, format, toJSON, fromJSON } from './cid.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nconst DAG_PB_CODE = 0x70\n// eslint-disable-next-line\nconst SHA_256_CODE = 0x12\n\n/**\n * Simplified version of `create` for CIDv0.\n *\n * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n * @returns {API.LegacyLink}\n */\nexport const createLegacy = digest => CID.create(0, DAG_PB_CODE, digest)\n\n/**\n * Simplified version of `create` for CIDv1.\n *\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @param {Code} code - Content encoding format code.\n * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n * @returns {API.Link<Data, Code, Alg>}\n */\nexport const create = (code, digest) => CID.create(1, code, digest)\n\n/**\n * Type predicate returns true if value is the link.\n *\n * @template {API.Link<unknown, number, number, 0|1>} L\n * @param {unknown|L} value\n * @returns {value is L & CID}\n */\nexport const isLink = value => {\n  if (value == null) {\n    return false\n  }\n\n  const withSlash = /** @type {{'/'?: Uint8Array, bytes: Uint8Array}} */ (value)\n\n  if (withSlash['/'] != null && withSlash['/'] === withSlash.bytes) {\n    return true\n  }\n\n  const withAsCID = /** @type {{'asCID'?: unknown}} */ (value)\n\n  if (withAsCID.asCID === value) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Takes cid in a string representation and creates an instance. If `base`\n * decoder is not provided will use a default from the configuration. It will\n * throw an error if encoding of the CID is not compatible with supplied (or\n * a default decoder).\n *\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {API.Link<Data, Code, Alg, Ver>}\n */\nexport const parse = (source, base) => CID.parse(source, base)\n\nexport { format, toJSON, fromJSON }\n\n/**\n * Decoded a CID from its binary representation. The byte array must contain\n * only the CID with no additional bytes.\n *\n * An error will be thrown if the bytes provided do not contain a valid\n * binary representation of a CID.\n *\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n * @returns {API.Link<Data, Code, Alg, Ver>}\n */\nexport const decode = bytes => CID.decode(bytes)\n", "// @ts-check\n\nimport { coerce } from '../bytes.js'\n\n/**\n * @template T\n * @typedef {import('./interface.js').ByteView<T>} ByteView\n */\n\nexport const name = 'raw'\nexport const code = 0x55\n\n/**\n * @param {Uint8Array} node\n * @returns {ByteView<Uint8Array>}\n */\nexport const encode = (node) => coerce(node)\n\n/**\n * @param {ByteView<Uint8Array>} data\n * @returns {Uint8Array}\n */\nexport const decode = (data) => coerce(data)\n", "import * as Digest from './digest.js'\n\n/**\n * @template {string} Name\n * @template {number} Code\n * @param {object} options\n * @param {Name} options.name\n * @param {Code} options.code\n * @param {(input: Uint8Array) => Await<Uint8Array>} options.encode\n */\nexport const from = ({ name, code, encode }) => new Hasher(name, code, encode)\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n *\n * @template {string} Name\n * @template {number} Code\n * @class\n * @implements {MultihashHasher<Code>}\n */\nexport class Hasher {\n  /**\n   *\n   * @param {Name} name\n   * @param {Code} code\n   * @param {(input: Uint8Array) => Await<Uint8Array>} encode\n   */\n  constructor (name, code, encode) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  /**\n   * @param {Uint8Array} input\n   * @returns {Await<Digest.Digest<Code, number>>}\n   */\n  digest (input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * @template {number} Alg\n * @typedef {import('./interface.js').MultihashHasher} MultihashHasher\n */\n\n/**\n * @template T\n * @typedef {Promise<T>|T} Await\n */\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", null, "/**\n * Store Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Store from '@web3-storage/capabilities/store'\n * ```\n *\n * @module\n */\nimport { capability, Link, Schema, ok, fail } from '@ucanto/validator'\nimport { equalLink, equalWith, SpaceDID } from './utils.js'\n\n// @see https://github.com/multiformats/multicodec/blob/master/table.csv#L140\nexport const code = 0x0202\n\nexport const CARLink = Schema.link({ code, version: 1 })\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `store/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const store = capability({\n  can: 'store/*',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * `store/add` capability allows agent to store a CAR file into a (memory) space\n * identified by did:key in the `with` field. Agent must precompute CAR locally\n * and provide it's CID and size using `nb.link` and `nb.size` fields, allowing\n * a service to provision a write location for the agent to PUT or POST desired\n * CAR into.\n */\nexport const add = capability({\n  can: 'store/add',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * CID of the CAR file to be stored. Service will provision write target\n     * for this exact CAR file for agent to PUT or POST it. Attempt to write\n     * any other content will fail.\n     */\n    link: CARLink,\n    /**\n     * Size of the CAR file to be stored. Service will provision write target\n     * for this exact size. Attempt to write a larger CAR file will fail.\n     */\n    size: Schema.integer(),\n    /**\n     * Agent may optionally provide a link to a related CAR file using `origin`\n     * field. This is useful when storing large DAGs, agent could shard it\n     * across multiple CAR files and then link each shard with a previous one.\n     *\n     * Providing this relation tells service that given CAR is shard of the\n     * larger DAG as opposed to it being intentionally partial DAG. When DAG is\n     * not sharded, there will be only one `store/add` with `origin` left out.\n     */\n    origin: Link.optional(),\n  }),\n  derives: (claim, from) => {\n    const result = equalLink(claim, from)\n    if (result.error) {\n      return result\n    } else if (claim.nb.size !== undefined && from.nb.size !== undefined) {\n      return claim.nb.size > from.nb.size\n        ? fail(`Size constraint violation: ${claim.nb.size} > ${from.nb.size}`)\n        : ok({})\n    } else {\n      return ok({})\n    }\n  },\n})\n\n/**\n * Capability to get store metadata by shard CID.\n * Use to check for inclusion, or get shard size and origin\n *\n * `nb.link` is optional to allow delegation of `store/get`\n * capability for any shard CID. If link is specified, then the\n * capability only allows a get for that specific CID.\n *\n * When used as as an invocation, `nb.link` must be specified.\n */\nexport const get = capability({\n  can: 'store/get',\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * shard CID to fetch info about.\n     */\n    link: CARLink.optional(),\n  }),\n  derives: equalLink,\n})\n\n/**\n * Capability can be used to remove the stored CAR file from the (memory)\n * space identified by `with` field.\n */\nexport const remove = capability({\n  can: 'store/remove',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * CID of the CAR file to be removed from the store.\n     */\n    link: CARLink,\n  }),\n  derives: equalLink,\n})\n\n/**\n * Capability can be invoked to request a list of stored CAR files in the\n * (memory) space identified by `with` field.\n */\nexport const list = capability({\n  can: 'store/list',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A pointer that can be moved back and forth on the list.\n     * It can be used to paginate a list for instance.\n     */\n    cursor: Schema.string().optional(),\n    /**\n     * Maximum number of items per page.\n     */\n    size: Schema.integer().optional(),\n    /**\n     * If true, return page of results preceding cursor. Defaults to false.\n     */\n    pre: Schema.boolean().optional(),\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(\n        `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n      )\n    }\n    return ok({})\n  },\n})\n\nexport const all = add.or(remove).or(list)\n\n// \u26A0\uFE0F We export imports here so they are not omitted in generated typedes\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema, Link }\n", "import retry from 'retry';\n\nconst networkErrorMsgs = new Set([\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari\n\t'Network request failed', // `cross-fetch`\n\t'fetch failed', // Undici (Node.js)\n]);\n\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\treturn error;\n};\n\nconst isNetworkError = errorMessage => networkErrorMsgs.has(errorMessage);\n\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new Error(errorMessage)\n\t: new DOMException(errorMessage);\n\nexport default async function pRetry(input, options) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = {\n\t\t\tonFailedAttempt() {},\n\t\t\tretries: 10,\n\t\t\t...options,\n\t\t};\n\n\t\tconst operation = retry.operation(options);\n\n\t\toperation.attempt(async attemptNumber => {\n\t\t\ttry {\n\t\t\t\tresolve(await input(attemptNumber));\n\t\t\t} catch (error) {\n\t\t\t\tif (!(error instanceof Error)) {\n\t\t\t\t\treject(new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (error instanceof AbortError) {\n\t\t\t\t\toperation.stop();\n\t\t\t\t\treject(error.originalError);\n\t\t\t\t} else if (error instanceof TypeError && !isNetworkError(error.message)) {\n\t\t\t\t\toperation.stop();\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait options.onFailedAttempt(error);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\t\treject(operation.mainError());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (options.signal && !options.signal.aborted) {\n\t\t\toptions.signal.addEventListener('abort', () => {\n\t\t\t\toperation.stop();\n\t\t\t\tconst reason = options.signal.reason === undefined\n\t\t\t\t\t? getDOMException('The operation was aborted.')\n\t\t\t\t\t: options.signal.reason;\n\t\t\t\treject(reason instanceof Error ? reason : getDOMException(reason));\n\t\t\t}, {\n\t\t\t\tonce: true,\n\t\t\t});\n\t\t}\n\t});\n}\n", null, null, "export * from './ed25519/signer.js'\nexport * as Verifier from './ed25519/verifier.js'\nexport * as Signer from './ed25519/signer.js'\n", "import * as ED25519 from '@noble/ed25519'\nimport { varint } from 'multiformats'\nimport * as API from './type.js'\nimport * as Verifier from './verifier.js'\nimport { base64pad } from 'multiformats/bases/base64'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport * as Signer from '../signer.js'\nexport * from './type.js'\n\nexport const code = 0x1300\nexport const name = Verifier.name\n\n/** @type {'EdDSA'} */\nexport const signatureAlgorithm = Verifier.signatureAlgorithm\nexport const signatureCode = Verifier.signatureCode\n\nconst PRIVATE_TAG_SIZE = varint.encodingLength(code)\nconst PUBLIC_TAG_SIZE = varint.encodingLength(Verifier.code)\nconst KEY_SIZE = 32\nconst SIZE = PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE + KEY_SIZE\n\nexport const PUB_KEY_OFFSET = PRIVATE_TAG_SIZE + KEY_SIZE\n\n/**\n * Generates new issuer by generating underlying ED25519 keypair.\n * @returns {Promise<API.EdSigner>}\n */\nexport const generate = () => derive(ED25519.utils.randomPrivateKey())\n\n/**\n * Derives issuer from 32 byte long secret key.\n * @param {Uint8Array} secret\n * @returns {Promise<API.EdSigner>}\n */\nexport const derive = async secret => {\n  if (secret.byteLength !== KEY_SIZE) {\n    throw new Error(\n      `Expected Uint8Array with byteLength of ${KEY_SIZE} instead not ${secret.byteLength}`\n    )\n  }\n\n  const publicKey = await ED25519.getPublicKey(secret)\n  const signer = new Ed25519Signer(SIZE)\n\n  varint.encodeTo(code, signer, 0)\n  signer.set(secret, PRIVATE_TAG_SIZE)\n\n  varint.encodeTo(Verifier.code, signer, PRIVATE_TAG_SIZE + KEY_SIZE)\n  signer.set(publicKey, PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE)\n\n  return signer\n}\n\n/**\n * @param {API.SignerArchive<API.DID, typeof signatureCode>} archive\n * @returns {API.EdSigner}\n */\nexport const from = ({ id, keys }) => {\n  if (id.startsWith('did:key:')) {\n    const key = keys[/** @type {API.DIDKey} */ (id)]\n    if (key instanceof Uint8Array) {\n      return decode(key)\n    }\n  }\n  throw new TypeError(`Unsupported archive format`)\n}\n\n/**\n * @template {API.SignerImporter} O\n * @param {O} other\n */\nexport const or = other => Signer.or({ from }, other)\n\n/**\n * @param {Uint8Array} bytes\n * @returns {API.EdSigner}\n */\nexport const decode = bytes => {\n  if (bytes.byteLength !== SIZE) {\n    throw new Error(\n      `Expected Uint8Array with byteLength of ${SIZE} instead not ${bytes.byteLength}`\n    )\n  }\n\n  {\n    const [keyCode] = varint.decode(bytes)\n    if (keyCode !== code) {\n      throw new Error(`Given bytes must be a multiformat with ${code} tag`)\n    }\n  }\n\n  {\n    const [code] = varint.decode(bytes.subarray(PUB_KEY_OFFSET))\n    if (code !== Verifier.code) {\n      throw new Error(\n        `Given bytes must contain public key in multiformats with ${Verifier.code} tag`\n      )\n    }\n  }\n\n  return new Ed25519Signer(bytes)\n}\n\n/**\n * @param {API.EdSigner} signer\n * @return {API.ByteView<API.EdSigner & CryptoKeyPair>}\n */\nexport const encode = signer => signer.encode()\n\n/**\n * @template {string} Prefix\n * @param {API.EdSigner} signer\n * @param {API.MultibaseEncoder<Prefix>} [encoder]\n */\nexport const format = (signer, encoder) =>\n  (encoder || base64pad).encode(encode(signer))\n\n/**\n * @template {string} Prefix\n * @param {string} principal\n * @param {API.MultibaseDecoder<Prefix>} [decoder]\n * @returns {API.EdSigner}\n */\nexport const parse = (principal, decoder) =>\n  decode((decoder || base64pad).decode(principal))\n\n/**\n * @implements {API.EdSigner}\n */\nclass Ed25519Signer extends Uint8Array {\n  /** @type {typeof code} */\n  get code() {\n    return code\n  }\n  get signer() {\n    return this\n  }\n  /** @type {API.EdVerifier} */\n  get verifier() {\n    const bytes = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE + KEY_SIZE)\n    const verifier = Verifier.decode(bytes)\n\n    Object.defineProperties(this, {\n      verifier: {\n        value: verifier,\n      },\n    })\n\n    return verifier\n  }\n\n  /**\n   * Raw public key without multiformat code.\n   */\n  get secret() {\n    const secret = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE, KEY_SIZE)\n    Object.defineProperties(this, {\n      secret: {\n        value: secret,\n      },\n    })\n\n    return secret\n  }\n\n  /**\n   * DID of this principal in `did:key` format.\n   */\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof Signature.EdDSA>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @returns {Promise<API.SignatureView<T, typeof Signature.EdDSA>>}\n   */\n  async sign(payload) {\n    const raw = await ED25519.sign(payload, this.secret)\n\n    return Signature.create(this.signatureCode, raw)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   */\n\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  get signatureCode() {\n    return Signature.EdDSA\n  }\n\n  encode() {\n    return this\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.encode() },\n    }\n  }\n}\n", "/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _8n = BigInt(8);\nconst CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');\nconst CURVE = Object.freeze({\n    a: BigInt(-1),\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),\n    l: CU_O,\n    n: CU_O,\n    h: BigInt(8),\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n});\nexport { CURVE };\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\nclass ExtendedPoint {\n    constructor(x, y, z, t) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.t = t;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return ExtendedPoint.ZERO;\n        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    equals(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const X1Z2 = mod(X1 * Z2);\n        const X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2);\n        const Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    negate() {\n        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { a } = CURVE;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(_2n * mod(Z1 * Z1));\n        const D = mod(a * A);\n        const x1y1 = X1 + Y1;\n        const E = mod(mod(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1, t: T1 } = this;\n        const { x: X2, y: Y2, z: Z2, t: T2 } = other;\n        const A = mod((Y1 - X1) * (Y2 + X2));\n        const B = mod((Y1 + X1) * (Y2 - X2));\n        const F = mod(B - A);\n        if (F === _0n)\n            return this.double();\n        const C = mod(Z1 * _2n * T2);\n        const D = mod(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    precomputeWindow(W) {\n        const windows = 1 + 256 / W;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(ExtendedPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = ExtendedPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = ExtendedPoint.ZERO;\n        let f = ExtendedPoint.BASE;\n        const windows = 1 + 256 / W;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return ExtendedPoint.normalizeZ([p, f])[0];\n    }\n    multiply(scalar, affinePoint) {\n        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar, CURVE.l, false);\n        const G = ExtendedPoint.BASE;\n        const P0 = ExtendedPoint.ZERO;\n        if (n === _0n)\n            return P0;\n        if (this.equals(P0) || n === _1n)\n            return this;\n        if (this.equals(G))\n            return this.wNAF(n);\n        let p = P0;\n        let d = this;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    isSmallOrder() {\n        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n    }\n    isTorsionFree() {\n        let p = this.multiplyUnsafe(CURVE.l / _2n).double();\n        if (CURVE.l % _2n)\n            p = p.add(this);\n        return p.equals(ExtendedPoint.ZERO);\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(ExtendedPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const ax = mod(x * invZ);\n        const ay = mod(y * invZ);\n        const zz = mod(z * invZ);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n    fromRistrettoBytes() {\n        legacyRist();\n    }\n    toRistrettoBytes() {\n        legacyRist();\n    }\n    fromRistrettoHash() {\n        legacyRist();\n    }\n}\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction assertExtPoint(other) {\n    if (!(other instanceof ExtendedPoint))\n        throw new TypeError('ExtendedPoint expected');\n}\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistrettoPoint))\n        throw new TypeError('RistrettoPoint expected');\n}\nfunction legacyRist() {\n    throw new Error('Legacy method: switch to RistrettoPoint');\n}\nclass RistrettoPoint {\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static calcElligatorRistrettoMap(r0) {\n        const { d } = CURVE;\n        const r = mod(SQRT_M1 * r0 * r0);\n        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n        let c = BigInt(-1);\n        const D = mod((c - d * r) * mod(r + d));\n        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n        let s_ = mod(s * r0);\n        if (!edIsNegative(s_))\n            s_ = mod(-s_);\n        if (!Ns_D_is_sq)\n            s = s_;\n        if (!Ns_D_is_sq)\n            c = r;\n        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n        const s2 = s * s;\n        const W0 = mod((s + s) * D);\n        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n        const W2 = mod(_1n - s2);\n        const W3 = mod(_1n + s2);\n        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static hashToCurve(hex) {\n        hex = ensureBytes(hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = this.calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = this.calcElligatorRistrettoMap(r2);\n        return new RistrettoPoint(R1.add(R2));\n    }\n    static fromHex(hex) {\n        hex = ensureBytes(hex, 32);\n        const { a, d } = CURVE;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2);\n        const u2 = mod(_1n - a * s2);\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2);\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2));\n        const Dx = mod(I * u2);\n        const Dy = mod(I * Dx * v);\n        let x = mod((s + s) * Dx);\n        if (edIsNegative(x))\n            x = mod(-x);\n        const y = mod(u1 * Dy);\n        const t = mod(x * y);\n        if (!isValid || edIsNegative(t) || y === _0n)\n            throw new Error(emsg);\n        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n    }\n    toRawBytes() {\n        let { x, y, z, t } = this.ep;\n        const u1 = mod(mod(z + y) * mod(z - y));\n        const u2 = mod(x * y);\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));\n        const D1 = mod(invsqrt * u1);\n        const D2 = mod(invsqrt * u2);\n        const zInv = mod(D1 * D2 * t);\n        let D;\n        if (edIsNegative(t * zInv)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2;\n        }\n        if (edIsNegative(x * zInv))\n            y = mod(-y);\n        let s = mod((z - y) * D);\n        if (edIsNegative(s))\n            s = mod(-s);\n        return numberTo32BytesLE(s);\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    equals(other) {\n        assertRstPoint(other);\n        const a = this.ep;\n        const b = other.ep;\n        const one = mod(a.x * b.y) === mod(a.y * b.x);\n        const two = mod(a.y * b.y) === mod(a.x * b.x);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistrettoPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n    }\n}\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromHex(hex, strict = true) {\n        const { d, P } = CURVE;\n        hex = ensureBytes(hex, 32);\n        const normed = hex.slice();\n        normed[31] = hex[31] & ~0x80;\n        const y = bytesToNumberLE(normed);\n        if (strict && y >= P)\n            throw new Error('Expected 0 < hex < P');\n        if (!strict && y >= POW_2_256)\n            throw new Error('Expected 0 < hex < 2**256');\n        const y2 = mod(y * y);\n        const u = mod(y2 - _1n);\n        const v = mod(d * y2 + _1n);\n        let { isValid, value: x } = uvRatio(u, v);\n        if (!isValid)\n            throw new Error('Point.fromHex: invalid y coordinate');\n        const isXOdd = (x & _1n) === _1n;\n        const isLastByteOdd = (hex[31] & 0x80) !== 0;\n        if (isLastByteOdd !== isXOdd) {\n            x = mod(-x);\n        }\n        return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n        return (await getExtendedPublicKey(privateKey)).point;\n    }\n    toRawBytes() {\n        const bytes = numberTo32BytesLE(this.y);\n        bytes[31] |= this.x & _1n ? 0x80 : 0;\n        return bytes;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n        const { y } = this;\n        const u = mod((_1n + y) * invert(_1n - y));\n        return numberTo32BytesLE(u);\n    }\n    isTorsionFree() {\n        return ExtendedPoint.fromAffine(this).isTorsionFree();\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex, 64);\n        const r = Point.fromHex(bytes.slice(0, 32), false);\n        const s = bytesToNumberLE(bytes.slice(32, 64));\n        return new Signature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!(r instanceof Point))\n            throw new Error('Expected Point instance');\n        normalizeScalar(s, CURVE.l, false);\n        return this;\n    }\n    toRawBytes() {\n        const u8 = new Uint8Array(64);\n        u8.set(this.r.toRawBytes());\n        u8.set(numberTo32BytesLE(this.s), 32);\n        return u8;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n}\nexport { ExtendedPoint, RistrettoPoint, Point, Signature };\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array list');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction numberTo32BytesBE(num) {\n    const length = 32;\n    const hex = num.toString(16).padStart(length * 2, '0');\n    return hexToBytes(hex);\n}\nfunction numberTo32BytesLE(num) {\n    return numberTo32BytesBE(num).reverse();\n}\nfunction edIsNegative(num) {\n    return (mod(num) & _1n) === _1n;\n}\nfunction bytesToNumberLE(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nfunction bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & MAX_255B);\n}\nfunction mod(a, b = CURVE.P) {\n    const res = a % b;\n    return res >= _0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = mod(acc * tmp[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return tmp;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction pow_2_252_3(x) {\n    const { P } = CURVE;\n    const _5n = BigInt(5);\n    const _10n = BigInt(10);\n    const _20n = BigInt(20);\n    const _40n = BigInt(40);\n    const _80n = BigInt(80);\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P;\n    const b4 = (pow2(b2, _2n) * b2) % P;\n    const b5 = (pow2(b4, _1n) * x) % P;\n    const b10 = (pow2(b5, _5n) * b5) % P;\n    const b20 = (pow2(b10, _10n) * b10) % P;\n    const b40 = (pow2(b20, _20n) * b20) % P;\n    const b80 = (pow2(b40, _40n) * b40) % P;\n    const b160 = (pow2(b80, _80n) * b80) % P;\n    const b240 = (pow2(b160, _80n) * b80) % P;\n    const b250 = (pow2(b240, _10n) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n) * x) % P;\n    return { pow_p_5_8, b2 };\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2;\n    if (edIsNegative(x))\n        x = mod(-x);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nfunction invertSqrt(number) {\n    return uvRatio(_1n, number);\n}\nfunction modlLE(hash) {\n    return mod(bytesToNumberLE(hash), CURVE.l);\n}\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureBytes(hex, expectedLength) {\n    const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n    if (typeof expectedLength === 'number' && bytes.length !== expectedLength)\n        throw new Error(`Expected ${expectedLength} bytes`);\n    return bytes;\n}\nfunction normalizeScalar(num, max, strict = true) {\n    if (!max)\n        throw new TypeError('Specify max value');\n    if (typeof num === 'number' && Number.isSafeInteger(num))\n        num = BigInt(num);\n    if (typeof num === 'bigint' && num < max) {\n        if (strict) {\n            if (_0n < num)\n                return num;\n        }\n        else {\n            if (_0n <= num)\n                return num;\n        }\n    }\n    throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\nfunction adjustBytes25519(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n}\nfunction decodeScalar25519(n) {\n    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\nfunction checkPrivateKey(key) {\n    key =\n        typeof key === 'bigint' || typeof key === 'number'\n            ? numberTo32BytesBE(normalizeScalar(key, POW_2_256))\n            : ensureBytes(key);\n    if (key.length !== 32)\n        throw new Error(`Expected 32 bytes`);\n    return key;\n}\nfunction getKeyFromHash(hashed) {\n    const head = adjustBytes25519(hashed.slice(0, 32));\n    const prefix = hashed.slice(32, 64);\n    const scalar = modlLE(head);\n    const point = Point.BASE.multiply(scalar);\n    const pointBytes = point.toRawBytes();\n    return { head, prefix, scalar, point, pointBytes };\n}\nlet _sha512Sync;\nfunction sha512s(...m) {\n    if (typeof _sha512Sync !== 'function')\n        throw new Error('utils.sha512Sync must be set to use sync methods');\n    return _sha512Sync(...m);\n}\nasync function getExtendedPublicKey(key) {\n    return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));\n}\nfunction getExtendedPublicKeySync(key) {\n    return getKeyFromHash(sha512s(checkPrivateKey(key)));\n}\nexport async function getPublicKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\nfunction getPublicKeySync(privateKey) {\n    return getExtendedPublicKeySync(privateKey).pointBytes;\n}\nexport async function sign(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);\n    const r = modlLE(await utils.sha512(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction signSync(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);\n    const r = modlLE(sha512s(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction prepareVerification(sig, message, publicKey) {\n    message = ensureBytes(message);\n    if (!(publicKey instanceof Point))\n        publicKey = Point.fromHex(publicKey, false);\n    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n    return { r, s, SB, pub: publicKey, msg: message };\n}\nfunction finishVerification(publicKey, r, SB, hashed) {\n    const k = modlLE(hashed);\n    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n    const RkA = ExtendedPoint.fromAffine(r).add(kA);\n    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\nexport async function verify(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nfunction verifySync(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nexport const sync = {\n    getExtendedPublicKey: getExtendedPublicKeySync,\n    getPublicKey: getPublicKeySync,\n    sign: signSync,\n    verify: verifySync,\n};\nexport async function getSharedSecret(privateKey, publicKey) {\n    const { head } = await getExtendedPublicKey(privateKey);\n    const u = Point.fromHex(publicKey).toX25519();\n    return curve25519.scalarMult(head, u);\n}\nPoint.BASE._setWindowSize(8);\nfunction cswap(swap, x_2, x_3) {\n    const dummy = mod(swap * (x_2 - x_3));\n    x_2 = mod(x_2 - dummy);\n    x_3 = mod(x_3 + dummy);\n    return [x_2, x_3];\n}\nfunction montgomeryLadder(pointU, scalar) {\n    const { P } = CURVE;\n    const u = normalizeScalar(pointU, P);\n    const k = normalizeScalar(scalar, P);\n    const a24 = BigInt(121665);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(255 - 1); t >= _0n; t--) {\n        const k_t = (k >> t) & _1n;\n        swap ^= k_t;\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        swap = k_t;\n        const A = x_2 + z_2;\n        const AA = mod(A * A);\n        const B = x_2 - z_2;\n        const BB = mod(B * B);\n        const E = AA - BB;\n        const C = x_3 + z_3;\n        const D = x_3 - z_3;\n        const DA = mod(D * A);\n        const CB = mod(C * B);\n        const dacb = DA + CB;\n        const da_cb = DA - CB;\n        x_3 = mod(dacb * dacb);\n        z_3 = mod(x_1 * mod(da_cb * da_cb));\n        x_2 = mod(AA * BB);\n        z_2 = mod(E * (AA + mod(a24 * E)));\n    }\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);\n    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n    return mod(x_2 * xp2);\n}\nfunction encodeUCoordinate(u) {\n    return numberTo32BytesLE(mod(u, CURVE.P));\n}\nfunction decodeUCoordinate(uEnc) {\n    const u = ensureBytes(uEnc, 32);\n    u[31] &= 127;\n    return bytesToNumberLE(u);\n}\nexport const curve25519 = {\n    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n    scalarMult(privateKey, publicKey) {\n        const u = decodeUCoordinate(publicKey);\n        const p = decodeScalar25519(privateKey);\n        const pu = montgomeryLadder(u, p);\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    },\n    scalarMultBase(privateKey) {\n        return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);\n    },\n};\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nexport const utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    getExtendedPublicKey,\n    mod,\n    invert,\n    TORSION_SUBGROUP: [\n        '0100000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n        '0000000000000000000000000000000000000000000000000000000000000080',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n        '0000000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n    ],\n    hashToPrivateScalar: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.randomBytes(32);\n    },\n    sha512: async (...messages) => {\n        const message = concatBytes(...messages);\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha512 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_2n);\n        return cached;\n    },\n    sha512Sync: undefined,\n};\nObject.defineProperties(utils, {\n    sha512Sync: {\n        configurable: false,\n        get() {\n            return _sha512Sync;\n        },\n        set(val) {\n            if (!_sha512Sync)\n                _sha512Sync = val;\n        },\n    },\n});\n", "import * as DID from '@ipld/dag-ucan/did'\nimport * as ED25519 from '@noble/ed25519'\nimport { varint } from 'multiformats'\nimport * as API from './type.js'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as Verifier from '../verifier.js'\n\n/** @type {API.EdVerifier['code']} */\nexport const code = 0xed\nexport const name = 'Ed25519'\n\n/** @type {API.SigAlg} */\nexport const signatureCode = Signature.EdDSA\nexport const signatureAlgorithm = 'EdDSA'\nconst PUBLIC_TAG_SIZE = varint.encodingLength(code)\nconst SIZE = 32 + PUBLIC_TAG_SIZE\n\n/**\n * @typedef {API.EdVerifier} EdVerifier\n */\n\n/**\n * Parses `did:key:` string as a VerifyingPrincipal.\n *\n * @param {API.DID|string} did\n * @returns {API.Verifier<API.DID, typeof signatureCode>}\n */\nexport const parse = did => decode(DID.parse(did))\n\n/**\n * Takes ed25519 public key tagged with `0xed` multiformat code and creates a\n * corresponding `Principal` that can be used to verify signatures.\n *\n * @param {Uint8Array} bytes\n * @returns {API.EdVerifier}\n */\nexport const decode = bytes => {\n  const [algorithm] = varint.decode(bytes)\n  if (algorithm !== code) {\n    throw new RangeError(\n      `Unsupported key algorithm with multicode 0x${code.toString(16)}`\n    )\n  } else if (bytes.byteLength !== SIZE) {\n    throw new RangeError(\n      `Expected Uint8Array with byteLength ${SIZE}, instead got Uint8Array with byteLength ${bytes.byteLength}`\n    )\n  } else {\n    return new Ed25519Verifier(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  }\n}\n\n/**\n * Formats given Principal into `did:key:` format.\n *\n * @param {API.Principal<API.DID>} principal\n */\nexport const format = principal => DID.format(principal)\n\n/**\n * Encodes given Principal by tagging it's ed25519 public key with `0xed`\n * multiformat code.\n *\n * @param {API.Principal<API.DID<\"key\">>} principal\n */\nexport const encode = principal => DID.encode(principal)\n\n/**\n * @implements {API.EdVerifier}\n */\nclass Ed25519Verifier extends Uint8Array {\n  /** @type {typeof code} */\n  get code() {\n    return code\n  }\n  /** @type {typeof signatureCode} */\n  get signatureCode() {\n    return signatureCode\n  }\n  /** @type {typeof signatureAlgorithm} */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  /**\n   * Raw public key without a multiformat code.\n   *\n   * @readonly\n   */\n  get publicKey() {\n    const key = new Uint8Array(this.buffer, this.byteOffset + PUBLIC_TAG_SIZE)\n    Object.defineProperties(this, {\n      publicKey: {\n        value: key,\n      },\n    })\n    return key\n  }\n  /**\n   * DID of the Principal in `did:key` format.\n   * @returns {API.DID<\"key\">}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this)}`\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, Signature.EdDSA>} signature\n   * @returns {API.Await<boolean>}\n   */\n  verify(payload, signature) {\n    return (\n      signature.code === signatureCode &&\n      ED25519.verify(signature.raw, payload, this.publicKey)\n    )\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Verifier<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Verifier.withDID(this, id)\n  }\n\n  toDIDKey() {\n    return this.did()\n  }\n}\n\n/**\n * @param {API.PrincipalParser} other\n */\nexport const or = other => Verifier.or({ parse }, other)\n", "import * as API from '@ucanto/interface'\n\n/**\n * @param {API.DID} did\n * @param {API.PrincipalParser[]} parsers\n * @return {API.Verifier}\n */\nconst parseWith = (did, parsers) => {\n  if (did.startsWith('did:')) {\n    for (const parser of parsers) {\n      try {\n        return parser.parse(did)\n      } catch (_) {}\n    }\n    throw new Error(`Unsupported did ${did}`)\n  } else {\n    throw new Error(`Expected did instead got ${did}`)\n  }\n}\n\n/**\n * @param {API.PrincipalParser} left\n * @param {API.PrincipalParser} right\n * @returns {API.ComposedDIDParser}\n */\nexport const or = (left, right) => new Parser([left, right])\n\n/**\n * @implements {API.ComposedDIDParser}\n */\nclass Parser {\n  /**\n   * @param {API.PrincipalParser[]} variants\n   */\n  constructor(variants) {\n    this.variants = variants\n  }\n\n  /**\n   * @param {API.DID} did\n   */\n  parse(did) {\n    return parseWith(did, this.variants)\n  }\n\n  /**\n   * @param {API.PrincipalParser} parser\n   */\n  or(parser) {\n    return new Parser([...this.variants, parser])\n  }\n}\n\n/**\n * @template {API.DID} ID\n * @template {API.MulticodecCode} SigAlg\n * @param {API.VerifierKey<SigAlg>} key\n * @param {ID} id\n * @returns {API.Verifier<ID, SigAlg>}\n */\nexport const withDID = (key, id) => new VerifierWithDID(id, key)\n\n/**\n * @template {API.DID} ID\n * @template {API.MulticodecCode} SigAlg\n * @implements {API.Verifier<ID, SigAlg>}\n */\nclass VerifierWithDID {\n  /**\n   * @param {ID} id\n   * @param {API.VerifierKey<SigAlg>} key\n   */\n  constructor(id, key) {\n    this.id = id\n    this.key = key\n  }\n  did() {\n    return this.id\n  }\n\n  toDIDKey() {\n    return this.key.toDIDKey()\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, SigAlg>} signature\n   * @returns {API.Await<boolean>}\n   */\n  verify(payload, signature) {\n    return this.key.verify(payload, signature)\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   */\n  withDID(id) {\n    return withDID(this.key, id)\n  }\n}\n", "import * as API from '@ucanto/interface'\n\n/**\n * @template {API.SignerImporter} L\n * @template {API.SignerImporter} R\n * @param {L} left\n * @param {R} right\n * @returns {API.CompositeImporter<[L, R]>}\n */\nexport const or = (left, right) => new Importer([left, right])\n\n/**\n * @template {[API.SignerImporter, ...API.SignerImporter[]]} Importers\n * @implements {API.CompositeImporter<Importers>}\n */\nclass Importer {\n  /**\n   * @param {Importers} variants\n   */\n  constructor(variants) {\n    this.variants = variants\n    this.from = create(variants)\n  }\n\n  /**\n   * @template {API.SignerImporter} Other\n   * @param {Other} other\n   * @returns {API.CompositeImporter<[Other, ...Importers]>}\n   */\n  or(other) {\n    return new Importer([other, ...this.variants])\n  }\n}\n\n/**\n * @template {[API.SignerImporter, ...API.SignerImporter[]]} Importers\n * @param {Importers} importers\n */\nconst create = importers => {\n  /**\n   * @template {API.DID} ID - DID that can be imported, which may be a type union.\n   * @template {API.SigAlg} Alg - Multicodec code corresponding to signature algorithm.\n   * @param {API.SignerArchive<ID, Alg>} archive\n   * @returns {API.Signer<ID, Alg>}\n   */\n  const from = archive => {\n    if (archive.id.startsWith('did:key:')) {\n      return /** @type {API.Signer<ID, Alg>} */ (importWith(archive, importers))\n    } else {\n      for (const [name, key] of Object.entries(archive.keys)) {\n        const id = /** @type {API.DIDKey} */ (name)\n        const signer = /** @type {API.Signer<API.DIDKey, Alg>} */ (\n          importWith(\n            {\n              id,\n              keys: { [id]: key },\n            },\n            importers\n          )\n        )\n\n        return signer.withDID(archive.id)\n      }\n\n      throw new Error(`Archive ${archive.id} contains no keys`)\n    }\n  }\n\n  return /** @type {API.Intersection<Importers[number]['from']>} */ (from)\n}\n\n/**\n * @param {API.SignerArchive} archive\n * @param {API.SignerImporter[]} importers\n * @returns {API.Signer}\n */\nconst importWith = (archive, importers) => {\n  for (const importer of importers) {\n    try {\n      return importer.from(archive)\n    } catch (_) {}\n  }\n  throw new Error(`Unsupported signer`)\n}\n/**\n * @template {number} Code\n * @template {API.DID} ID\n * @param {API.Signer<API.DID<'key'>, Code>} signer\n * @param {ID} id\n * @returns {API.Signer<ID, Code>}\n */\nexport const withDID = ({ signer, verifier }, id) =>\n  new SignerWithDID(signer, verifier.withDID(id))\n\n/**\n * @template {API.DID} ID\n * @template {number} Code\n * @implements {API.Signer<ID, Code>}\n */\nclass SignerWithDID {\n  /**\n   * @param {API.Signer<API.DID<'key'>, Code>} key\n   * @param {API.Verifier<ID, Code>} verifier\n   */\n  constructor(key, verifier) {\n    this.key = key\n    this.verifier = verifier\n  }\n  /** @type {API.Signer<ID, Code>} */\n  get signer() {\n    return this\n  }\n\n  get signatureAlgorithm() {\n    return this.key.signatureAlgorithm\n  }\n  get signatureCode() {\n    return this.key.signatureCode\n  }\n\n  /**\n   * @returns {ID}\n   */\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   */\n  withDID(id) {\n    return withDID(this.key, id)\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   */\n  sign(payload) {\n    return this.key.sign(payload)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, Code>} signature\n   */\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n\n  toArchive() {\n    const { keys } = this.key.toArchive()\n    return {\n      id: this.did(),\n      keys,\n    }\n  }\n}\n", "import { webcrypto } from 'one-webcrypto'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as API from './rsa/type.js'\nimport * as DID from '@ipld/dag-ucan/did'\nimport { tagWith, untagWith } from './multiformat.js'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport * as SPKI from './rsa/spki.js'\nimport * as PKCS8 from './rsa/pkcs8.js'\nimport * as PrivateKey from './rsa/private-key.js'\nimport * as PublicKey from './rsa/public-key.js'\nimport * as Verifier from './verifier.js'\nimport * as Signer from './signer.js'\nexport * from './rsa/type.js'\n\nexport const name = 'RSA'\n\n/** @type {API.RSASigner['code']} */\nexport const code = 0x1305\n\n/** @type {API.RSAVerifier['code']} */\nconst verifierCode = 0x1205\n\n/** @type {API.SigAlg} */\nexport const signatureCode = Signature.RS256\nexport const signatureAlgorithm = 'RS256'\n\nconst ALG = 'RSASSA-PKCS1-v1_5'\nconst HASH_ALG = 'SHA-256'\nconst KEY_SIZE = 2048\nconst SALT_LENGTH = 128\nconst IMPORT_PARAMS = {\n  name: ALG,\n  hash: { name: HASH_ALG },\n}\n\n/**\n * @param {object} options\n * @param {number} [options.size]\n * @param {boolean} [options.extractable]\n * @returns {Promise<API.RSASigner>}\n */\nexport const generate = async ({\n  size = KEY_SIZE,\n  extractable = false,\n} = {}) => {\n  // We start by generate an RSA keypair using web crypto API.\n  const { publicKey, privateKey } = await webcrypto.subtle.generateKey(\n    {\n      name: ALG,\n      modulusLength: size,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: { name: HASH_ALG },\n    },\n\n    extractable,\n    ['sign', 'verify']\n  )\n\n  // Next we need to encode public key, because `RSAVerifier` uses it to\n  // for implementing a `did()` method. To do this we first export\n  // Subject Public Key Info (SPKI) using web crypto API.\n  const spki = await webcrypto.subtle.exportKey('spki', publicKey)\n  // Then we extract public key from the SPKI and tag it with RSA public key\n  // multicode\n  const publicBytes = tagWith(verifierCode, SPKI.decode(new Uint8Array(spki)))\n  // Now that we have publicKey and it's multiformat representation we can\n  // create a verifier.\n  const verifier = new RSAVerifier({ bytes: publicBytes, publicKey })\n\n  // If we generated non extractable key we just wrap actual keys and verifier\n  // in the RSASigner view.\n  if (!extractable) {\n    return new UnextractableRSASigner({\n      privateKey,\n      verifier,\n    })\n  }\n  // Otherwise we export key in Private Key Cryptography Standards (PKCS)\n  // format and extract a bytes corresponding to the private key, which\n  // we tag with RSA private key multiformat code. With both binary and actual\n  // key representation we create a RSASigner view.\n  // Please note that do key export flow during generation so that we can:\n  // 1. Guarantee that it will be exportable.\n  // 2. Make `export` method sync.\n  else {\n    const pkcs8 = await webcrypto.subtle.exportKey('pkcs8', privateKey)\n    const bytes = tagWith(code, PKCS8.decode(new Uint8Array(pkcs8)))\n    return new ExtractableRSASigner({\n      privateKey,\n      bytes,\n      verifier,\n    })\n  }\n}\n\n/**\n * @param {API.SignerArchive<API.DID, typeof signatureCode>} archive\n * @returns {API.RSASigner}\n */\nexport const from = ({ id, keys }) => {\n  if (id.startsWith('did:key:')) {\n    const did = /** @type {API.DIDKey} */ (id)\n    const key = keys[did]\n    if (key instanceof Uint8Array) {\n      return decode(key)\n    } else {\n      return new UnextractableRSASigner({\n        privateKey: key,\n        verifier: RSAVerifier.parse(did),\n      })\n    }\n  } else {\n    throw new TypeError(\n      `RSA can not import from ${id} archive, try generic Signer instead`\n    )\n  }\n}\n\n/**\n * @template {API.SignerImporter} Other\n * @param {Other} other\n */\nexport const or = other => Signer.or({ from }, other)\n\n/**\n * @param {EncodedSigner} bytes\n * @returns {API.RSASigner}\n */\nexport const decode = bytes => {\n  // First we decode RSA key data from the private key with multicode tag.\n  const rsa = PrivateKey.decode(untagWith(code, bytes))\n  // Then we encode RSA key data as public key with multicode tag.\n  const publicBytes = tagWith(verifierCode, PublicKey.encode(rsa))\n\n  return new ExtractableRSASigner({\n    bytes,\n    privateKey: webcrypto.subtle.importKey(\n      'pkcs8',\n      PKCS8.encode(untagWith(code, bytes)),\n      IMPORT_PARAMS,\n      true,\n      ['sign']\n    ),\n\n    verifier: RSAVerifier.decode(publicBytes),\n  })\n}\n\n/**\n * @implements {API.RSAVerifier}\n */\nclass RSAVerifier {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.publicKey\n   * @param {API.ByteView<API.RSAVerifier>} options.bytes\n   */\n  constructor({ publicKey, bytes }) {\n    /** @private */\n    this.publicKey = publicKey\n    /** @private */\n    this.bytes = bytes\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Verifier<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Verifier.withDID(this, id)\n  }\n\n  toDIDKey() {\n    return this.did()\n  }\n\n  /**\n   * @param {API.ByteView<API.RSAVerifier>} bytes\n   * @returns {API.RSAVerifier}\n   */\n  static decode(bytes) {\n    return new this({\n      bytes,\n      publicKey: webcrypto.subtle.importKey(\n        'spki',\n        SPKI.encode(untagWith(verifierCode, bytes)),\n        IMPORT_PARAMS,\n        true,\n        ['verify']\n      ),\n    })\n  }\n  /**\n   * @param {API.DIDKey} did\n   * @returns {API.RSAVerifier}\n   */\n  static parse(did) {\n    return RSAVerifier.decode(/** @type {Uint8Array} */ (DID.parse(did)))\n  }\n\n  /**\n   * @param {API.PrincipalParser} other\n   */\n  static or(other) {\n    return Verifier.or(this, other)\n  }\n\n  /** @type {typeof verifierCode} */\n  get code() {\n    return verifierCode\n  }\n  /**\n   * @type {typeof signatureCode}\n   */\n  get signatureCode() {\n    return signatureCode\n  }\n  /**\n   * @type {typeof signatureAlgorithm}\n   */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  /**\n   * DID of the Principal in `did:key` format.\n   * @returns {API.DID<\"key\">}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this.bytes)}`\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   * @returns {Promise<boolean>}\n   */\n  async verify(payload, signature) {\n    // if signature code does not match RS256 it's not signed by corresponding\n    // signer.\n    if (signature.code !== signatureCode) {\n      return false\n    }\n\n    return webcrypto.subtle.verify(\n      { name: ALG, hash: { name: HASH_ALG } },\n      await this.publicKey,\n      signature.raw,\n      payload\n    )\n  }\n}\n\nconst RSAVerifier$ = /** @type {API.ComposedDIDParser} */ (RSAVerifier)\nexport { RSAVerifier as Verifier }\n\n/**\n * @typedef {API.ByteView<API.Signer<API.DID<'key'>, typeof signatureCode> & CryptoKey>} EncodedSigner\n */\n\nclass RSASigner {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.privateKey\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor({ privateKey, verifier }) {\n    /** @readonly */\n    this.verifier = verifier\n    /** @protected */\n    this.privateKey = privateKey\n  }\n  get signer() {\n    return this\n  }\n\n  /**\n   * @type {typeof code}\n   */\n  get code() {\n    return code\n  }\n  /**\n   * @type {typeof signatureCode}\n   */\n  get signatureCode() {\n    return signatureCode\n  }\n  /**\n   * @type {typeof signatureAlgorithm}\n   */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   */\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @returns {Promise<API.SignatureView<T, typeof signatureCode>>}\n   */\n  async sign(payload) {\n    const buffer = await webcrypto.subtle.sign(\n      { name: ALG, saltLength: SALT_LENGTH },\n      await this.privateKey,\n      payload\n    )\n\n    return Signature.create(signatureCode, new Uint8Array(buffer))\n  }\n}\n\n/**\n * @implements {API.RSASigner}\n */\nclass ExtractableRSASigner extends RSASigner {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.privateKey\n   * @param {EncodedSigner} options.bytes\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor(options) {\n    super(options)\n    this.bytes = options.bytes\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.bytes },\n    }\n  }\n}\n\n/**\n * @implements {API.RSASigner}\n */\nclass UnextractableRSASigner extends RSASigner {\n  /**\n   * @param {object} options\n   * @param {CryptoKey} options.privateKey\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor(options) {\n    super(options)\n    this.privateKey = options.privateKey\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.privateKey },\n    }\n  }\n}\n", "const _globalReference = globalThis || window || self\n\nexport const webcrypto = _globalReference.crypto\n", "import { varint } from 'multiformats'\n\n/**\n *\n * @param {number} code\n * @param {Uint8Array} bytes\n */\nexport const tagWith = (code, bytes) => {\n  const offset = varint.encodingLength(code)\n  const multiformat = new Uint8Array(bytes.byteLength + offset)\n  varint.encodeTo(code, multiformat, 0)\n  multiformat.set(bytes, offset)\n\n  return multiformat\n}\n\n/**\n * @param {number} code\n * @param {Uint8Array} source\n * @param {number} byteOffset\n * @returns\n */\nexport const untagWith = (code, source, byteOffset = 0) => {\n  const bytes = byteOffset !== 0 ? source.subarray(byteOffset) : source\n  const [tag, size] = varint.decode(bytes)\n  if (tag !== code) {\n    throw new Error(\n      `Expected multiformat with 0x${code.toString(\n        16\n      )} tag instead got 0x${tag.toString(16)}`\n    )\n  } else {\n    return new Uint8Array(bytes.buffer, bytes.byteOffset + size)\n  }\n}\n\nexport const encodingLength = varint.encodingLength\nexport const encodeTo = varint.encodeTo\nexport const decode = varint.decode\n", "/**\n * ASN1 Tags as per https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nconst TAG_SIZE = 1\nexport const INT_TAG = 0x02\nexport const BITSTRING_TAG = 0x03\nexport const OCTET_STRING_TAG = 0x04\nexport const NULL_TAG = 0x05\nexport const OBJECT_TAG = 0x06\nexport const SEQUENCE_TAG = 0x30\n\nexport const UNUSED_BIT_PAD = 0x00\n\n/**\n * @param {number} length\n * @returns {Uint8Array}\n */\nexport const encodeDERLength = length => {\n  if (length <= 127) {\n    return new Uint8Array([length])\n  }\n\n  /** @type {number[]} */\n  const octets = []\n  while (length !== 0) {\n    octets.push(length & 0xff)\n    length = length >>> 8\n  }\n  octets.reverse()\n  return new Uint8Array([0x80 | (octets.length & 0xff), ...octets])\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {{number: number, consumed: number}}\n */\nexport const readDERLength = (bytes, offset = 0) => {\n  if ((bytes[offset] & 0x80) === 0) {\n    return { number: bytes[offset], consumed: 1 }\n  }\n\n  const numberBytes = bytes[offset] & 0x7f\n  /* c8 ignore next 5 */\n  if (bytes.length < numberBytes + 1) {\n    throw new Error(\n      `ASN parsing error: Too few bytes. Expected encoded length's length to be at least ${numberBytes}`\n    )\n  }\n\n  let length = 0\n  for (let i = 0; i < numberBytes; i++) {\n    length = length << 8\n    length = length | bytes[offset + i + 1]\n  }\n\n  return { number: length, consumed: numberBytes + 1 }\n}\n\n/**\n * @param {Uint8Array} input\n * @param {number} expectedTag\n * @param {number} position\n * @returns {number}\n */\nexport const skip = (input, expectedTag, position) => {\n  const parsed = into(input, expectedTag, position)\n  return parsed.position + parsed.length\n}\n\n/**\n * @param {Uint8Array} input\n * @param {number} expectedTag\n * @param {number} offset\n * @returns {{ position: number, length: number }}\n */\nexport const into = (input, expectedTag, offset) => {\n  const actualTag = input[offset]\n  /* c8 ignore next 7 */\n  if (actualTag !== expectedTag) {\n    throw new Error(\n      `ASN parsing error: Expected tag 0x${expectedTag.toString(\n        16\n      )} at position ${offset}, but got 0x${actualTag.toString(16)}.`\n    )\n  }\n\n  // length\n  const length = readDERLength(input, offset + TAG_SIZE)\n  const position = offset + TAG_SIZE + length.consumed\n\n  // content\n  return { position, length: length.number }\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeBitString = input => {\n  // encode input length + 1 for unused bit pad\n  const length = encodeDERLength(input.byteLength + 1)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(\n    TAG_SIZE + // ASN_BITSTRING_TAG\n      length.byteLength +\n      1 + // amount of unused bits at the end of our bitstring\n      input.byteLength\n  )\n\n  let byteOffset = 0\n  // write bytestring tag\n  bytes[byteOffset] = BITSTRING_TAG\n  byteOffset += TAG_SIZE\n\n  // write length of the bytestring\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write unused bits at the end of our bitstring\n  bytes[byteOffset] = UNUSED_BIT_PAD\n  byteOffset += 1\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeOctetString = input => {\n  // encode input length\n  const length = encodeDERLength(input.byteLength)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(TAG_SIZE + length.byteLength + input.byteLength)\n\n  let byteOffset = 0\n  // write octet string tag\n  bytes[byteOffset] = OCTET_STRING_TAG\n  byteOffset += TAG_SIZE\n\n  // write octet string length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array[]} sequence\n */\nexport const encodeSequence = sequence => {\n  // calculate bytelength for all the parts\n  let byteLength = 0\n  for (const item of sequence) {\n    byteLength += item.byteLength\n  }\n\n  // encode sequence byte length\n  const length = encodeDERLength(byteLength)\n\n  // allocate the buffer to write sequence into\n  const bytes = new Uint8Array(TAG_SIZE + length.byteLength + byteLength)\n\n  let byteOffset = 0\n\n  // write the sequence tag\n  bytes[byteOffset] = SEQUENCE_TAG\n  byteOffset += TAG_SIZE\n\n  // write sequence length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write each item in the sequence\n  for (const item of sequence) {\n    bytes.set(item, byteOffset)\n    byteOffset += item.byteLength\n  }\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n */\nexport const readSequence = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, SEQUENCE_TAG, offset)\n\n  return new Uint8Array(bytes.buffer, bytes.byteOffset + position, length)\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeInt = input => {\n  const extra = input.byteLength === 0 || input[0] & 0x80 ? 1 : 0\n\n  // encode input length\n  const length = encodeDERLength(input.byteLength + extra)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(\n    TAG_SIZE + // INT_TAG\n      length.byteLength +\n      input.byteLength +\n      extra\n  )\n\n  let byteOffset = 0\n  // write octet string tag\n  bytes[byteOffset] = INT_TAG\n  byteOffset += TAG_SIZE\n\n  // write int length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // add 0 if the most-significant bit is set\n  if (extra > 0) {\n    bytes[byteOffset] = UNUSED_BIT_PAD\n    byteOffset += extra\n  }\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\n\nexport const enterSequence = (bytes, offset = 0) =>\n  into(bytes, SEQUENCE_TAG, offset).position\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\nexport const skipSequence = (bytes, offset = 0) =>\n  skip(bytes, SEQUENCE_TAG, offset)\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\nexport const skipInt = (bytes, offset = 0) => skip(bytes, INT_TAG, offset)\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nexport const readBitString = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, BITSTRING_TAG, offset)\n  const tag = bytes[position]\n  /* c8 ignore next 5 */\n  if (tag !== UNUSED_BIT_PAD) {\n    throw new Error(\n      `Can not read bitstring, expected length to be multiple of 8, but got ${tag} unused bits in last byte.`\n    )\n  }\n\n  return new Uint8Array(\n    bytes.buffer,\n    bytes.byteOffset + position + 1,\n    length - 1\n  )\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} byteOffset\n * @returns {Uint8Array}\n */\nexport const readInt = (bytes, byteOffset = 0) => {\n  const { position, length } = into(bytes, INT_TAG, byteOffset)\n  let delta = 0\n\n  // drop leading 0s\n  while (bytes[position + delta] === 0) {\n    delta++\n  }\n\n  return new Uint8Array(\n    bytes.buffer,\n    bytes.byteOffset + position + delta,\n    length - delta\n  )\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nexport const readOctetString = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, OCTET_STRING_TAG, offset)\n\n  return new Uint8Array(bytes.buffer, bytes.byteOffset + position, length)\n}\n\n/**\n * @typedef {(bytes:Uint8Array, offset:number) => Uint8Array} Reader\n * @param {[Reader, ...Reader[]]} readers\n * @param {Uint8Array} source\n * @param {number} byteOffset\n */\nexport const readSequenceWith = (readers, source, byteOffset = 0) => {\n  const results = []\n  const sequence = readSequence(source, byteOffset)\n  let offset = 0\n  for (const read of readers) {\n    const chunk = read(sequence, offset)\n    results.push(chunk)\n    offset = chunk.byteOffset + chunk.byteLength - sequence.byteOffset\n  }\n  return results\n}\n", "import * as API from '@ucanto/interface'\nimport {\n  encodeSequence,\n  encodeBitString,\n  enterSequence,\n  skipSequence,\n  readBitString,\n} from './asn1.js'\n\n/**\n * @typedef {import('./public-key.js').RSAPublicKey} RSAPublicKey\n */\n/**\n * Described in RFC 5208 Section 4.1: https://tools.ietf.org/html/rfc5280#section-4.1\n * ```\n * SubjectPublicKeyInfo  ::=  SEQUENCE  {\n *    algorithm            AlgorithmIdentifier,\n *    subjectPublicKey     BIT STRING  }\n * ```\n *\n * @typedef {object} SubjectPublicKeyInfo\n * @property {API.ByteView<AlgorithmIdentifier>} algorithm\n * @property {API.ByteView<RSAPublicKey>} subjectPublicKey\n * @typedef {import('./pkcs8.js').AlgorithmIdentifier} AlgorithmIdentifier\n */\n\n/**\n * The ASN.1 DER encoded header that needs to be added to an\n * ASN.1 DER encoded RSAPublicKey to make it a SubjectPublicKeyInfo.\n *\n * This byte sequence is always the same.\n *\n * A human-readable version of this as part of a dumpasn1 dump:\n *\n *     SEQUENCE {\n *       OBJECT IDENTIFIER rsaEncryption (1 2 840 113549 1 1 1)\n *       NULL\n *     }\n *\n * See https://github.com/ucan-wg/ts-ucan/issues/30\n */\nexport const SPKI_PARAMS_ENCODED = new Uint8Array([\n  48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0,\n])\n\n/**\n * @param {API.ByteView<RSAPublicKey>} key\n * @returns {API.ByteView<SubjectPublicKeyInfo>}\n */\nexport const encode = key =>\n  encodeSequence([SPKI_PARAMS_ENCODED, encodeBitString(key)])\n\n/**\n *\n * @param {API.ByteView<SubjectPublicKeyInfo>} info\n * @returns {API.ByteView<RSAPublicKey>}\n */\nexport const decode = info => {\n  // go into the top-level SEQUENCE\n  const offset = enterSequence(info, 0)\n  // skip the header we expect (SKPI_PARAMS_ENCODED)\n  const keyOffset = skipSequence(info, offset)\n\n  // we expect the bitstring next\n  return readBitString(info, keyOffset)\n}\n", "import * as API from '@ucanto/interface'\nimport { base64url } from 'multiformats/bases/base64'\nimport {\n  encodeSequence,\n  encodeOctetString,\n  enterSequence,\n  skipSequence,\n  skipInt,\n  readOctetString,\n} from './asn1.js'\n\nconst PKSC8_HEADER = new Uint8Array([\n  // version\n  2, 1, 0,\n  // privateKeyAlgorithm\n  48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0,\n])\n/**\n * @typedef {import('./private-key').RSAPrivateKey} RSAPrivateKey\n * @typedef {object} AlgorithmIdentifier\n * @property {Uint8Array} version\n * @property {Uint8Array} parameters\n *\n * @see https://datatracker.ietf.org/doc/html/rfc5208#section-5\n * @typedef {object} PrivateKeyInfo\n * @property {API.ByteView<number>} version\n * @property {API.ByteView<AlgorithmIdentifier>} privateKeyAlgorithm\n * @property {API.ByteView<RSAPrivateKey>} privateKey\n * @property {API.ByteView<unknown>} [attributes]\n */\n\n/**\n * @param {API.ByteView<PrivateKeyInfo>} info\n * @returns {API.ByteView<RSAPrivateKey>}\n */\nexport const decode = info => {\n  let offset = 0\n  // go into the top-level SEQUENCE\n  offset = enterSequence(info, offset)\n  offset = skipInt(info, offset)\n  offset = skipSequence(info, offset)\n\n  // we expect the bitstring next\n  return readOctetString(info, offset)\n}\n\n/**\n * @param {API.ByteView<RSAPrivateKey>} key\n * @returns {API.ByteView<PrivateKeyInfo>}\n */\nexport const encode = key =>\n  encodeSequence([PKSC8_HEADER, encodeOctetString(key)])\n", "import * as API from '@ucanto/interface'\nimport { encodeSequence, readInt, encodeInt, readSequenceWith } from './asn1.js'\nimport * as SPKI from './spki.js'\nimport { base64url } from 'multiformats/bases/base64'\n/**\n * RSA public key represenatation\n * @see https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1\n *\n * @typedef {object} RSAPublicKey\n * @property {API.ByteView<number>} n\n * @property {API.ByteView<number>} e\n */\n\n/**\n * Takes private-key information in [Private-Key Information Syntax](https://datatracker.ietf.org/doc/html/rfc5208#section-5)\n * and extracts all the fields as per [RSA private key syntax](https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1.2)\n *\n *\n * @param {API.ByteView<RSAPublicKey>} key\n * @param {number} byteOffset\n * @returns {RSAPublicKey}\n */\nexport const decode = (key, byteOffset = 0) => {\n  const [n, e] = readSequenceWith([readInt, readInt], key, byteOffset)\n\n  return { n, e }\n}\n\n/**\n * @param {RSAPublicKey} key\n * @returns {API.ByteView<RSAPublicKey>}\n */\nexport const encode = ({ n, e }) => encodeSequence([encodeInt(n), encodeInt(e)])\n\n/**\n * @param {RSAPublicKey} key\n */\nexport const toSPKI = key => SPKI.encode(encode(key))\n\n/**\n * @param {API.ByteView<SPKI.SubjectPublicKeyInfo>} info\n */\nexport const fromSPKI = info => decode(SPKI.decode(info))\n\n/**\n * @param {RSAPublicKey} key\n * @returns {JsonWebKey}\n */\nexport const toJWK = ({ n, e }) => ({\n  kty: 'RSA',\n  alg: 'RS256',\n  key_ops: ['verify'],\n  ext: true,\n  n: base64url.baseEncode(n),\n  e: base64url.baseEncode(e),\n})\n\n/**\n * @param {JsonWebKey} jwk\n * @returns {RSAPublicKey}\n */\nexport const fromJWK = ({ n, e }) => ({\n  n: base64urlDecode(n),\n  e: base64urlDecode(e),\n})\n\n/**\n * @param {string|undefined} input\n */\nconst base64urlDecode = (input = '') => base64url.baseDecode(input)\n", "import * as API from '@ucanto/interface'\nimport { encodeSequence, readInt, readSequenceWith, encodeInt } from './asn1.js'\nimport { base64url } from 'multiformats/bases/base64'\nimport * as PKCS8 from './pkcs8.js'\nimport * as SPKI from './spki.js'\nimport * as PublicKey from './public-key.js'\n\nexport const code = 0x1305\nconst VERSION = new Uint8Array()\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1.2\n * @typedef {object} RSAPrivateKey\n * @property {Uint8Array} v\n * @property {Uint8Array} n\n * @property {Uint8Array} e\n * @property {Uint8Array} d\n * @property {Uint8Array} p\n * @property {Uint8Array} q\n * @property {Uint8Array} dp\n * @property {Uint8Array} dq\n * @property {Uint8Array} qi\n */\n\n/**\n * Takes private-key information in [Private-Key Information Syntax](https://datatracker.ietf.org/doc/html/rfc5208#section-5)\n * and extracts all the fields as per [RSA private key syntax](https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1.2)\n *\n *\n * @param {API.ByteView<RSAPrivateKey>} source\n * @param {number} byteOffset\n * @returns {RSAPrivateKey}\n */\nexport const decode = (source, byteOffset = 0) => {\n  const [v, n, e, d, p, q, dp, dq, qi] = readSequenceWith(\n    [\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n    ],\n    source,\n    byteOffset\n  )\n\n  return { v, n, e, d, p, q, dp, dq, qi }\n}\n\n/**\n * @param {RSAPrivateKey} key\n * @returns {API.ByteView<RSAPrivateKey>}\n */\nexport const encode = ({ v, n, e, d, p, q, dp, dq, qi }) => {\n  return encodeSequence([\n    encodeInt(v),\n    encodeInt(n),\n    encodeInt(e),\n    encodeInt(d),\n    encodeInt(p),\n    encodeInt(q),\n    encodeInt(dp),\n    encodeInt(dq),\n    encodeInt(qi),\n  ])\n}\n\n/**\n * @param {RSAPrivateKey} key\n * @returns {JsonWebKey}\n */\nexport const toJWK = ({ n, e, d, p, q, dp, dq, qi }) => ({\n  kty: 'RSA',\n  alg: 'RS256',\n  key_ops: ['sign'],\n  ext: true,\n  n: base64url.baseEncode(n),\n  e: base64url.baseEncode(e),\n  d: base64url.baseEncode(d),\n  p: base64url.baseEncode(p),\n  q: base64url.baseEncode(q),\n  dp: base64url.baseEncode(dp),\n  dq: base64url.baseEncode(dq),\n  qi: base64url.baseEncode(qi),\n})\n\n/**\n * @param {JsonWebKey} key\n * @returns {RSAPrivateKey}\n */\nexport const fromJWK = ({ n, e, d, p, q, dp, dq, qi }) => ({\n  v: VERSION,\n  n: base64urlDecode(n),\n  e: base64urlDecode(e),\n  d: base64urlDecode(d),\n  p: base64urlDecode(p),\n  q: base64urlDecode(q),\n  dp: base64urlDecode(dp),\n  dq: base64urlDecode(dq),\n  qi: base64urlDecode(qi),\n})\n\n/**\n * @param {RSAPrivateKey} key\n */\nexport const toPKCS8 = key => PKCS8.encode(encode(key))\n\n/**\n * @param {API.ByteView<PKCS8.PrivateKeyInfo>} info\n */\nexport const fromPKCS8 = info => decode(PKCS8.decode(info))\n\n/**\n * @param {RSAPrivateKey} key\n */\nexport const toSPKI = key => SPKI.encode(PublicKey.encode(key))\n\n/**\n *\n * @param {string|undefined} input\n * @returns\n */\nconst base64urlDecode = (input = '') => base64url.baseDecode(input)\n", "import * as ed25519 from './ed25519.js'\nimport * as RSA from './rsa.js'\nimport * as Absentee from './absentee.js'\nexport * from './multiformat.js'\nexport const Verifier = ed25519.Verifier.or(RSA.Verifier)\nexport const Signer = ed25519.or(RSA)\n\nexport { ed25519, RSA, Absentee }\n", "/**\n * UCAN core capabilities.\n */\n\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport * as API from '@ucanto/interface'\nimport { equalWith, equal, and, checkLink } from './utils.js'\n\nexport const UCANLink =\n  /** @type {Schema.Schema<API.UCANLink, unknown>} */\n  (Schema.link({ version: 1 }))\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `store/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const ucan = capability({\n  can: 'ucan/*',\n  with: Schema.did(),\n  derives: equalWith,\n})\n\n/**\n * `ucan/revoke` capability is a replacement for the\n * [UCAN Revocation](https://github.com/ucan-wg/spec#66-revocation) that had\n * been proposed to a UCAN working group and had a tentative support from\n * members.\n *\n * Capability can be used to revoke `nb.ucan` authorization from all proofs\n * chains that lead to the UCAN issued or being delegated to the principal\n * identified by the `with` field. Note that revoked UCAN MUST continue to\n * be valid in the invocation where proof chain does not lead to the principal\n * identified by the `with` field.\n */\nexport const revoke = capability({\n  can: 'ucan/revoke',\n  /**\n   * DID of the principal authorizing revocation.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * UCAN being revoked from all proof chains that lead to the UCAN that is\n     * either issued (iss) by or delegated to (aud) the principal identified\n     * by the `with` field.\n     */\n    ucan: UCANLink,\n    /**\n     * Proof chain illustrating the path from revoked UCAN to the one that is\n     * either issued (iss) by or delegated to (aud) the principal identified\n     * by the `with` field.\n     *\n     * If the UCAN being revoked is either issued (iss) by or delegated to (aud)\n     * the principal identified by the `with` field no `proof` is required and\n     * it can be omitted or set to an empty array.\n     *\n     * It is RECOMMENDED that `proof` is provided in all other cases otherwise\n     * it MAY not be possible to verify that revoking principal is a participant\n     * in the proof chain.\n     */\n    proof: UCANLink.array().optional(),\n  }),\n  derives: (claim, from) =>\n    // With field MUST be the same\n    and(equalWith(claim, from)) ??\n    // UCAN being revoked MUST be the same\n    and(checkLink(claim.nb.ucan, from.nb.ucan, 'nb.ucan')) ??\n    // And proof chain MUST be the same\n    equal(\n      (claim.nb.proof ?? []).join('/'),\n      (from.nb.proof ?? []).join('/'),\n      'nb.proof'\n    ),\n})\n\n/**\n * `ucan/conclude` capability represents a receipt using a special UCAN capability.\n *\n * The UCAN invocation specification defines receipt record, that is cryptographically\n * signed description of the invocation output and requested effects. Receipt\n * structure is very similar to UCAN except it has no notion of expiry nor it is\n * possible to delegate ability to issue receipt to another principal.\n */\nexport const conclude = capability({\n  can: 'ucan/conclude',\n  /**\n   * DID of the principal representing the Conclusion Authority.\n   * MUST be the DID of the audience of the ran invocation.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the content with the Receipt.\n     */\n    receipt: Schema.link(),\n  }),\n  derives: (claim, from) =>\n    // With field MUST be the same\n    and(equalWith(claim, from)) ||\n    and(checkLink(claim.nb.receipt, from.nb.receipt, 'nb.receipt')) ||\n    ok({}),\n})\n\n/**\n * Issued by trusted authority (usually the one handling invocation) that attest\n * that specific UCAN delegation has been considered authentic.\n *\n * @see https://github.com/storacha/specs/blob/main/w3-session.md#authorization-session\n * \n * @example\n * ```js\n * {\n    iss: \"did:web:web3.storage\",\n    aud: \"did:key:z6Mkk89bC3JrVqKie71YEcc5M1SMVxuCgNx6zLZ8SYJsxALi\",\n    att: [{\n      \"with\": \"did:web:web3.storage\",\n      \"can\": \"ucan/attest\",\n      \"nb\": {\n        \"proof\": {\n          \"/\": \"bafyreifer23oxeyamllbmrfkkyvcqpujevuediffrpvrxmgn736f4fffui\"\n        }\n      }\n    }],\n    exp: null\n    sig: \"...\"\n  }\n * ```\n */\nexport const attest = capability({\n  can: 'ucan/attest',\n  // Should be web3.storage DID\n  with: Schema.did(),\n  nb: Schema.struct({\n    // UCAN delegation that is being attested.\n    proof: Schema.link({ version: 1 }),\n  }),\n  derives: (claim, from) =>\n    // With field MUST be the same\n    and(equalWith(claim, from)) ??\n    // UCAN link MUST be the same\n    checkLink(claim.nb.proof, from.nb.proof, 'nb.proof'),\n})\n", "/**\n * Blob Capabilities.\n *\n * Blob is a fixed size byte array addressed by the multihash.\n * Usually blobs are used to represent set of IPLD blocks at different byte ranges.\n *\n * These can be imported directly with:\n * ```js\n * import * as Blob from '@web3-storage/capabilities/blob'\n * ```\n *\n * @module\n */\nimport { equals } from 'uint8arrays/equals'\nimport { capability, Schema, fail, ok } from '@ucanto/validator'\nimport { equalBlob, equalWith, SpaceDID } from './utils.js'\n\n/**\n * Agent capabilities for Blob protocol\n */\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `space/blob/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const blob = capability({\n  can: 'space/blob/*',\n  /**\n   * DID of the (memory) space where Blob is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * Blob description for being ingested by the service.\n */\nexport const content = Schema.struct({\n  /**\n   * A multihash digest of the blob payload bytes, uniquely identifying blob.\n   */\n  digest: Schema.bytes(),\n  /**\n   * Number of bytes contained by this blob. Service will provision write target\n   * for this exact size. Attempt to write a larger Blob file will fail.\n   */\n  size: Schema.integer(),\n})\n\n/**\n * `space/blob/add` capability allows agent to store a Blob into a (memory) space\n * identified by did:key in the `with` field. Agent should compute blob multihash\n * and size and provide it under `nb.blob` field, allowing a service to provision\n * a write location for the agent to PUT desired Blob into.\n */\nexport const add = capability({\n  can: 'space/blob/add',\n  /**\n   * DID of the (memory) space where Blob is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Blob to be added on the space.\n     */\n    blob: content,\n  }),\n  derives: equalBlob,\n})\n\n/**\n * Capability can be used to remove the stored Blob from the (memory)\n * space identified by `with` field.\n */\nexport const remove = capability({\n  can: 'space/blob/remove',\n  /**\n   * DID of the (memory) space where Blob is stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A multihash digest of the blob payload bytes, uniquely identifying blob.\n     */\n    digest: Schema.bytes(),\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(\n        `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n      )\n    } else if (\n      delegated.nb.digest &&\n      !equals(delegated.nb.digest, claimed.nb.digest)\n    ) {\n      return fail(\n        `Link ${\n          claimed.nb.digest ? `${claimed.nb.digest}` : ''\n        } violates imposed ${delegated.nb.digest} constraint.`\n      )\n    }\n    return ok({})\n  },\n})\n\n/**\n * Capability can be invoked to request a list of stored Blobs in the\n * (memory) space identified by `with` field.\n */\nexport const list = capability({\n  can: 'space/blob/list',\n  /**\n   * DID of the (memory) space where Blobs to be listed are stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A pointer that can be moved back and forth on the list.\n     * It can be used to paginate a list for instance.\n     */\n    cursor: Schema.string().optional(),\n    /**\n     * Maximum number of items per page.\n     */\n    size: Schema.integer().optional(),\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(\n        `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n      )\n    }\n    return ok({})\n  },\n})\n\n/**\n * Capability can be used to get the stored Blob from the (memory)\n * space identified by `with` field.\n */\nexport const get = capability({\n  can: 'space/blob/get/0/1',\n  /**\n   * DID of the (memory) space where Blob is stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A multihash digest of the blob payload bytes, uniquely identifying blob.\n     */\n    digest: Schema.bytes(),\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(\n        `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n      )\n    } else if (\n      delegated.nb.digest &&\n      !equals(delegated.nb.digest, claimed.nb.digest)\n    ) {\n      return fail(\n        `Link ${\n          claimed.nb.digest ? `${claimed.nb.digest}` : ''\n        } violates imposed ${delegated.nb.digest} constraint.`\n      )\n    }\n    return ok({})\n  },\n})\n\n// \u26A0\uFE0F We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema }\n", "import { capability, Schema, Link, ok } from '@ucanto/validator'\nimport { content } from '../blob.js'\nimport {\n  equalBlob,\n  equalWith,\n  SpaceDID,\n  and,\n  equal,\n  checkLink,\n  Await,\n} from '../utils.js'\n\n/**\n * Service capabilities for Blob protocol\n */\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `web3.storage/blob/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const blob = capability({\n  can: 'web3.storage/blob/*',\n  /**\n   * DID of the (memory) space where Blob is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * `web3.storage/blob//allocate` capability can be invoked to create a memory\n * address where blob content can be written via HTTP PUT request.\n */\nexport const allocate = capability({\n  can: 'web3.storage/blob/allocate',\n  /**\n   * Provider DID.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * Blob to allocate on the space.\n     */\n    blob: content,\n    /**\n     * The Link for an Add Blob task, that caused an allocation\n     */\n    cause: Link,\n    /**\n     * DID of the user space where allocation takes place\n     */\n    space: SpaceDID,\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(equalBlob(claim, from)) ||\n      and(checkLink(claim.nb.cause, from.nb.cause, 'cause')) ||\n      and(equal(claim.nb.space, from.nb.space, 'space')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * `blob/accept` capability invocation should either succeed when content is\n * delivered on allocated address or fail if no content is allocation expires\n * without content being delivered.\n */\nexport const accept = capability({\n  can: 'web3.storage/blob/accept',\n  /**\n   * Provider DID.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * Blob to accept.\n     */\n    blob: content,\n    /**\n     * Content location commitment time to live, which will be encoded as expiry of the issued location claim.\n     */\n    ttl: Schema.integer().optional(),\n    /**\n     * DID of the user space where allocation took place\n     */\n    space: SpaceDID,\n    /**\n     * This task is blocked on `http/put` receipt available\n     */\n    _put: Await,\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(equalBlob(claim, from)) ||\n      and(equal(claim.nb.ttl, from.nb.ttl, 'ttl')) ||\n      and(equal(claim.nb.space, from.nb.space, 'space')) ||\n      ok({})\n    )\n  },\n})\n\n// \u26A0\uFE0F We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema, Link }\n", "/**\n * HTTP Capabilities.\n *\n * These can be imported directly with:\n * ```js\n * import * as HTTP from '@web3-storage/capabilities/http'\n * ```\n *\n * @module\n */\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport { content } from './blob.js'\nimport { equal, equalBody, equalWith, SpaceDID, Await, and } from './utils.js'\n\n/**\n * `http/put` capability invocation MAY be performed by any authorized agent on behalf of the subject\n * as long as they have referenced `body` content to do so.\n */\nexport const put = capability({\n  can: 'http/put',\n  /**\n   * DID of the (memory) space where Blob is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Description of body to send (digest/size).\n     */\n    body: content,\n    /**\n     * HTTP(S) location that can receive blob content via HTTP PUT request.\n     */\n    url: Schema.string().or(Await),\n    /**\n     * HTTP headers.\n     */\n    headers: Schema.dictionary({ value: Schema.string() }).or(Await),\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(equalBody(claim, from)) ||\n      and(equal(claim.nb.url, from.nb, 'url')) ||\n      and(equal(claim.nb.headers, from.nb, 'headers')) ||\n      ok({})\n    )\n  },\n})\n", null, null, null, null, null, null, "/**\n * Index Capabilities.\n *\n * W3 Indexing protocol allows authorized agents to submit verifiable claims\n * about content-addressed data to be published on the InterPlanetary Network\n * Indexer (IPNI), making it publicly queryable.\n *\n * These can be imported directly with:\n * ```js\n * import * as Index from '@web3-storage/capabilities/index'\n * ```\n *\n * @module\n */\nimport { CAR } from '@ucanto/core'\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport { equalWith, SpaceDID, and, equal } from '../utils.js'\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derive any `space/index/` prefixed capability for the space identified by the DID\n * in the `with` field.\n */\nexport const index = capability({\n  can: 'space/index/*',\n  /** DID of the space where indexed data is stored. */\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * `space/index/add` capability allows an agent to submit verifiable claims\n * about content-addressed data to be published on the InterPlanetary Network\n * Indexer (IPNI), making it publicly queryable.\n */\nexport const add = capability({\n  can: 'space/index/add',\n  /** DID of the space where indexed data is stored. */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /** Content Archive (CAR) containing the `Index`. */\n    index: Schema.link({ code: CAR.code, version: 1 }),\n  }),\n  derives: (claimed, delegated) =>\n    and(equalWith(claimed, delegated)) ||\n    and(equal(claimed.nb.index, delegated.nb.index, 'index')) ||\n    ok({}),\n})\n\n// \u26A0\uFE0F We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema }\n", null, null, "/**\n * Upload Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Account from '@web3-storage/capabilities/upload'\n * ```\n *\n * @module\n */\nimport { capability, Link, Schema, ok } from '@ucanto/validator'\nimport { codec as CAR } from '@ucanto/transport/car'\nimport { equalWith, and, equal, SpaceDID } from './utils.js'\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `upload/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const upload = capability({\n  can: 'upload/*',\n  /**\n   * DID of the (memory) space where upload is add to the\n   * upload list.\n   */\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * Schema representing a link (a.k.a CID) to a CAR file. Enforces CAR codec code and CID v1.\n */\nconst CARLink = Link.match({ code: CAR.code, version: 1 })\n\n/**\n * Capability allows an agent to add an arbitrary DAG (root) to the upload list\n * of the specified (memory) space (identified by did:key in the `with` field).\n * It is recommended to provide an optional list of shard links that contain\n * fragments of this DAG, as it allows system to optimize block discovery, it is\n * also a way to communicate DAG partiality - this upload contains partial DAG\n * identified by the given `root`.\n *\n * Usually when agent wants to upload a DAG it will encode it as a one or more\n * CAR files (shards) and invoke `store/add` capability for each one. Once all\n * shards are stored it will invoke `upload/add` capability (providing link to\n * a DAG root and all the shards) to add it the upload list.\n *\n * That said `upload/add` could be invoked without invoking `store/add`s e.g.\n * because another (memory) space may already have those CARs.\n *\n * Note: If DAG with the given root is already in the upload list, invocation\n * will simply update `shards` to be a union of existing and new shards.\n */\nexport const add = capability({\n  can: 'upload/add',\n  /**\n   * DID of the (memory) space where uploaded is added.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Root CID of the DAG to be added to the upload list.\n     */\n    root: Link,\n    /**\n     * CIDs to the CAR files that contain blocks of the DAG.\n     */\n    shards: CARLink.array().optional(),\n  }),\n  derives: (self, from) => {\n    return (\n      and(equalWith(self, from)) ||\n      and(equal(self.nb.root, from.nb.root, 'root')) ||\n      and(equal(self.nb.shards, from.nb.shards, 'shards')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability to get upload metadata by root CID.\n * Use to check for inclusion, or find the shards for a root.\n *\n * `nb.root` is optional to allow delegation of `upload/get`\n * capability for any root. If root is specified, then the\n * capability only allows a get for that single cid.\n *\n * When used as as an invocation, `nb.root` must be specified.\n */\nexport const get = capability({\n  can: 'upload/get',\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Root CID of the DAG to fetch upload info about.\n     */\n    root: Link.optional(),\n  }),\n  derives: (self, from) => {\n    const res = equalWith(self, from)\n    if (res.error) {\n      return res\n    }\n    if (!from.nb.root) {\n      return res\n    }\n    // root must match if specified in the proof\n    return equal(self.nb.root, from.nb.root, 'root')\n  },\n})\n\n/**\n * Capability removes an upload (identified by it's root CID) from the upload\n * list. Please note that removing an upload does not delete corresponding shards\n * from the store, however that could be done via `store/remove` invocations.\n */\nexport const remove = capability({\n  can: 'upload/remove',\n  /**\n   * DID of the (memory) space where uploaded is removed from.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Root CID of the DAG to be removed from the upload list.\n     */\n    root: Link,\n  }),\n  derives: (self, from) => {\n    return (\n      and(equalWith(self, from)) ||\n      and(equal(self.nb.root, from.nb.root, 'root')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability can be invoked to request a list of uploads in the (memory) space\n * identified by the `with` field.\n */\nexport const list = capability({\n  can: 'upload/list',\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A pointer that can be moved back and forth on the list.\n     * It can be used to paginate a list for instance.\n     */\n    cursor: Schema.string().optional(),\n    /**\n     * Maximum number of items per page.\n     */\n    size: Schema.integer().optional(),\n    /**\n     * If true, return page of results preceding cursor. Defaults to false.\n     */\n    pre: Schema.boolean().optional(),\n  }),\n})\n\nexport const all = add.or(remove).or(list)\n\n// \u26A0\uFE0F We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Link, Schema }\n", null, null, null, null, null, "import * as PB from \"@ipld/dag-pb\"\nimport * as UnixFS from \"./unixfs.js\"\nimport { NodeType } from \"./unixfs.js\"\nimport { Data } from \"../gen/unixfs.js\"\n\nexport * from \"./unixfs.js\"\n\n/** @type {ReadonlyArray<any>} */\nconst EMPTY = Object.freeze([])\nconst EMPTY_BUFFER = new Uint8Array(0)\n\nconst BLANK = Object.freeze({})\nexport const DEFAULT_FILE_MODE = parseInt(\"0644\", 8)\nexport const DEFAULT_DIRECTORY_MODE = parseInt(\"0755\", 8)\n\nexport const code = PB.code\nexport const name = \"UnixFS\"\n\n/**\n * @param {UnixFS.IData} data\n * @param {ReadonlyArray<UnixFS.PBLink>} links\n */\nconst encodePB = (data, links) => {\n  Object(globalThis).debug && console.log({ data, links })\n\n  return PB.encode(\n    // We run through prepare as links need to be sorted by name which it will\n    // do.\n    PB.prepare({\n      Data: Data.encode(data).finish(),\n      // We can cast to mutable array as we know no mutation occurs there\n      Links:\n        /** @type {PB.PBLink[]} */ (links),\n    })\n  )\n}\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.Raw}\n */\nexport const createRaw = content => ({\n  type: NodeType.Raw,\n  content,\n})\n\n/**\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.SimpleFile}\n */\nexport const createEmptyFile = metadata =>\n  createSimpleFile(EMPTY_BUFFER, metadata)\n\n/**\n * @param {Uint8Array} content\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.SimpleFile}\n */\nexport const createSimpleFile = (content, metadata) => ({\n  type: NodeType.File,\n  layout: \"simple\",\n  content,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.FileChunk}\n */\nexport const createFileChunk = content => ({\n  type: NodeType.File,\n  layout: \"simple\",\n  content,\n})\n\n/**\n * @param {UnixFS.FileLink[]} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.AdvancedFile}\n */\nexport const createAdvancedFile = (parts, metadata) => ({\n  type: NodeType.File,\n  layout: \"advanced\",\n  parts,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.FileLink[]} parts\n * @returns {UnixFS.FileShard}\n */\nexport const createFileShard = parts => ({\n  type: NodeType.File,\n  layout: \"advanced\",\n  parts,\n})\n\n/**\n * @deprecated\n * @param {Uint8Array} content\n * @param {UnixFS.FileLink[]} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ComplexFile}\n */\nexport const createComplexFile = (content, parts, metadata) => ({\n  type: NodeType.File,\n  layout: \"complex\",\n  content,\n  parts,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.DirectoryEntryLink[]} entries\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.FlatDirectory}\n */\nexport const createFlatDirectory = (entries, metadata) => ({\n  type: NodeType.Directory,\n  metadata: decodeMetadata(metadata),\n  entries,\n})\n\n/**\n * @param {UnixFS.ShardedDirectoryLink[]} entries\n * @param {Uint8Array} bitfield\n * @param {number} fanout\n * @param {number} hashType\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ShardedDirectory}\n */\nexport const createShardedDirectory = (\n  entries,\n  bitfield,\n  fanout,\n  hashType,\n  metadata = BLANK\n) => ({\n  type: NodeType.HAMTShard,\n  bitfield,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  entries,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.ShardedDirectoryLink[]} entries\n * @param {Uint8Array} bitfield\n * @param {number} fanout\n * @param {number} hashType\n * @returns {UnixFS.DirectoryShard}\n */\nexport const createDirectoryShard = (entries, bitfield, fanout, hashType) => ({\n  type: NodeType.HAMTShard,\n  bitfield,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  entries,\n})\n\n/**\n *\n * @param {Uint8Array} content\n * @returns {UnixFS.ByteView<UnixFS.Raw>}\n */\nexport const encodeRaw = content =>\n  encodePB(\n    {\n      Type: NodeType.Raw,\n      // TODO:\n      Data: content.byteLength > 0 ? content : undefined,\n      filesize: content.byteLength,\n      // @ts-ignore\n      blocksizes: EMPTY,\n    },\n    []\n  )\n\n/**\n * @param {UnixFS.File|UnixFS.FileChunk|UnixFS.FileShard} node\n * @param {boolean} [ignoreMetadata]\n * @returns {UnixFS.ByteView<UnixFS.SimpleFile|UnixFS.AdvancedFile|UnixFS.ComplexFile>}\n */\nexport const encodeFile = (node, ignoreMetadata = false) => {\n  const metadata = ignoreMetadata ? BLANK : Object(node).metadata\n  switch (node.layout) {\n    case \"simple\":\n      return encodeSimpleFile(node.content, metadata)\n    case \"advanced\":\n      return encodeAdvancedFile(node.parts, metadata)\n    case \"complex\":\n      return encodeComplexFile(node.content, node.parts, metadata)\n    default:\n      throw new TypeError(\n        `File with unknown layout \"${Object(node).layout}\" was passed`\n      )\n  }\n}\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.ByteView<UnixFS.FileChunk>}\n */\nexport const encodeFileChunk = content => encodeSimpleFile(content, BLANK)\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @returns {UnixFS.ByteView<UnixFS.FileShard>}\n */\nexport const encodeFileShard = parts =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      blocksizes: parts.map(contentByteLength),\n      filesize: cumulativeContentByteLength(parts),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.AdvancedFile>}\n */\nexport const encodeAdvancedFile = (parts, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      blocksizes: parts.map(contentByteLength),\n      filesize: cumulativeContentByteLength(parts),\n\n      ...encodeMetadata(metadata),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {UnixFS.DAGLink} dag\n * @returns {UnixFS.PBLink}\n */\nexport const encodeLink = dag => ({\n  Name: \"\",\n  Tsize: dag.dagByteLength,\n  // @ts-ignore - @see https://github.com/multiformats/js-multiformats/pull/161\n  Hash: dag.cid,\n})\n\n/**\n * @param {Uint8Array} content\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.SimpleFile>}\n */\n\nexport const encodeSimpleFile = (content, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      // adding empty file to both go-ipfs and js-ipfs produces block in\n      // which `Data` is omitted but filesize and blocksizes are present.\n      // For the sake of hash consistency we do the same.\n      Data: content.byteLength > 0 ? content : undefined,\n      filesize: content.byteLength,\n      blocksizes: [],\n      ...encodeMetadata(metadata),\n    },\n    []\n  )\n\n/**\n *\n * @param {Uint8Array} content\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.ComplexFile>}\n */\nexport const encodeComplexFile = (content, parts, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      Data: content,\n      filesize: content.byteLength + cumulativeContentByteLength(parts),\n      blocksizes: parts.map(contentByteLength),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {UnixFS.FlatDirectory} node\n * @returns {UnixFS.ByteView<UnixFS.FlatDirectory>}\n */\nexport const encodeDirectory = node =>\n  encodePB(\n    {\n      Type: node.type,\n      ...encodeDirectoryMetadata(node.metadata || BLANK),\n    },\n    node.entries.map(encodeNamedLink)\n  )\n\n/**\n * @param {UnixFS.ShardedDirectory|UnixFS.DirectoryShard} node\n * @returns {UnixFS.ByteView<UnixFS.ShardedDirectory>}\n */\nexport const encodeHAMTShard = ({\n  bitfield,\n  fanout,\n  hashType,\n  entries,\n  metadata = BLANK,\n}) =>\n  encodePB(\n    {\n      Type: NodeType.HAMTShard,\n      Data: bitfield.byteLength > 0 ? bitfield : undefined,\n      fanout: readFanout(fanout),\n      hashType: readInt(hashType),\n\n      ...encodeDirectoryMetadata(metadata),\n    },\n    entries.map(encodeNamedLink)\n  )\n\n/**\n * @param {number} n\n * @returns {number}\n */\nconst readFanout = n => {\n  if (Math.log2(n) % 1 === 0) {\n    return n\n  } else {\n    throw new TypeError(\n      `Expected hamt size to be a power of two instead got ${n}`\n    )\n  }\n}\n\n/**\n * @param {number} n\n * @returns {number}\n */\n\nconst readInt = n => {\n  if (Number.isInteger(n)) {\n    return n\n  } else {\n    throw new TypeError(`Expected an integer value instead got ${n}`)\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n */\nconst readData = bytes => (bytes.byteLength > 0 ? bytes : undefined)\n\n/**\n * @param {Uint8Array} path\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.Symlink}\n */\nexport const createSymlink = (path, metadata = BLANK) => ({\n  type: NodeType.Symlink,\n  content: path,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.Symlink} node\n * @param {boolean} [ignoreMetadata]\n * @returns {UnixFS.ByteView<UnixFS.Symlink>}\n */\nexport const encodeSymlink = (node, ignoreMetadata = false) => {\n  const metadata = ignoreMetadata ? BLANK : Object(node).metadata\n  // We do not include filesize on symlinks because that is what go-ipfs does\n  // when doing `ipfs add mysymlink`. js-ipfs on the other hand seems to store\n  // it, here we choose to follow go-ipfs\n  // @see https://explore.ipld.io/#/explore/QmPZ1CTc5fYErTH2XXDGrfsPsHicYXtkZeVojGycwAfm3v\n  // @see https://github.com/ipfs/js-ipfs-unixfs/issues/195\n  return encodePB(\n    {\n      Type: NodeType.Symlink,\n      Data: node.content,\n      ...encodeMetadata(metadata || BLANK),\n    },\n    []\n  )\n}\n\n/**\n * @template {UnixFS.Node} T\n * @param {T} node\n * @param {boolean} root\n */\nexport const encode = (node, root = true) => {\n  switch (node.type) {\n    case NodeType.Raw:\n      return encodeRaw(node.content)\n    case NodeType.File:\n      return encodeFile(node)\n    case NodeType.Directory:\n      return encodeDirectory(node)\n    case NodeType.HAMTShard:\n      return encodeHAMTShard(node)\n    case NodeType.Symlink:\n      return encodeSymlink(node)\n    default:\n      throw new Error(`Unknown node type ${Object(node).type}`)\n  }\n}\n\n/**\n * @param {UnixFS.ByteView<UnixFS.Node>} bytes\n * @returns {UnixFS.Node}\n */\nexport const decode = bytes => {\n  const pb = PB.decode(bytes)\n  const message = Data.decode(/** @type {Uint8Array} */ (pb.Data))\n\n  const {\n    Type: type,\n    Data: data,\n    mtime,\n    mode,\n    blocksizes,\n    ...rest\n  } = Data.toObject(message, {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false,\n  })\n  const metadata = {\n    ...(mode && { mode }),\n    ...decodeMtime(mtime),\n  }\n  /** @type {UnixFS.PBLink[]} */\n  const links = pb.Links\n\n  switch (message.Type) {\n    case NodeType.Raw:\n      return createRaw(data)\n    case NodeType.File:\n      if (links.length === 0) {\n        return new SimpleFileView(data, metadata)\n      } else if (data.byteLength === 0) {\n        return new AdvancedFileView(\n          decodeFileLinks(rest.blocksizes, links),\n          metadata\n        )\n      } else {\n        return new ComplexFileView(\n          data,\n          decodeFileLinks(rest.blocksizes, links),\n          metadata\n        )\n      }\n    case NodeType.Directory:\n      return createFlatDirectory(decodeDirectoryLinks(links), metadata)\n    case NodeType.HAMTShard:\n      return createShardedDirectory(\n        decodeDirectoryLinks(links),\n        data || EMPTY_BUFFER,\n        rest.fanout,\n        rest.hashType,\n        metadata\n      )\n    case NodeType.Symlink:\n      return createSymlink(data, metadata)\n    default:\n      throw new TypeError(`Unsupported node type ${message.Type}`)\n  }\n}\n\n/**\n * @param {UnixFS.UnixTime|undefined} mtime\n */\nconst decodeMtime = mtime =>\n  mtime == null\n    ? undefined\n    : {\n        mtime: { secs: mtime.Seconds, nsecs: mtime.FractionalNanoseconds || 0 },\n      }\n\n/**\n * @param {NodeType} type\n * @param {number[]|undefined} blocksizes\n */\nconst decodeBlocksizes = (type, blocksizes) => {\n  switch (type) {\n    case NodeType.File:\n      return blocksizes && blocksizes.length > 0 ? { blocksizes } : undefined\n    default:\n      return undefined\n  }\n}\n\n/**\n *\n * @param {number[]} blocksizes\n * @param {UnixFS.PBLink[]} links\n * @returns {UnixFS.FileLink[]}\n */\n\nconst decodeFileLinks = (blocksizes, links) => {\n  const parts = []\n  const length = blocksizes.length\n  let n = 0\n  while (n < length) {\n    parts.push(\n      /** @type {UnixFS.FileLink} */ ({\n        cid: links[n].Hash,\n        dagByteLength: links[n].Tsize || 0,\n        contentByteLength: blocksizes[n],\n      })\n    )\n  }\n  return parts\n}\n\n/**\n * @param {UnixFS.PBLink[]} links\n * @returns {UnixFS.DirectoryEntryLink[]}\n */\nconst decodeDirectoryLinks = links =>\n  links.map(\n    link =>\n      /** @type {UnixFS.DirectoryEntryLink} */ ({\n        cid: link.Hash,\n        name: link.Name || \"\",\n        dagByteLength: link.Tsize || 0,\n      })\n  )\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} links\n * @returns {number}\n */\nexport const cumulativeContentByteLength = links =>\n  links.reduce((size, link) => size + link.contentByteLength, 0)\n\n/**\n * @param {Uint8Array} root\n * @param {ReadonlyArray<UnixFS.DAGLink>} links\n * @returns {number}\n */\nexport const cumulativeDagByteLength = (root, links) =>\n  links.reduce((size, link) => size + link.dagByteLength, root.byteLength)\n\n/**\n *\n * @param {UnixFS.FileLink} link\n */\nconst contentByteLength = link => link.contentByteLength\n\n/**\n * @param {UnixFS.NamedDAGLink<unknown>} link\n * @returns {UnixFS.PBLink}\n */\nconst encodeNamedLink = ({ name, dagByteLength, cid }) => ({\n  Name: name,\n  Tsize: dagByteLength,\n  Hash: cid,\n})\n\n/**\n * @param {UnixFS.Metadata} metadata\n */\nexport const encodeDirectoryMetadata = metadata =>\n  encodeMetadata(metadata, DEFAULT_DIRECTORY_MODE)\n\n/**\n * @param {UnixFS.Metadata} metadata\n * @param {UnixFS.Mode} defaultMode\n */\nexport const encodeMetadata = (\n  { mode, mtime },\n  defaultMode = DEFAULT_FILE_MODE\n) => ({\n  mode: mode != null ? encodeMode(mode, defaultMode) : undefined,\n  mtime: mtime != null ? encodeMTime(mtime) : undefined,\n})\n\n/**\n * @param {UnixFS.Metadata} [data]\n */\nexport const decodeMetadata = data =>\n  data == null\n    ? BLANK\n    : {\n        ...(data.mode == null ? undefined : { mode: decodeMode(data.mode) }),\n        ...(data.mtime == null ? undefined : { mtime: data.mtime }),\n      }\n\n/**\n * @param {UnixFS.MTime} mtime\n */\nconst encodeMTime = mtime => {\n  return mtime == null\n    ? undefined\n    : mtime.nsecs !== 0\n    ? { Seconds: mtime.secs, FractionalNanoseconds: mtime.nsecs }\n    : { Seconds: mtime.secs }\n}\n\n/**\n * @param {number} specifiedMode\n * @param {number} defaultMode\n */\nexport const encodeMode = (specifiedMode, defaultMode) => {\n  const mode = specifiedMode == null ? undefined : decodeMode(specifiedMode)\n  return mode === defaultMode || mode == null ? undefined : mode\n}\n\n/**\n * @param {UnixFS.Mode} mode\n * @returns {UnixFS.Mode}\n */\nconst decodeMode = mode => (mode & 0xfff) | (mode & 0xfffff000)\n\n/**\n * @param {{content?: Uint8Array, parts?: ReadonlyArray<UnixFS.FileLink>, metadata?: UnixFS.Metadata }} node\n * @returns {UnixFS.SimpleFile|UnixFS.AdvancedFile|UnixFS.ComplexFile}\n */\nexport const matchFile = ({\n  content = EMPTY_BUFFER,\n  parts = EMPTY,\n  metadata = BLANK,\n  ...rest\n}) => {\n  if (parts.length === 0) {\n    return new SimpleFileView(content, metadata)\n  } else if (content.byteLength === 0) {\n    return new AdvancedFileView(parts, metadata)\n  } else {\n    return new ComplexFileView(content, parts, metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.SimpleFile}\n */\nclass SimpleFileView {\n  /**\n   * @param {Uint8Array} content\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(content, metadata) {\n    this.content = content\n    this.metadata = metadata\n    /**\n     * @readonly\n     * @type {\"simple\"}\n     */\n    this.layout = \"simple\"\n    /**\n     * @readonly\n     * @type {NodeType.File}\n     */\n    this.type = NodeType.File\n  }\n\n  get filesize() {\n    return this.content.byteLength\n  }\n\n  encode() {\n    return encodeSimpleFile(this.content, this.metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.AdvancedFile}\n */\nclass AdvancedFileView {\n  /**\n   * @param {ReadonlyArray<UnixFS.FileLink>} parts\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(parts, metadata) {\n    this.parts = parts\n    this.metadata = metadata\n  }\n  /** @type {\"advanced\"} */\n  get layout() {\n    return \"advanced\"\n  }\n\n  /**\n   * @returns {NodeType.File}\n   */\n  get type() {\n    return NodeType.File\n  }\n  get fileSize() {\n    return cumulativeContentByteLength(this.parts)\n  }\n  get blockSizes() {\n    return this.parts.map(contentByteLength)\n  }\n\n  encode() {\n    return encodeAdvancedFile(this.parts, this.metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.ComplexFile}\n */\nclass ComplexFileView {\n  /**\n   * @param {Uint8Array} content\n   * @param {ReadonlyArray<UnixFS.FileLink>} parts\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(content, parts, metadata) {\n    this.content = content\n    this.parts = parts\n    this.metadata = metadata\n  }\n  /** @type {\"complex\"} */\n  get layout() {\n    return \"complex\"\n  }\n\n  /**\n   * @returns {NodeType.File}\n   */\n  get type() {\n    return NodeType.File\n  }\n  get fileSize() {\n    return this.content.byteLength + cumulativeContentByteLength(this.parts)\n  }\n  get blockSizes() {\n    return this.parts.map(contentByteLength)\n  }\n\n  encode() {\n    return encodeComplexFile(this.content, this.parts, this.metadata)\n  }\n}\n\n/**\n * @param {UnixFS.File|UnixFS.Raw|UnixFS.FileChunk|UnixFS.FileShard|UnixFS.Symlink} node\n * @returns {number}\n */\nexport const filesize = node => {\n  switch (node.type) {\n    case NodeType.Raw:\n    case NodeType.Symlink:\n      return node.content.byteLength\n    case NodeType.File:\n      switch (node.layout) {\n        case \"simple\":\n          return node.content.byteLength\n        case \"advanced\":\n          return cumulativeContentByteLength(node.parts)\n        case \"complex\":\n          return (\n            node.content.byteLength + cumulativeContentByteLength(node.parts)\n          )\n      }\n    default:\n      return 0\n  }\n}\n", "const textDecoder = new TextDecoder()\n\n/**\n * @typedef {import('./interface.js').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface.js').RawPBNode} RawPBNode\n */\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[number, number]}\n */\nfunction decodeVarint (bytes, offset) {\n  let v = 0\n\n  for (let shift = 0; ; shift += 7) {\n    /* c8 ignore next 3 */\n    if (shift >= 64) {\n      throw new Error('protobuf: varint overflow')\n    }\n    /* c8 ignore next 3 */\n    if (offset >= bytes.length) {\n      throw new Error('protobuf: unexpected end of data')\n    }\n\n    const b = bytes[offset++]\n    v += shift < 28 ? (b & 0x7f) << shift : (b & 0x7f) * (2 ** shift)\n    if (b < 0x80) {\n      break\n    }\n  }\n  return [v, offset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[Uint8Array, number]}\n */\nfunction decodeBytes (bytes, offset) {\n  let byteLen\n  ;[byteLen, offset] = decodeVarint(bytes, offset)\n  const postOffset = offset + byteLen\n\n  /* c8 ignore next 3 */\n  if (byteLen < 0 || postOffset < 0) {\n    throw new Error('protobuf: invalid length')\n  }\n  /* c8 ignore next 3 */\n  if (postOffset > bytes.length) {\n    throw new Error('protobuf: unexpected end of data')\n  }\n\n  return [bytes.subarray(offset, postOffset), postOffset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} index\n * @returns {[number, number, number]}\n */\nfunction decodeKey (bytes, index) {\n  let wire\n  ;[wire, index] = decodeVarint(bytes, index)\n  // [wireType, fieldNum, newIndex]\n  return [wire & 0x7, wire >> 3, index]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBLink}\n */\nfunction decodeLink (bytes) {\n  /** @type {RawPBLink} */\n  const link = {}\n  const l = bytes.length\n  let index = 0\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (fieldNum === 1) {\n      if (link.Hash) {\n        throw new Error('protobuf: (PBLink) duplicate Hash section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`)\n      }\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Name before Hash')\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash')\n      }\n\n      [link.Hash, index] = decodeBytes(bytes, index)\n    } else if (fieldNum === 2) {\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Name section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`)\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name')\n      }\n\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      link.Name = textDecoder.decode(byts)\n    } else if (fieldNum === 3) {\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Tsize section')\n      }\n      if (wireType !== 0) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`)\n      }\n\n      [link.Tsize, index] = decodeVarint(bytes, index)\n    } else {\n      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBLink) unexpected end of data')\n  }\n\n  return link\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBNode}\n */\nexport function decodeNode (bytes) {\n  const l = bytes.length\n  let index = 0\n  /** @type {RawPBLink[]|void} */\n  let links = undefined // eslint-disable-line no-undef-init\n  let linksBeforeData = false\n  /** @type {Uint8Array|void} */\n  let data = undefined // eslint-disable-line no-undef-init\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (wireType !== 2) {\n      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`)\n    }\n\n    if (fieldNum === 1) {\n      if (data) {\n        throw new Error('protobuf: (PBNode) duplicate Data section')\n      }\n\n      [data, index] = decodeBytes(bytes, index)\n      if (links) {\n        linksBeforeData = true\n      }\n    } else if (fieldNum === 2) {\n      if (linksBeforeData) { // interleaved Links/Data/Links\n        throw new Error('protobuf: (PBNode) duplicate Links section')\n      } else if (!links) {\n        links = []\n      }\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      links.push(decodeLink(byts))\n    } else {\n      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBNode) unexpected end of data')\n  }\n\n  /** @type {RawPBNode} */\n  const node = {}\n  if (data) {\n    node.Data = data\n  }\n  node.Links = links || []\n  return node\n}\n", "const textEncoder = new TextEncoder()\nconst maxInt32 = 2 ** 32\nconst maxUInt32 = 2 ** 31\n\n/**\n * @typedef {import('./interface.js').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface.js').RawPBNode} RawPBNode\n */\n\n// the encoders work backward from the end of the bytes array\n\n/**\n * encodeLink() is passed a slice of the parent byte array that ends where this\n * link needs to end, so it packs to the right-most part of the passed `bytes`\n *\n * @param {RawPBLink} link\n * @param {Uint8Array} bytes\n * @returns {number}\n */\nfunction encodeLink (link, bytes) {\n  let i = bytes.length\n\n  if (typeof link.Tsize === 'number') {\n    if (link.Tsize < 0) {\n      throw new Error('Tsize cannot be negative')\n    }\n    if (!Number.isSafeInteger(link.Tsize)) {\n      throw new Error('Tsize too large for encoding')\n    }\n    i = encodeVarint(bytes, i, link.Tsize) - 1\n    bytes[i] = 0x18\n  }\n\n  if (typeof link.Name === 'string') {\n    const nameBytes = textEncoder.encode(link.Name)\n    i -= nameBytes.length\n    bytes.set(nameBytes, i)\n    i = encodeVarint(bytes, i, nameBytes.length) - 1\n    bytes[i] = 0x12\n  }\n\n  if (link.Hash) {\n    i -= link.Hash.length\n    bytes.set(link.Hash, i)\n    i = encodeVarint(bytes, i, link.Hash.length) - 1\n    bytes[i] = 0xa\n  }\n\n  return bytes.length - i\n}\n\n/**\n * Encodes a PBNode into a new byte array of precisely the correct size\n *\n * @param {RawPBNode} node\n * @returns {Uint8Array}\n */\nexport function encodeNode (node) {\n  const size = sizeNode(node)\n  const bytes = new Uint8Array(size)\n  let i = size\n\n  if (node.Data) {\n    i -= node.Data.length\n    bytes.set(node.Data, i)\n    i = encodeVarint(bytes, i, node.Data.length) - 1\n    bytes[i] = 0xa\n  }\n\n  if (node.Links) {\n    for (let index = node.Links.length - 1; index >= 0; index--) {\n      const size = encodeLink(node.Links[index], bytes.subarray(0, i))\n      i -= size\n      i = encodeVarint(bytes, i, size) - 1\n      bytes[i] = 0x12\n    }\n  }\n\n  return bytes\n}\n\n/**\n * work out exactly how many bytes this link takes up\n *\n * @param {RawPBLink} link\n * @returns\n */\nfunction sizeLink (link) {\n  let n = 0\n\n  if (link.Hash) {\n    const l = link.Hash.length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Name === 'string') {\n    const l = textEncoder.encode(link.Name).length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Tsize === 'number') {\n    n += 1 + sov(link.Tsize)\n  }\n\n  return n\n}\n\n/**\n * Work out exactly how many bytes this node takes up\n *\n * @param {RawPBNode} node\n * @returns {number}\n */\nfunction sizeNode (node) {\n  let n = 0\n\n  if (node.Data) {\n    const l = node.Data.length\n    n += 1 + l + sov(l)\n  }\n\n  if (node.Links) {\n    for (const link of node.Links) {\n      const l = sizeLink(link)\n      n += 1 + l + sov(l)\n    }\n  }\n\n  return n\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @param {number} v\n * @returns {number}\n */\nfunction encodeVarint (bytes, offset, v) {\n  offset -= sov(v)\n  const base = offset\n\n  while (v >= maxUInt32) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v /= 128\n  }\n\n  while (v >= 128) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v >>>= 7\n  }\n\n  bytes[offset] = v\n\n  return base\n}\n\n/**\n * size of varint\n *\n * @param {number} x\n * @returns {number}\n */\nfunction sov (x) {\n  if (x % 2 === 0) {\n    x++\n  }\n  return Math.floor((len64(x) + 6) / 7)\n}\n\n/**\n * golang math/bits, how many bits does it take to represent this integer?\n *\n * @param {number} x\n * @returns {number}\n */\nfunction len64 (x) {\n  let n = 0\n  if (x >= maxInt32) {\n    x = Math.floor(x / maxInt32)\n    n = 32\n  }\n  if (x >= (1 << 16)) {\n    x >>>= 16\n    n += 16\n  }\n  if (x >= (1 << 8)) {\n    x >>>= 8\n    n += 8\n  }\n  return n + len8tab[x]\n}\n\n// golang math/bits\nconst len8tab = [\n  0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8\n]\n", "import { CID } from 'multiformats/cid'\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\nconst pbNodeProperties = ['Data', 'Links']\nconst pbLinkProperties = ['Hash', 'Name', 'Tsize']\n\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {PBLink} a\n * @param {PBLink} b\n * @returns {number}\n */\nfunction linkComparator (a, b) {\n  if (a === b) {\n    return 0\n  }\n\n  const abuf = a.Name ? textEncoder.encode(a.Name) : []\n  const bbuf = b.Name ? textEncoder.encode(b.Name) : []\n\n  let x = abuf.length\n  let y = bbuf.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (abuf[i] !== bbuf[i]) {\n      x = abuf[i]\n      y = bbuf[i]\n      break\n    }\n  }\n\n  return x < y ? -1 : y < x ? 1 : 0\n}\n\n/**\n * @param {any} node\n * @param {string[]} properties\n * @returns {boolean}\n */\nfunction hasOnlyProperties (node, properties) {\n  return !Object.keys(node).some((p) => !properties.includes(p))\n}\n\n/**\n * Converts a CID, or a PBLink-like object to a PBLink\n *\n * @param {any} link\n * @returns {PBLink}\n */\nfunction asLink (link) {\n  if (typeof link.asCID === 'object') {\n    const Hash = CID.asCID(link)\n    if (!Hash) {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n    return { Hash }\n  }\n\n  if (typeof link !== 'object' || Array.isArray(link)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  const pbl = {}\n\n  if (link.Hash) {\n    let cid = CID.asCID(link.Hash)\n    try {\n      if (!cid) {\n        if (typeof link.Hash === 'string') {\n          cid = CID.parse(link.Hash)\n        } else if (link.Hash instanceof Uint8Array) {\n          cid = CID.decode(link.Hash)\n        }\n      }\n    } catch (/** @type {any} */ e) {\n      throw new TypeError(`Invalid DAG-PB form: ${e.message}`)\n    }\n\n    if (cid) {\n      pbl.Hash = cid\n    }\n  }\n\n  if (!pbl.Hash) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (typeof link.Name === 'string') {\n    pbl.Name = link.Name\n  }\n\n  if (typeof link.Tsize === 'number') {\n    pbl.Tsize = link.Tsize\n  }\n\n  return pbl\n}\n\n/**\n * @param {any} node\n * @returns {PBNode}\n */\nexport function prepare (node) {\n  if (node instanceof Uint8Array || typeof node === 'string') {\n    node = { Data: node }\n  }\n\n  if (typeof node !== 'object' || Array.isArray(node)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  /** @type {PBNode} */\n  const pbn = {}\n\n  if (node.Data !== undefined) {\n    if (typeof node.Data === 'string') {\n      pbn.Data = textEncoder.encode(node.Data)\n    } else if (node.Data instanceof Uint8Array) {\n      pbn.Data = node.Data\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  }\n\n  if (node.Links !== undefined) {\n    if (Array.isArray(node.Links)) {\n      pbn.Links = node.Links.map(asLink)\n      pbn.Links.sort(linkComparator)\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  } else {\n    pbn.Links = []\n  }\n\n  return pbn\n}\n\n/**\n * @param {PBNode} node\n */\nexport function validate (node) {\n  /*\n  type PBLink struct {\n    Hash optional Link\n    Name optional String\n    Tsize optional Int\n  }\n\n  type PBNode struct {\n    Links [PBLink]\n    Data optional Bytes\n  }\n  */\n  // @ts-ignore private property for TS\n  if (!node || typeof node !== 'object' || Array.isArray(node) || node instanceof Uint8Array || (node['/'] && node['/'] === node.bytes)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (!hasOnlyProperties(node, pbNodeProperties)) {\n    throw new TypeError('Invalid DAG-PB form (extraneous properties)')\n  }\n\n  if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {\n    throw new TypeError('Invalid DAG-PB form (Data must be bytes)')\n  }\n\n  if (!Array.isArray(node.Links)) {\n    throw new TypeError('Invalid DAG-PB form (Links must be a list)')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const link = node.Links[i]\n    // @ts-ignore private property for TS\n    if (!link || typeof link !== 'object' || Array.isArray(link) || link instanceof Uint8Array || (link['/'] && link['/'] === link.bytes)) {\n      throw new TypeError('Invalid DAG-PB form (bad link)')\n    }\n\n    if (!hasOnlyProperties(link, pbLinkProperties)) {\n      throw new TypeError('Invalid DAG-PB form (extraneous properties on link)')\n    }\n\n    if (link.Hash === undefined) {\n      throw new TypeError('Invalid DAG-PB form (link must have a Hash)')\n    }\n\n    // @ts-ignore private property for TS\n    if (link.Hash == null || !link.Hash['/'] || link.Hash['/'] !== link.Hash.bytes) {\n      throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)')\n    }\n\n    if (link.Name !== undefined && typeof link.Name !== 'string') {\n      throw new TypeError('Invalid DAG-PB form (link Name must be a string)')\n    }\n\n    if (link.Tsize !== undefined) {\n      if (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)')\n      }\n      if (link.Tsize < 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize cannot be negative)')\n      }\n    }\n\n    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {\n      throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)')\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {PBLink[]} [links=[]]\n * @returns {PBNode}\n */\nexport function createNode (data, links = []) {\n  return prepare({ Data: data, Links: links })\n}\n\n/**\n * @param {string} name\n * @param {number} size\n * @param {CID} cid\n * @returns {PBLink}\n */\nexport function createLink (name, size, cid) {\n  return asLink({ Hash: cid, Name: name, Tsize: size })\n}\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n", "import { CID } from 'multiformats/cid'\nimport { decodeNode } from './pb-decode.js'\nimport { encodeNode } from './pb-encode.js'\nimport { prepare, validate, createNode, createLink, toByteView } from './util.js'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\nexport const name = 'dag-pb'\nexport const code = 0x70\n\n/**\n * @param {PBNode} node\n * @returns {ByteView<PBNode>}\n */\nexport function encode (node) {\n  validate(node)\n\n  const pbn = {}\n  if (node.Links) {\n    pbn.Links = node.Links.map((l) => {\n      const link = {}\n      if (l.Hash) {\n        link.Hash = l.Hash.bytes // cid -> bytes\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n  if (node.Data) {\n    pbn.Data = node.Data\n  }\n\n  return encodeNode(pbn)\n}\n\n/**\n * @param {ByteView<PBNode> | ArrayBufferView<PBNode>} bytes\n * @returns {PBNode}\n */\nexport function decode (bytes) {\n  const buf = toByteView(bytes)\n  const pbn = decodeNode(buf)\n\n  const node = {}\n\n  if (pbn.Data) {\n    node.Data = pbn.Data\n  }\n\n  if (pbn.Links) {\n    node.Links = pbn.Links.map((l) => {\n      const link = {}\n      try {\n        link.Hash = CID.decode(l.Hash)\n      } catch (e) {}\n      if (!link.Hash) {\n        throw new Error('Invalid Hash field found in link, expected CID')\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n\n  return node\n}\n\nexport { prepare, validate, createNode, createLink }\n", "/*eslint-disable*/\nimport $protobuf from \"protobufjs/minimal.js\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots.unixfs || ($protobuf.roots.unixfs = {});\n\nexport const Data = $root.Data = (() => {\n\n    /**\n     * Properties of a Data.\n     * @exports IData\n     * @interface IData\n     * @property {Data.DataType} Type Data Type\n     * @property {Uint8Array|null} [Data] Data Data\n     * @property {number|null} [filesize] Data filesize\n     * @property {Array.<number>|null} [blocksizes] Data blocksizes\n     * @property {number|null} [hashType] Data hashType\n     * @property {number|null} [fanout] Data fanout\n     * @property {number|null} [mode] Data mode\n     * @property {IUnixTime|null} [mtime] Data mtime\n     */\n\n    /**\n     * Constructs a new Data.\n     * @exports Data\n     * @classdesc Represents a Data.\n     * @implements IData\n     * @constructor\n     * @param {IData=} [p] Properties to set\n     */\n    function Data(p) {\n        this.blocksizes = [];\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * Data Type.\n     * @member {Data.DataType} Type\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.Type = 0;\n\n    /**\n     * Data Data.\n     * @member {Uint8Array} Data\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.Data = $util.newBuffer([]);\n\n    /**\n     * Data filesize.\n     * @member {number} filesize\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.filesize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data blocksizes.\n     * @member {Array.<number>} blocksizes\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.blocksizes = $util.emptyArray;\n\n    /**\n     * Data hashType.\n     * @member {number} hashType\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.hashType = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data fanout.\n     * @member {number} fanout\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.fanout = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data mode.\n     * @member {number} mode\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.mode = 0;\n\n    /**\n     * Data mtime.\n     * @member {IUnixTime|null|undefined} mtime\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.mtime = null;\n\n    /**\n     * Encodes the specified Data message. Does not implicitly {@link Data.verify|verify} messages.\n     * @function encode\n     * @memberof Data\n     * @static\n     * @param {IData} m Data message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Data.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        w.uint32(8).int32(m.Type);\n        if (m.Data != null && Object.hasOwnProperty.call(m, \"Data\"))\n            w.uint32(18).bytes(m.Data);\n        if (m.filesize != null && Object.hasOwnProperty.call(m, \"filesize\"))\n            w.uint32(24).uint64(m.filesize);\n        if (m.blocksizes != null && m.blocksizes.length) {\n            for (var i = 0; i < m.blocksizes.length; ++i)\n                w.uint32(32).uint64(m.blocksizes[i]);\n        }\n        if (m.hashType != null && Object.hasOwnProperty.call(m, \"hashType\"))\n            w.uint32(40).uint64(m.hashType);\n        if (m.fanout != null && Object.hasOwnProperty.call(m, \"fanout\"))\n            w.uint32(48).uint64(m.fanout);\n        if (m.mode != null && Object.hasOwnProperty.call(m, \"mode\"))\n            w.uint32(56).uint32(m.mode);\n        if (m.mtime != null && Object.hasOwnProperty.call(m, \"mtime\"))\n            $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();\n        return w;\n    };\n\n    /**\n     * Decodes a Data message from the specified reader or buffer.\n     * @function decode\n     * @memberof Data\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Data} Data\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Data.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.Data();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.Type = r.int32();\n                break;\n            case 2:\n                m.Data = r.bytes();\n                break;\n            case 3:\n                m.filesize = r.uint64();\n                break;\n            case 4:\n                if (!(m.blocksizes && m.blocksizes.length))\n                    m.blocksizes = [];\n                if ((t & 7) === 2) {\n                    var c2 = r.uint32() + r.pos;\n                    while (r.pos < c2)\n                        m.blocksizes.push(r.uint64());\n                } else\n                    m.blocksizes.push(r.uint64());\n                break;\n            case 5:\n                m.hashType = r.uint64();\n                break;\n            case 6:\n                m.fanout = r.uint64();\n                break;\n            case 7:\n                m.mode = r.uint32();\n                break;\n            case 8:\n                m.mtime = $root.UnixTime.decode(r, r.uint32());\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        if (!m.hasOwnProperty(\"Type\"))\n            throw $util.ProtocolError(\"missing required 'Type'\", { instance: m });\n        return m;\n    };\n\n    /**\n     * Creates a Data message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Data\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Data} Data\n     */\n    Data.fromObject = function fromObject(d) {\n        if (d instanceof $root.Data)\n            return d;\n        var m = new $root.Data();\n        switch (d.Type) {\n        case \"Raw\":\n        case 0:\n            m.Type = 0;\n            break;\n        case \"Directory\":\n        case 1:\n            m.Type = 1;\n            break;\n        case \"File\":\n        case 2:\n            m.Type = 2;\n            break;\n        case \"Metadata\":\n        case 3:\n            m.Type = 3;\n            break;\n        case \"Symlink\":\n        case 4:\n            m.Type = 4;\n            break;\n        case \"HAMTShard\":\n        case 5:\n            m.Type = 5;\n            break;\n        }\n        if (d.Data != null) {\n            if (typeof d.Data === \"string\")\n                $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);\n            else if (d.Data.length)\n                m.Data = d.Data;\n        }\n        if (d.filesize != null) {\n            if ($util.Long)\n                (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;\n            else if (typeof d.filesize === \"string\")\n                m.filesize = parseInt(d.filesize, 10);\n            else if (typeof d.filesize === \"number\")\n                m.filesize = d.filesize;\n            else if (typeof d.filesize === \"object\")\n                m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);\n        }\n        if (d.blocksizes) {\n            if (!Array.isArray(d.blocksizes))\n                throw TypeError(\".Data.blocksizes: array expected\");\n            m.blocksizes = [];\n            for (var i = 0; i < d.blocksizes.length; ++i) {\n                if ($util.Long)\n                    (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;\n                else if (typeof d.blocksizes[i] === \"string\")\n                    m.blocksizes[i] = parseInt(d.blocksizes[i], 10);\n                else if (typeof d.blocksizes[i] === \"number\")\n                    m.blocksizes[i] = d.blocksizes[i];\n                else if (typeof d.blocksizes[i] === \"object\")\n                    m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);\n            }\n        }\n        if (d.hashType != null) {\n            if ($util.Long)\n                (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;\n            else if (typeof d.hashType === \"string\")\n                m.hashType = parseInt(d.hashType, 10);\n            else if (typeof d.hashType === \"number\")\n                m.hashType = d.hashType;\n            else if (typeof d.hashType === \"object\")\n                m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);\n        }\n        if (d.fanout != null) {\n            if ($util.Long)\n                (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;\n            else if (typeof d.fanout === \"string\")\n                m.fanout = parseInt(d.fanout, 10);\n            else if (typeof d.fanout === \"number\")\n                m.fanout = d.fanout;\n            else if (typeof d.fanout === \"object\")\n                m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);\n        }\n        if (d.mode != null) {\n            m.mode = d.mode >>> 0;\n        }\n        if (d.mtime != null) {\n            if (typeof d.mtime !== \"object\")\n                throw TypeError(\".Data.mtime: object expected\");\n            m.mtime = $root.UnixTime.fromObject(d.mtime);\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from a Data message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Data\n     * @static\n     * @param {Data} m Data\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Data.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.arrays || o.defaults) {\n            d.blocksizes = [];\n        }\n        if (o.defaults) {\n            d.Type = o.enums === String ? \"Raw\" : 0;\n            if (o.bytes === String)\n                d.Data = \"\";\n            else {\n                d.Data = [];\n                if (o.bytes !== Array)\n                    d.Data = $util.newBuffer(d.Data);\n            }\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.filesize = o.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.hashType = o.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.fanout = o.longs === String ? \"0\" : 0;\n            d.mode = 0;\n            d.mtime = null;\n        }\n        if (m.Type != null && m.hasOwnProperty(\"Type\")) {\n            d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;\n        }\n        if (m.Data != null && m.hasOwnProperty(\"Data\")) {\n            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;\n        }\n        if (m.filesize != null && m.hasOwnProperty(\"filesize\")) {\n            if (typeof m.filesize === \"number\")\n                d.filesize = o.longs === String ? String(m.filesize) : m.filesize;\n            else\n                d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;\n        }\n        if (m.blocksizes && m.blocksizes.length) {\n            d.blocksizes = [];\n            for (var j = 0; j < m.blocksizes.length; ++j) {\n                if (typeof m.blocksizes[j] === \"number\")\n                    d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];\n                else\n                    d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];\n            }\n        }\n        if (m.hashType != null && m.hasOwnProperty(\"hashType\")) {\n            if (typeof m.hashType === \"number\")\n                d.hashType = o.longs === String ? String(m.hashType) : m.hashType;\n            else\n                d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;\n        }\n        if (m.fanout != null && m.hasOwnProperty(\"fanout\")) {\n            if (typeof m.fanout === \"number\")\n                d.fanout = o.longs === String ? String(m.fanout) : m.fanout;\n            else\n                d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;\n        }\n        if (m.mode != null && m.hasOwnProperty(\"mode\")) {\n            d.mode = m.mode;\n        }\n        if (m.mtime != null && m.hasOwnProperty(\"mtime\")) {\n            d.mtime = $root.UnixTime.toObject(m.mtime, o);\n        }\n        return d;\n    };\n\n    /**\n     * Converts this Data to JSON.\n     * @function toJSON\n     * @memberof Data\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Data.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * DataType enum.\n     * @name Data.DataType\n     * @enum {number}\n     * @property {number} Raw=0 Raw value\n     * @property {number} Directory=1 Directory value\n     * @property {number} File=2 File value\n     * @property {number} Metadata=3 Metadata value\n     * @property {number} Symlink=4 Symlink value\n     * @property {number} HAMTShard=5 HAMTShard value\n     */\n    Data.DataType = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"Raw\"] = 0;\n        values[valuesById[1] = \"Directory\"] = 1;\n        values[valuesById[2] = \"File\"] = 2;\n        values[valuesById[3] = \"Metadata\"] = 3;\n        values[valuesById[4] = \"Symlink\"] = 4;\n        values[valuesById[5] = \"HAMTShard\"] = 5;\n        return values;\n    })();\n\n    return Data;\n})();\n\nexport const UnixTime = $root.UnixTime = (() => {\n\n    /**\n     * Properties of an UnixTime.\n     * @exports IUnixTime\n     * @interface IUnixTime\n     * @property {number} Seconds UnixTime Seconds\n     * @property {number|null} [FractionalNanoseconds] UnixTime FractionalNanoseconds\n     */\n\n    /**\n     * Constructs a new UnixTime.\n     * @exports UnixTime\n     * @classdesc Represents an UnixTime.\n     * @implements IUnixTime\n     * @constructor\n     * @param {IUnixTime=} [p] Properties to set\n     */\n    function UnixTime(p) {\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * UnixTime Seconds.\n     * @member {number} Seconds\n     * @memberof UnixTime\n     * @instance\n     */\n    UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n    /**\n     * UnixTime FractionalNanoseconds.\n     * @member {number} FractionalNanoseconds\n     * @memberof UnixTime\n     * @instance\n     */\n    UnixTime.prototype.FractionalNanoseconds = 0;\n\n    /**\n     * Encodes the specified UnixTime message. Does not implicitly {@link UnixTime.verify|verify} messages.\n     * @function encode\n     * @memberof UnixTime\n     * @static\n     * @param {IUnixTime} m UnixTime message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    UnixTime.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        w.uint32(8).int64(m.Seconds);\n        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, \"FractionalNanoseconds\"))\n            w.uint32(21).fixed32(m.FractionalNanoseconds);\n        return w;\n    };\n\n    /**\n     * Decodes an UnixTime message from the specified reader or buffer.\n     * @function decode\n     * @memberof UnixTime\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {UnixTime} UnixTime\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    UnixTime.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.UnixTime();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.Seconds = r.int64();\n                break;\n            case 2:\n                m.FractionalNanoseconds = r.fixed32();\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        if (!m.hasOwnProperty(\"Seconds\"))\n            throw $util.ProtocolError(\"missing required 'Seconds'\", { instance: m });\n        return m;\n    };\n\n    /**\n     * Creates an UnixTime message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof UnixTime\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {UnixTime} UnixTime\n     */\n    UnixTime.fromObject = function fromObject(d) {\n        if (d instanceof $root.UnixTime)\n            return d;\n        var m = new $root.UnixTime();\n        if (d.Seconds != null) {\n            if ($util.Long)\n                (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;\n            else if (typeof d.Seconds === \"string\")\n                m.Seconds = parseInt(d.Seconds, 10);\n            else if (typeof d.Seconds === \"number\")\n                m.Seconds = d.Seconds;\n            else if (typeof d.Seconds === \"object\")\n                m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();\n        }\n        if (d.FractionalNanoseconds != null) {\n            m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from an UnixTime message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof UnixTime\n     * @static\n     * @param {UnixTime} m UnixTime\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    UnixTime.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.defaults) {\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, false);\n                d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.Seconds = o.longs === String ? \"0\" : 0;\n            d.FractionalNanoseconds = 0;\n        }\n        if (m.Seconds != null && m.hasOwnProperty(\"Seconds\")) {\n            if (typeof m.Seconds === \"number\")\n                d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;\n            else\n                d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;\n        }\n        if (m.FractionalNanoseconds != null && m.hasOwnProperty(\"FractionalNanoseconds\")) {\n            d.FractionalNanoseconds = m.FractionalNanoseconds;\n        }\n        return d;\n    };\n\n    /**\n     * Converts this UnixTime to JSON.\n     * @function toJSON\n     * @memberof UnixTime\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    UnixTime.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return UnixTime;\n})();\n\nexport const Metadata = $root.Metadata = (() => {\n\n    /**\n     * Properties of a Metadata.\n     * @exports IMetadata\n     * @interface IMetadata\n     * @property {string|null} [MimeType] Metadata MimeType\n     */\n\n    /**\n     * Constructs a new Metadata.\n     * @exports Metadata\n     * @classdesc Represents a Metadata.\n     * @implements IMetadata\n     * @constructor\n     * @param {IMetadata=} [p] Properties to set\n     */\n    function Metadata(p) {\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * Metadata MimeType.\n     * @member {string} MimeType\n     * @memberof Metadata\n     * @instance\n     */\n    Metadata.prototype.MimeType = \"\";\n\n    /**\n     * Encodes the specified Metadata message. Does not implicitly {@link Metadata.verify|verify} messages.\n     * @function encode\n     * @memberof Metadata\n     * @static\n     * @param {IMetadata} m Metadata message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Metadata.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        if (m.MimeType != null && Object.hasOwnProperty.call(m, \"MimeType\"))\n            w.uint32(10).string(m.MimeType);\n        return w;\n    };\n\n    /**\n     * Decodes a Metadata message from the specified reader or buffer.\n     * @function decode\n     * @memberof Metadata\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Metadata} Metadata\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Metadata.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.Metadata();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.MimeType = r.string();\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        return m;\n    };\n\n    /**\n     * Creates a Metadata message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Metadata\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Metadata} Metadata\n     */\n    Metadata.fromObject = function fromObject(d) {\n        if (d instanceof $root.Metadata)\n            return d;\n        var m = new $root.Metadata();\n        if (d.MimeType != null) {\n            m.MimeType = String(d.MimeType);\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from a Metadata message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Metadata\n     * @static\n     * @param {Metadata} m Metadata\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Metadata.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.defaults) {\n            d.MimeType = \"\";\n        }\n        if (m.MimeType != null && m.hasOwnProperty(\"MimeType\")) {\n            d.MimeType = m.MimeType;\n        }\n        return d;\n    };\n\n    /**\n     * Converts this Metadata to JSON.\n     * @function toJSON\n     * @memberof Metadata\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Metadata.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Metadata;\n})();\n\nexport { $root as default };\n", "// @ts-nocheck\n\n/**\n * This is file is shadowed by api.ts and only exists so JS could import it to\n * refer to types without encountering runtime errors\n * @see https://github.com/microsoft/TypeScript/issues/41825\n */\n\nimport { Data } from \"../gen/unixfs.js\"\nexport const NodeType = Data.DataType\n", "import * as Task from \"./task.js\"\nexport * from \"./task.js\"\n\n/**\n * Turns a task (that never fails or sends messages) into an effect of it's\n * result.\n *\n * @template T\n * @param {Task.Task<T, never>} task\n * @returns {Task.Effect<T>}\n */\nexport const effect = function* (task) {\n  const message = yield* task\n  yield* send(message)\n}\n\n/**\n * Gets a handle to the task that invoked it. Useful when task needs to\n * suspend execution until some outside event occurs, in which case handle\n * can be used resume execution (see `suspend` code example for more details)\n *\n * @template T, M, X\n * @returns {Task.Task<Task.Controller<T, X, M>, never>}\n */\nexport function* current() {\n  return /** @type {Task.Controller<T, X, M>} */ (yield CURRENT)\n}\n\n/**\n * Suspends the current task (task that invokes it),  which can then be\n * resumed from another task or an outside event (e.g. `setTimeout` callback)\n * by calling the `resume` with an task's handle.\n *\n * Calling this in almost all cases is preceeded by call to `current()` in\n * order to obtain a `handle` which can be passed to `resume` function\n * to resume the execution.\n *\n * Note: This task never fails, although it may never resume either. However\n * you can utilize `finally` block to do a necessary cleanup in case execution\n * is aborted.\n *\n * @example\n * ```js\n * import { current, suspend, resume } from \"actor\"\n * function * sleep(duration) {\n *    // get a reference to this task so we can resume it.\n *    const self = yield * current()\n *    // resume this task when timeout fires\n *    const id = setTimeout(() => resume(self), duration)\n *    try {\n *      // suspend this task nothing below this line will run until task is\n *      // resumed.\n *      yield * suspend()\n *    } finally {\n *      // if task is aborted finally block will still run which given you\n *      // chance to cleanup.\n *      clearTimeout(id)\n *    }\n * }\n * ```\n *\n * @returns {Task.Task<void, never>}\n */\nexport const suspend = function* () {\n  yield SUSPEND\n}\n\n/**\n * Suspends execution for the given duration in milliseconds, after which\n * execution is resumed (unless it was aborted in the meantime).\n *\n * @example\n * ```js\n * function * demo() {\n *    console.log(\"I'm going to take small nap\")\n *    yield * sleep(200)\n *    console.log(\"I am back to work\")\n * }\n * ```\n *\n * @param {number} [duration]\n * @returns {Task.Task<void, never>}\n */\nexport function* sleep(duration = 0) {\n  const task = yield* current()\n  const id = setTimeout(enqueue, duration, task)\n\n  try {\n    yield* suspend()\n  } finally {\n    clearTimeout(id)\n  }\n}\n\n/**\n * Provides equivalent of `await` in async functions. Specifically it takes\n * a value that you can `await` on (that is `Promise<T>|T`) and suspends\n * execution until promise is settled. If promise succeeds execution is resumed\n * with `T` otherwise an error of type `X` is thrown (which is by default\n * `unknown` since promises do not encode error type).\n *\n * It is useful when you need to deal with potentially async set of operations\n * without having to check if thing is a promise at every step.\n *\n * Please note: This that execution is suspended even if given value is not a\n * promise, however scheduler will still resume it in the same tick of the event\n * loop after, just processing other scheduled tasks. This avoids problematic\n * race condititions that can otherwise occur when values are sometimes promises\n * and other times are not.\n *\n * @example\n * ```js\n * function * fetchJSON (url, options) {\n *    const response = yield * wait(fetch(url, options))\n *    const json = yield * wait(response.json())\n *    return json\n * }\n * ```\n *\n * @template T, [X=unknown]\n * @param {Task.Await<T>} input\n * @returns {Task.Task<T, Error>}\n */\nexport const wait = function* (input) {\n  const task = yield* current()\n  if (isAsync(input)) {\n    let failed = false\n    /** @type {unknown} */\n    let output = undefined\n    input.then(\n      value => {\n        failed = false\n        output = value\n        enqueue(task)\n      },\n      error => {\n        failed = true\n        output = error\n        enqueue(task)\n      }\n    )\n\n    yield* suspend()\n    if (failed) {\n      throw output\n    } else {\n      return /** @type {T} */ (output)\n    }\n  } else {\n    // This may seem redundunt but it is not, by enqueuing this task we allow\n    // scheduler to perform other queued tasks first. This way many race\n    // conditions can be avoided when values are sometimes promises and other\n    // times aren't.\n    // Unlike `await` however this will resume in the same tick.\n    main(wake(task))\n    yield* suspend()\n    return input\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n * @returns {Task.Task<void, never, never>}\n */\nfunction* wake(task) {\n  enqueue(task)\n}\n\n/**\n * Checks if value value is a promise (or it's lookalike).\n *\n * @template T\n * @param {any} node\n * @returns {node is PromiseLike<T>}\n */\n\nconst isAsync = node =>\n  node != null &&\n  typeof (/** @type {{then?:unknown}} */ (node).then) === \"function\"\n\n/**\n * Task that sends given message (or rather an effect producing this message).\n * Please note, that while you could use `yield message` instead, but you'd risk\n * having to deal with potential breaking changes if library internals change\n * in the future, which in fact may happen as anticipated improvements in\n * TS generator inference could enable replace need for `yield *`.\n *\n * @see https://github.com/microsoft/TypeScript/issues/43632\n *\n * @template T\n * @param {T} message\n * @returns {Task.Effect<T>}\n */\nexport const send = function* (message) {\n  yield /** @type {Task.Message<T>} */ (message)\n}\n\n/**\n * Takes several effects and merges them into a single effect of tagged\n * variants so that their source could be identified via `type` field.\n *\n * @example\n * ```js\n * listen({\n *    read: Task.effect(dbRead),\n *    write: Task.effect(dbWrite)\n * })\n * ```\n *\n * @template {string} Tag\n * @template T\n * @param {{ [K in Tag]: Task.Effect<T> }} source\n * @returns {Task.Effect<Tagged<Tag, T>>}\n */\nexport const listen = function* (source) {\n  /** @type {Task.Fork<void, never, Tagged<Tag, T>>[]} */\n  const forks = []\n  for (const entry of Object.entries(source)) {\n    const [name, effect] = /** @type {[Tag, Task.Effect<T>]} */ (entry)\n    if (effect !== NONE) {\n      forks.push(yield* fork(tag(effect, name)))\n    }\n  }\n\n  yield* group(forks)\n}\n\n/**\n * Takes several tasks and creates an effect of them all.\n *\n * @example\n * ```js\n * Task.effects([\n *    dbRead,\n *    dbWrite\n * ])\n * ```\n *\n * @template {string} Tag\n * @template T\n * @param {Task.Task<T, never>[]} tasks\n * @returns {Task.Effect<T>}\n */\n\nexport const effects = tasks =>\n  tasks.length > 0 ? batch(tasks.map(effect)) : NONE\n\n/**\n * Takes several effects and combines them into a one.\n *\n * @template T\n * @param {Task.Effect<T>[]} effects\n * @returns {Task.Effect<T>}\n */\nexport function* batch(effects) {\n  const forks = []\n  for (const effect of effects) {\n    forks.push(yield* fork(effect))\n  }\n\n  yield* group(forks)\n}\n\n/**\n * @template {string} Tag\n * @template T\n * @typedef {{type: Tag} & {[K in Tag]: T}} Tagged\n */\n/**\n * Tags an effect by boxing each event with an object that has `type` field\n * corresponding to given tag and same named field holding original message\n * e.g. given `nums` effect that produces numbers, `tag(nums, \"inc\")` would\n * create an effect that produces events like `{type:'inc', inc:1}`.\n *\n * @template {string} Tag\n * @template T, M, X\n * @param {Task.Task<T, X, M>} effect\n * @param {Tag} tag\n * @returns {Task.Task<T, X, Tagged<Tag, M>>}\n */\nexport const tag = (effect, tag) =>\n  // @ts-ignore\n  effect === NONE\n    ? NONE\n    : effect instanceof Tagger\n    ? new Tagger([...effect.tags, tag], effect.source)\n    : new Tagger([tag], effect)\n\n/**\n * @template {string} Tag\n * @template Success, Failure, Message\n *\n * @implements {Task.Task<Success, Failure, Tagged<Tag, Message>>}\n * @implements {Task.Controller<Success, Failure, Tagged<Tag, Message>>}\n */\nclass Tagger {\n  /**\n   * @param {Task.Task<Success, Failure, Message>} source\n   * @param {string[]} tags\n   */\n  constructor(tags, source) {\n    this.tags = tags\n    this.source = source\n    /** @type {Task.Controller<Success, Failure, Message>} */\n    this.controller\n  }\n  /* c8 ignore next 3 */\n  [Symbol.iterator]() {\n    if (!this.controller) {\n      this.controller = this.source[Symbol.iterator]()\n    }\n    return this\n  }\n  /**\n   * @param {Task.TaskState<Success, Message>} state\n   * @returns {Task.TaskState<Success, Tagged<Tag, Message>>}\n   */\n  box(state) {\n    if (state.done) {\n      return state\n    } else {\n      switch (state.value) {\n        case SUSPEND:\n        case CURRENT:\n          return /** @type {Task.TaskState<Success, Tagged<Tag, Message>>} */ (\n            state\n          )\n        default: {\n          // Instead of boxing result at each transform step we perform in-place\n          // mutation as we know nothing else is accessing this value.\n          const tagged = /** @type {{ done: false, value: any }} */ (state)\n          let { value } = tagged\n          for (const tag of this.tags) {\n            value = withTag(tag, value)\n          }\n          tagged.value = value\n          return tagged\n        }\n      }\n    }\n  }\n  /**\n   *\n   * @param {Task.Instruction<Message>} instruction\n   */\n  next(instruction) {\n    return this.box(this.controller.next(instruction))\n  }\n  /**\n   *\n   * @param {Failure} error\n   */\n  throw(error) {\n    return this.box(this.controller.throw(error))\n  }\n  /**\n   * @param {Success} value\n   */\n  return(value) {\n    return this.box(this.controller.return(value))\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"TaggedEffect\"\n  }\n}\n\n/**\n * Returns empty `Effect`, that is produces no messages. Kind of like `[]` or\n * `\"\"` but for effects.\n *\n * @type {() => Task.Effect<never>}\n */\nexport const none = () => NONE\n\n/**\n * Takes iterable of tasks and runs them concurrently, returning array of\n * results in an order of tasks (not the order of completion). If any of the\n * tasks fail all the rest are aborted and error is throw into calling task.\n *\n * > This is basically equivalent of `Promise.all` except cancelation logic\n * because tasks unlike promises can be cancelled.\n *\n * @template T, X\n * @param {Iterable<Task.Task<T, X>>} tasks\n * @returns {Task.Task<T[], X>}\n */\nexport const all = function* (tasks) {\n  const self = yield* current()\n\n  /** @type {(id:number) => (value:T) => void} */\n  const succeed = id => value => {\n    delete forks[id]\n    results[id] = value\n    count -= 1\n    if (count === 0) {\n      enqueue(self)\n    }\n  }\n\n  /** @type {(error:X) => void} */\n  const fail = error => {\n    for (const handle of forks) {\n      if (handle) {\n        enqueue(abort(handle, error))\n      }\n    }\n\n    enqueue(abort(self, error))\n  }\n\n  /** @type {Task.Fork<void, never>[]} */\n  let forks = []\n  let count = 0\n  for (const task of tasks) {\n    forks.push(yield* fork(then(task, succeed(count++), fail)))\n  }\n  const results = new Array(count)\n\n  if (count > 0) {\n    yield* suspend()\n  }\n\n  return results\n}\n\n/**\n * @template {string} Tag\n * @template T\n * @param {Tag} tag\n * @param {Task.Message<T>} value\n */\nconst withTag = (tag, value) =>\n  /** @type {Tagged<Tag, T>} */\n  ({ type: tag, [tag]: value })\n\n/**\n * Kind of like promise.then which is handy when you want to extract result\n * from the given task from the outside.\n *\n * @template T, U, X, M\n * @param {Task.Task<T, X, M>} task\n * @param {(value:T) => U} resolve\n * @param {(error:X) => U} reject\n * @returns {Task.Task<U, never, M>}\n */\nexport function* then(task, resolve, reject) {\n  try {\n    return resolve(yield* task)\n  } catch (error) {\n    return reject(/** @type {X} */ (error))\n  }\n}\n\n// Special control instructions recognized by a scheduler.\nconst CURRENT = Symbol(\"current\")\nconst SUSPEND = Symbol(\"suspend\")\n/** @typedef {typeof SUSPEND|typeof CURRENT} Control */\n\n/**\n * @template M\n * @param {Task.Instruction<M>} value\n * @returns {value is M}\n */\nexport const isMessage = value => {\n  switch (value) {\n    case SUSPEND:\n    case CURRENT:\n      return false\n    default:\n      return true\n  }\n}\n\n/**\n * @template M\n * @param {Task.Instruction<M>} value\n * @returns {value is Control}\n */\nexport const isInstruction = value => !isMessage(value)\n\n/**\n * @template T, X, M\n * @implements {Task.TaskGroup<T, X, M>}\n */\nclass Group {\n  /**\n   * @template T, X, M\n   * @param {Task.Controller<T, X, M>|Task.Fork<T, X, M>} member\n   * @returns {Task.Group<T, X, M>}\n   */\n  static of(member) {\n    return (\n      /** @type {{group?:Task.TaskGroup<T, X, M>}} */ (member).group || MAIN\n    )\n  }\n\n  /**\n   * @template T, X, M\n   * @param {(Task.Controller<T, X, M>|Task.Fork<T, X, M>) & {group?:Task.TaskGroup<T, X, M>}} member\n   * @param {Task.TaskGroup<T, X, M>} group\n   */\n  static enqueue(member, group) {\n    member.group = group\n    group.stack.active.push(member)\n  }\n  /**\n   * @param {Task.Controller<T, X, M>} driver\n   * @param {Task.Controller<T, X, M>[]} [active]\n   * @param {Set<Task.Controller<T, X, M>>} [idle]\n   * @param {Task.Stack<T, X, M>} [stack]\n   */\n  constructor(\n    driver,\n    active = [],\n    idle = new Set(),\n    stack = new Stack(active, idle)\n  ) {\n    this.driver = driver\n    this.parent = Group.of(driver)\n    this.stack = stack\n    this.id = ++ID\n  }\n}\n\n/**\n * @template T, X, M\n * @implements {Task.Main<T, X, M>}\n */\nclass Main {\n  constructor() {\n    this.status = IDLE\n    this.stack = new Stack()\n    this.id = /** @type {0} */ (0)\n  }\n}\n\n/**\n * @template T, X, M\n */\nclass Stack {\n  /**\n   * @param {Task.Controller<T, X, M>[]} [active]\n   * @param {Set<Task.Controller<T, X, M>>} [idle]\n   */\n  constructor(active = [], idle = new Set()) {\n    this.active = active\n    this.idle = idle\n  }\n\n  /**\n   *\n   * @param {Task.Stack<unknown, unknown, unknown>} stack\n   * @returns\n   */\n  static size({ active, idle }) {\n    return active.length + idle.size\n  }\n}\n\n/**\n * Starts a main task.\n *\n * @param {Task.Task<void, never>} task\n */\nexport const main = task => enqueue(task[Symbol.iterator]())\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n */\nconst enqueue = task => {\n  let group = Group.of(task)\n  group.stack.active.push(task)\n  group.stack.idle.delete(task)\n\n  // then walk up the group chain and unblock their driver tasks.\n  while (group.parent) {\n    const { idle, active } = group.parent.stack\n    if (idle.has(group.driver)) {\n      idle.delete(group.driver)\n      active.push(group.driver)\n    } else {\n      // if driver was not blocked it must have been unblocked by\n      // other task so stop there.\n      break\n    }\n\n    group = group.parent\n  }\n\n  if (MAIN.status === IDLE) {\n    MAIN.status = ACTIVE\n    while (true) {\n      try {\n        for (const _message of step(MAIN)) {\n        }\n        MAIN.status = IDLE\n        break\n      } catch (_error) {\n        // Top level task may crash and throw an error, but given this is a main\n        // group we do not want to interupt other unrelated tasks, which is why\n        // we discard the error and the task that caused it.\n        MAIN.stack.active.shift()\n      }\n    }\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n */\nexport const resume = task => enqueue(task)\n\n/**\n * @template T, X, M\n * @param {Task.Group<T, X, M>} group\n */\n\nconst step = function* (group) {\n  const { active } = group.stack\n  let task = active[0]\n  group.stack.idle.delete(task)\n  while (task) {\n    /** @type {Task.TaskState<T, M>} */\n    let state = INIT\n    // Keep processing insturctions until task is done, it send suspend request\n    // or it's has been removed from the active queue.\n    // \u26A0\uFE0F Group changes require extra care so please make sure to understand\n    // the detail here. It occurs when spawned task(s) are joined into a group\n    // which will change the task driver, that is when `task === active[0]` will\n    // became false and need to to drop the task immediately otherwise race\n    // condition will occur due to task been  driven by multiple concurrent\n    // schedulers.\n    loop: while (!state.done && task === active[0]) {\n      const instruction = state.value\n      switch (instruction) {\n        // if task is suspended we add it to the idle list and break the loop\n        // to move to a next task.\n        case SUSPEND:\n          group.stack.idle.add(task)\n          break loop\n        // if task requested a context (which is usually to suspend itself)\n        // pass back a task reference and continue.\n        case CURRENT:\n          state = task.next(task)\n          break\n        default:\n          // otherwise task sent a message which we yield to the driver and\n          // continue\n          state = task.next(\n            yield /** @type {M & Task.Message<M>}*/ (instruction)\n          )\n          break\n      }\n    }\n\n    // If task is complete, or got suspended we move to a next task\n    active.shift()\n    task = active[0]\n    group.stack.idle.delete(task)\n  }\n}\n\n/**\n * Executes given task concurrently with a current task (task that spawned it).\n * Spawned task is detached from the task that spawned it and it can outlive it\n * and / or fail without affecting a task that spawned it. If you need to wait\n * on concurrent task completion consider using `fork` instead which can be\n * later `joined`. If you just want a to block on task execution you can just\n * `yield* work()` directly instead.\n *\n * @param {Task.Task<void, never, never>} task\n * @returns {Task.Task<void, never>}\n */\nexport function* spawn(task) {\n  main(task)\n}\n\n/**\n * Executes given task concurrently with current task (the task that initiated\n * fork). Froked task is detached from the task that created it and it can\n * outlive it and / or fail without affecting it. You do however get a handle\n * for the fork which could be used to `join` the task, in which case `joining`\n * task will block until fork finishes execution.\n *\n * This is also a primary interface for executing tasks from the outside of the\n * task context. Function returns `Fork` which implements `Promise` interface\n * so it could be awaited. Please note that calling `fork` does not really do\n * anything, it lazily starts execution when you either `await fork(work())`\n * from arbitray context or `yield* fork(work())` in anothe task context.\n *\n * @template T, X, M\n * @param {Task.Task<T, X, M>} task\n * @param {Task.ForkOptions} [options]\n * @returns {Task.Fork<T, X, M>}\n */\nexport const fork = (task, options) => new Fork(task, options)\n\n/**\n * Exits task succesfully with a given return value.\n *\n * @template T, M, X\n * @param  {Task.Controller<T, M, X>} handle\n * @param {T} value\n * @returns {Task.Task<void, never>}\n */\nexport const exit = (handle, value) => conclude(handle, { ok: true, value })\n\n/**\n * Terminates task execution execution. Only takes task that produces no\n * result, if your task has non `void` return type you should use `exit` instead.\n *\n * @template M, X\n * @param {Task.Controller<void, X, M>} handle\n */\nexport const terminate = handle =>\n  conclude(handle, { ok: true, value: undefined })\n\n/**\n * Aborts given task with an error. Task error type should match provided error.\n *\n * @template T, M, X\n * @param {Task.Controller<T, X, M>} handle\n * @param {X} [error]\n */\nexport const abort = (handle, error) => conclude(handle, { ok: false, error })\n\n/**\n * Aborts given task with an given error.\n *\n * @template T, M, X\n * @param {Task.Controller<T, X, M>} handle\n * @param {Task.Result<T, X>} result\n * @returns {Task.Task<void, never> & Task.Controller<void, never>}\n */\nfunction* conclude(handle, result) {\n  try {\n    const task = handle\n    const state = result.ok\n      ? task.return(result.value)\n      : task.throw(result.error)\n\n    if (!state.done) {\n      if (state.value === SUSPEND) {\n        const { idle } = Group.of(task).stack\n        idle.add(task)\n      } else {\n        enqueue(task)\n      }\n    }\n  } catch (error) {}\n}\n\n/**\n * Groups multiple forks togather and joins joins them with current task.\n *\n * @template T, X, M\n * @param {Task.Fork<T, X, M>[]} forks\n * @returns {Task.Task<void, X, M>}\n */\nexport function* group(forks) {\n  // Abort eraly if there'se no work todo.\n  if (forks.length === 0) return\n\n  const self = yield* current()\n  /** @type {Task.TaskGroup<T, X, M>} */\n  const group = new Group(self)\n  /** @type {Task.Failure<X>|null} */\n  let failure = null\n\n  for (const fork of forks) {\n    const { result } = fork\n    if (result) {\n      if (!result.ok && !failure) {\n        failure = result\n      }\n      continue\n    }\n    move(fork, group)\n  }\n\n  // Keep work looping until there is nom more work to be done\n  try {\n    if (failure) {\n      throw failure.error\n    }\n\n    while (true) {\n      yield* step(group)\n      if (Stack.size(group.stack) > 0) {\n        yield* suspend()\n      } else {\n        break\n      }\n    }\n  } catch (error) {\n    for (const task of group.stack.active) {\n      yield* abort(task, error)\n    }\n\n    for (const task of group.stack.idle) {\n      yield* abort(task, error)\n      enqueue(task)\n    }\n\n    throw error\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Fork<T, X, M>} fork\n * @param {Task.TaskGroup<T, X, M>} group\n */\nconst move = (fork, group) => {\n  const from = Group.of(fork)\n  if (from !== group) {\n    const { active, idle } = from.stack\n    const target = group.stack\n    fork.group = group\n    // If it is idle just move from one group to the other\n    // and update the group task thinks it belongs to.\n    if (idle.has(fork)) {\n      idle.delete(fork)\n      target.idle.add(fork)\n    } else {\n      const index = active.indexOf(fork)\n      // If task is in the job queue, we move it to a target job queue. Moving\n      // top task in the queue requires extra care so it does not end up\n      // processed by two groups which would lead to race. For that reason\n      // `step` loop checks for group changes on each turn.\n      if (index >= 0) {\n        active.splice(index, 1)\n        target.active.push(fork)\n      }\n      // otherwise task is complete\n    }\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Fork<T, X, M>} fork\n * @returns {Task.Task<T, X, M>}\n */\nexport function* join(fork) {\n  // If fork is still idle activate it.\n  if (fork.status === IDLE) {\n    yield* fork\n  }\n\n  if (!fork.result) {\n    yield* group([fork])\n  }\n\n  const result = /** @type {Task.Result<T, X>} */ (fork.result)\n  if (result.ok) {\n    return result.value\n  } else {\n    throw result.error\n  }\n}\n\n/**\n * @template T, X\n * @implements {Task.Future<T, X>}\n */\nclass Future {\n  /**\n   * @param {Task.StateHandler<T, X>} handler\n   */\n  constructor(handler) {\n    this.handler = handler\n    /**\n     * @abstract\n     * @type {Task.Result<T, X>|void}\n     */\n    this.result\n  }\n  /**\n   * @type {Promise<T>}\n   */\n  get promise() {\n    const { result } = this\n    const promise =\n      result == null\n        ? new Promise((succeed, fail) => {\n            this.handler.onsuccess = succeed\n            this.handler.onfailure = fail\n          })\n        : result.ok\n        ? Promise.resolve(result.value)\n        : Promise.reject(result.error)\n    Object.defineProperty(this, \"promise\", { value: promise })\n    return promise\n  }\n\n  /**\n   * @template U, [E=never]\n   * @param {((value:T) => U | PromiseLike<U>)|undefined|null} [onresolve]\n   * @param {((error:X) => E|PromiseLike<E>)|undefined|null} [onreject]\n   * @returns {Promise<U|E>}\n   */\n  then(onresolve, onreject) {\n    return this.activate().promise.then(onresolve, onreject)\n  }\n  /**\n   * @template [U=never]\n   * @param {(error:X) => U} onreject\n   */\n  catch(onreject) {\n    return /** @type {Task.Future<T|U, never>} */ (\n      this.activate().promise.catch(onreject)\n    )\n  }\n  /**\n   * @param {() => void} onfinally\n   * @returns {Task.Future<T, X>}\n   */\n  finally(onfinally) {\n    return /** @type {Task.Future<T, X>} */ (\n      this.activate().promise.finally(onfinally)\n    )\n  }\n  /**\n   * @abstract\n   */\n  /* c8 ignore next 3 */\n  activate() {\n    return this\n  }\n}\n\n/**\n * @template T, X, M\n * @implements {Task.Fork<T, X, M>}\n * @implements {Task.Controller<T, X, M>}\n * @implements {Task.Task<Task.Fork<T, X, M>, never>}\n * @implements {Task.Future<T, X>}\n * @extends {Future<T, X>}\n */\nclass Fork extends Future {\n  /**\n   * @param {Task.Task<T, X, M>} task\n   * @param {Task.ForkOptions} [options]\n   * @param {Task.StateHandler<T, X>} [handler]\n   * @param {Task.TaskState<T, M>} [state]\n   */\n  constructor(task, options = BLANK, handler = {}, state = INIT) {\n    super(handler)\n    this.id = ++ID\n    this.name = options.name || \"\"\n    /** @type {Task.Task<T, X, M>} */\n    this.task = task\n    this.state = state\n    this.status = IDLE\n    /** @type {Task.Result<T, X>} */\n    this.result\n    this.handler = handler\n\n    /** @type {Task.Controller<T, X, M>} */\n    this.controller\n  }\n\n  *resume() {\n    resume(this)\n  }\n\n  /**\n   * @returns {Task.Task<T, X, M>}\n   */\n  join() {\n    return join(this)\n  }\n\n  /**\n   * @param {X} error\n   */\n  abort(error) {\n    return abort(this, error)\n  }\n  /**\n   * @param {T} value\n   */\n  exit(value) {\n    return exit(this, value)\n  }\n  get [Symbol.toStringTag]() {\n    return \"Fork\"\n  }\n\n  /**\n   * @returns {Task.Controller<Task.Fork<T, X, M>, never, never>}\n   */\n  *[Symbol.iterator]() {\n    return this.activate()\n  }\n\n  activate() {\n    this.controller = this.task[Symbol.iterator]()\n    this.status = ACTIVE\n    enqueue(this)\n    return this\n  }\n\n  /**\n   * @private\n   * @param {any} error\n   * @returns {never}\n   */\n  panic(error) {\n    this.result = { ok: false, error }\n    this.status = FINISHED\n    const { handler } = this\n    if (handler.onfailure) {\n      handler.onfailure(error)\n    }\n\n    throw error\n  }\n\n  /**\n   * @private\n   * @param {Task.TaskState<T, M>} state\n   */\n  step(state) {\n    this.state = state\n    if (state.done) {\n      this.result = { ok: true, value: state.value }\n      this.status = FINISHED\n      const { handler } = this\n      if (handler.onsuccess) {\n        handler.onsuccess(state.value)\n      }\n    }\n\n    return state\n  }\n\n  /**\n   * @param {unknown} value\n   */\n  next(value) {\n    try {\n      return this.step(this.controller.next(value))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n  /**\n   * @param {T} value\n   */\n  return(value) {\n    try {\n      return this.step(this.controller.return(value))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n  /**\n   * @param {X} error\n   */\n  throw(error) {\n    try {\n      return this.step(this.controller.throw(error))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n}\n\n/**\n * @template M\n * @param {Task.Effect<M>} init\n * @param {(message:M) => Task.Effect<M>} next\n * @returns {Task.Task<void, never, never>}\n */\nexport const loop = function* (init, next) {\n  /** @type {Task.Controller<void, never, M>} */\n  const controller = yield* current()\n  const group = new Group(controller)\n  Group.enqueue(init[Symbol.iterator](), group)\n\n  while (true) {\n    for (const message of step(group)) {\n      Group.enqueue(next(message)[Symbol.iterator](), group)\n    }\n\n    if (Stack.size(group.stack) > 0) {\n      yield* suspend()\n    } else {\n      break\n    }\n  }\n}\n\nlet ID = 0\n/** @type {Task.Status} */\nconst IDLE = \"idle\"\nconst ACTIVE = \"active\"\nconst FINISHED = \"finished\"\n/** @type {Task.TaskState<any, any>} */\nconst INIT = { done: false, value: CURRENT }\n\nconst BLANK = {}\n\n/** @type {Task.Effect<never>} */\nconst NONE = (function* none() {})()\n\n/** @type {Task.Main<any, any, any>} */\nconst MAIN = new Main()\n", "function Indexed() {}\n\nObject.defineProperties(Indexed, {\n  prototype: {\n    value: new Proxy(Object.prototype, {\n      /**\n       * @param {object} target\n       * @param {PropertyKey} property\n       * @param {{get(key:PropertyKey): any}} receiver\n       */\n      get(target, property, receiver) {\n        return typeof property === \"symbol\"\n          ? Reflect.get(target, property, receiver)\n          : receiver.get(property)\n      },\n    }),\n  },\n})\n\nexport { Indexed }\n", "import { Indexed } from \"./indexed.js\"\n\n/**\n * @typedef {{\n * readonly byteOffset: number\n * readonly byteLength: number\n * readonly segments: Uint8Array[]\n * }} BufferSlice\n */\n\n/** @typedef {BufferView} View */\nexport const empty = () => new BufferView()\n\n/**\n * @param {Uint8Array[]} segments\n * @param {number} byteOffset\n * @param {number} byteLength\n */\nexport const create = (\n  segments,\n  byteOffset = 0,\n  byteLength = totalByteLength(segments)\n) => new BufferView(segments, byteOffset, byteLength)\n\n/**\n *\n * @param {Uint8Array[]} segments\n * @returns\n */\nconst totalByteLength = segments => {\n  let byteLength = 0\n  for (const segment of segments) {\n    byteLength += segment.byteLength\n  }\n  return byteLength\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {number} [startOffset]\n * @param {number} [endOffset]\n */\nexport const slice = (\n  buffer,\n  startOffset = 0,\n  endOffset = buffer.byteLength\n) => {\n  const segments = []\n  const start = startOffset < 0 ? buffer.byteLength - startOffset : startOffset\n  const end = endOffset < 0 ? buffer.byteLength - endOffset : endOffset\n\n  // If start at 0 offset and end is past buffer range it is effectively\n  // as same buffer.\n  if (start === 0 && end >= buffer.byteLength) {\n    return buffer\n  }\n\n  // If range is not within the current buffer just create an empty slice.\n  if (start > end || start > buffer.byteLength || end <= 0) {\n    return empty()\n  }\n\n  let byteLength = 0\n  let offset = 0\n  for (const segment of buffer.segments) {\n    const nextOffset = offset + segment.byteLength\n    // Have not found a start yet\n    if (byteLength === 0) {\n      // If end offset is within the current segment we know start is also,\n      // because it preceeds the end & we had not found start yet.\n      // In such case we create a view with only single segment of bytes\n      // in the range.\n      if (end <= nextOffset) {\n        const range = segment.subarray(start - offset, end - offset)\n        segments.push(range)\n        byteLength = range.byteLength\n        break\n      }\n      // If start offeset falls with in current range (but not the end)\n      // we save matching buffer slice and update byteLength.\n      else if (start < nextOffset) {\n        const range =\n          start === offset ? segment : segment.subarray(start - offset)\n        segments.push(range)\n        byteLength = range.byteLength\n      }\n    }\n    // Otherwise we already started collecting matching segments and are looking\n    // for the end end of the slice. If it is with in the current range capture\n    // the segment and create a view.\n    else if (end <= nextOffset) {\n      const range =\n        end === nextOffset ? segment : segment.subarray(0, end - offset)\n      segments.push(range)\n      byteLength += range.byteLength\n      break\n    }\n    // If end is past current range we just save the segment and continue.\n    else {\n      segments.push(segment)\n      byteLength += segment.byteLength\n    }\n\n    offset = nextOffset\n  }\n\n  return new BufferView(segments, buffer.byteOffset + start, byteLength)\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {Uint8Array} part\n */\n\nexport const push = (buffer, part) => {\n  if (part.byteLength > 0) {\n    // We MUTATE here but that is ok because it is out of bound for the passed\n    // buffer view so there will be no visible side effects.\n    buffer.segments.push(part)\n    return new BufferView(\n      buffer.segments,\n      buffer.byteOffset,\n      buffer.byteLength + part.byteLength\n    )\n  } else {\n    return buffer\n  }\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {number} n\n */\nexport const get = (buffer, n) => {\n  if (n < buffer.byteLength) {\n    let offset = 0\n    for (const segment of buffer.segments) {\n      if (n < offset + segment.byteLength) {\n        return segment[n - offset]\n      } else {\n        offset += segment.byteLength\n      }\n    }\n  }\n\n  return undefined\n}\n\n/**\n *\n * @param {BufferView} buffer\n * @param {Uint8Array} target\n * @param {number} byteOffset\n */\nexport const copyTo = (buffer, target, byteOffset) => {\n  let offset = byteOffset\n  for (const segment of buffer.segments) {\n    target.set(segment, offset)\n    offset += segment.byteLength\n  }\n\n  return target\n}\n\n/**\n *\n * @param {BufferView} buffer\n */\nexport function* iterate(buffer) {\n  for (const part of buffer.segments) {\n    yield* part\n  }\n}\n\n/**\n * @extends {Indexed<number>}\n */\nclass BufferView extends Indexed {\n  /**\n   * @param {Uint8Array[]} segments\n   * @param {number} byteOffset\n   * @param {number} byteLength\n   */\n  constructor(segments = [], byteOffset = 0, byteLength = 0) {\n    super()\n    /** @hide */\n    this.segments = segments\n    /** @readonly */\n    this.byteLength = byteLength\n    /** @readonly */\n    this.length = byteLength\n    /** @readonly */\n    this.byteOffset = byteOffset\n  }\n\n  [Symbol.iterator]() {\n    return iterate(this)\n  }\n\n  /**\n   * @param {number} [start]\n   * @param {number} [end]\n   */\n  slice(start, end) {\n    return /** @type {BufferView} */ (slice(this, start, end))\n  }\n\n  /**\n   * @param {number} [start]\n   * @param {number} [end]\n   */\n  subarray(start, end) {\n    return /** @type {BufferView} */ (slice(this, start, end))\n  }\n\n  /**\n   *\n   * @param {Uint8Array} bytes\n   */\n  push(bytes) {\n    return /** @type {BufferView} */ (push(this, bytes))\n  }\n\n  /**\n   * @param {number} n\n   */\n  get(n) {\n    return get(this, n)\n  }\n\n  /**\n   *\n   * @param {Uint8Array} target\n   * @param {number} offset\n   */\n  copyTo(target, offset) {\n    return copyTo(this, target, offset)\n  }\n}\n", "/**\n * @param {string} reason\n * @returns {never}\n */\nexport const panic = reason => {\n  throw new Error(reason)\n}\n\n/**\n * @param {{ raw: readonly string[] | ArrayLike<string>}} template\n * @param {never} [subject]\n * @param {unknown[]} substitutions\n * @returns {never}\n */\nexport const unreachable = (template, subject, ...substitutions) =>\n  panic(String.raw(template, JSON.stringify(subject), ...substitutions))\n\nexport const EMPTY_BUFFER = new Uint8Array(0)\n/** @type {any[]} */\nexport const EMPTY = []\n", "import * as BufferQueue from \"./chunker/buffer.js\"\nimport * as Chunker from \"./chunker/api.js\"\nimport { EMPTY } from \"../writer/util.js\"\nexport * from \"./chunker/api.js\"\n\n/**\n * @typedef {{\n * chunker: Chunker.Chunker\n * }} Config\n *\n *\n * @typedef {{\n * buffer: BufferQueue.View\n * config: Config\n * }} Chunker\n *\n * @typedef {Chunker & {chunks: Chunker.Chunk[]}} ChunkerWithChunks\n */\n\n/**\n * @param {Config} config\n * @returns {Chunker}\n */\nexport const open = config => ({\n  config,\n  buffer: BufferQueue.empty(),\n})\n\n/**\n * @param {Chunker} state\n * @param {Uint8Array} bytes\n * @returns {ChunkerWithChunks}\n */\nexport const write = (state, bytes) =>\n  bytes.byteLength > 0\n    ? split(state.config, state.buffer.push(bytes), false)\n    : { ...state, chunks: EMPTY }\n\n/**\n * @param {Chunker} state\n * @returns {ChunkerWithChunks}\n */\nexport const close = state => split(state.config, state.buffer, true)\n\n/**\n * @param {Config} config\n * @param {BufferQueue.View} buffer\n * @param {boolean} end\n * @returns {ChunkerWithChunks}\n */\n\nexport const split = (config, buffer, end) => {\n  const chunker = config.chunker\n  const chunks = []\n\n  let offset = 0\n  for (const size of chunker.cut(chunker.context, buffer, end)) {\n    // We may be splitting empty buffer in which case there will be no chunks\n    // in it so we make sure that we do not emit empty buffer.\n    if (size > 0) {\n      const chunk = buffer.subarray(offset, offset + size)\n      chunks.push(chunk)\n      offset += size\n    }\n  }\n\n  return { config, chunks, buffer: buffer.subarray(offset) }\n}\n", "import * as Layout from \"./api.js\"\nimport * as Queue from \"./queue/api.js\"\nexport * from \"./queue/api.js\"\n\n/**\n * @returns {Queue.Result}\n */\nexport const empty = () => ({\n  mutable: false,\n  needs: {},\n  nodes: {},\n  links: {},\n  linked: [],\n})\n\nexport const mutable = () => ({\n  mutable: true,\n  needs: {},\n  nodes: {},\n  links: {},\n  linked: EMPTY,\n})\n\n/**\n * Adds given layout node to the layout queue. If links for all of the node\n * children are available correspnoding linked node is added (removing links\n * form the queue) otherwise `nood` is added to the wait queue until all the\n * needed links are added.\n *\n *\n * @param {Layout.Branch} node\n * @param {Queue.Queue} queue\n * @returns {Queue.Result}\n */\nexport const addNode = (node, queue) => addNodes([node], queue)\n\n/**\n *\n * @param {Layout.Branch[]} newNodes\n * @param {Queue.Queue} input\n * @returns {Queue.Result}\n */\nexport const addNodes = (newNodes, input) => {\n  let queue = patch(input, {})\n  for (const node of newNodes) {\n    const { ready, has, wants } = collect(node.children, queue.links)\n    // If node isn't waiting on any of the children it's ready to be linked\n    // so we add linked node diretly.\n    if (wants.length === 0) {\n      queue = patch(queue, {\n        links: assign(undefined, has),\n        linked: [{ id: node.id, links: ready }],\n      })\n    } else {\n      queue = patch(queue, {\n        needs: assign(node.id, wants),\n        nodes: {\n          [node.id]: {\n            children: node.children,\n            count: wants.length,\n          },\n        },\n      })\n    }\n  }\n\n  return queue\n}\n\n/**\n * Adds link to the queue. If queue contains a node that needs this link it gets\n * updated. Either it's gets linked (when it was blocked only on this link) or\n * it's want could is reduced. If no node needed this link it just gets stored\n * for the future node that will need it.\n *\n *\n * @param {Queue.NodeID} id\n * @param {Queue.Link} link\n * @param {Queue.Queue} queue\n * @returns {Queue.Result}\n */\n\nexport const addLink = (id, link, queue) => {\n  const nodeID = queue.needs[id]\n  const node = queue.nodes[nodeID]\n  // We have node than needs this link.\n  if (node != null) {\n    // This is the only link it needed so we materialize the node and remove\n    // links and needs associated with it.\n    if (node.count === 1) {\n      const { ready, has } = collect(node.children, {\n        ...queue.links,\n        [id]: link,\n      })\n\n      return patch(queue, {\n        needs: { [id]: undefined },\n        links: assign(undefined, has),\n        nodes: { [nodeID]: undefined },\n        linked: [{ id: nodeID, links: ready }],\n      })\n    }\n    // If node needs more links we just reduce a want count and remove this\n    // need.\n    else {\n      return patch(queue, {\n        needs: { [id]: undefined },\n        links: { [id]: link },\n        nodes: {\n          [nodeID]: {\n            ...node,\n            count: node.count - 1,\n          },\n        },\n      })\n    }\n  }\n  // If we have no one waiting for this link just add it to the queue\n  else {\n    return patch(queue, {\n      links: { [id]: link },\n    })\n  }\n}\n\n/**\n *\n * @param {Queue.Queue} queue\n * @param {Queue.Delta} delta\n */\n\nconst patch = (queue, { needs, nodes, links, linked }) => {\n  const result = queue.mutable ? queue : { ...queue }\n  const original = queue.mutable ? BLANK : undefined\n\n  if (needs) {\n    result.needs = patchDict(queue.needs, needs, original)\n  }\n\n  if (nodes) {\n    result.nodes = patchDict(queue.nodes, nodes, original)\n  }\n\n  if (links) {\n    result.links = patchDict(queue.links, links, original)\n  }\n\n  result.linked = linked\n    ? append(queue.linked || EMPTY, linked, EMPTY)\n    : queue.linked || []\n\n  return /** @type {Queue.Result} */ (result)\n}\n\n/**\n * @template V\n * @template {PropertyKey} K\n * @param {V} value\n * @param {K[]} keys\n * @returns {Record<K, V>}\n */\n\nconst assign = (value, keys) => {\n  const delta = /** @type {Record<K, V>} */ ({})\n  for (const key of keys) {\n    delta[key] = value\n  }\n\n  return delta\n}\n\n/**\n * @template {PropertyKey} K\n * @template V\n * @param {Record<K, V>} target\n *\n * @param {Record<K, V|void>} delta\n * @param {Record<K, V>} original\n * @returns {Record<K, V>}\n */\n\nconst patchDict = (target, delta, original = target) => {\n  const result = target === original ? { ...target } : target\n  for (const entry of Object.entries(delta)) {\n    const [id, value] = /** @type {[K, V|void]} */ (entry)\n    if (value == null) {\n      delete result[id]\n    } else {\n      result[id] = value\n    }\n  }\n\n  return result\n}\n/**\n *\n * @param {Iterable<[Queue.NodeID, Queue.Link]>} entries\n * @param {Queue.Queue} queue\n * @returns {Queue.Queue}\n */\nexport const addLinks = (entries, queue) => {\n  for (const [id, link] of entries) {\n    queue = addLink(id, link, queue)\n  }\n  return queue\n}\n\n/**\n * @param {Queue.Queue} queue\n */\n\nexport const isEmpty = queue =>\n  Object.keys(queue.nodes).length === 0 && Object.keys(queue.links).length === 0\n\n/**\n * @template T\n * @param {T[]} target\n * @param {T[]} items\n * @param {T[]} original\n */\nconst append = (target, items, original = target) => {\n  if (target === original) {\n    return [...target, ...items]\n  } else {\n    for (const item of items) {\n      target.push(item)\n    }\n    return target\n  }\n}\n\n/**\n * @param {Queue.NodeID[]} children\n * @param {Record<Queue.NodeID, Queue.Link>} source\n * @returns {{has:Queue.NodeID[], wants:Queue.NodeID[], ready:Queue.Link[]}}\n */\nconst collect = (children, source) => {\n  const has = []\n  const wants = []\n  const ready = []\n  for (const child of children) {\n    const link = source[child]\n    if (link) {\n      has.push(child)\n      ready.push(link)\n    } else {\n      wants.push(child)\n    }\n  }\n\n  return { has, wants, ready }\n}\n\nconst EMPTY = /** @type {never[]} */ (Object.freeze([]))\n\nconst BLANK = /** @type {Record<never, never>} */ (Object.freeze({}))\n", "import * as Task from \"actor\"\nimport * as API from \"./api.js\"\nimport * as Layout from \"./layout/api.js\"\nimport * as UnixFS from \"../codec.js\"\nimport * as Chunker from \"./chunker.js\"\nimport { EMPTY_BUFFER, panic, unreachable } from \"../writer/util.js\"\nimport * as Queue from \"./layout/queue.js\"\n\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'open'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * chunker: Chunker.Chunker\n * layout: Layout\n * nodeQueue: Queue.Queue\n * }} Open\n */\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'closed'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * readonly rootID: Layout.NodeID\n * readonly end?: Task.Fork<void, never>\n * chunker?: null\n * layout?: null\n * nodeQueue: Queue.Queue\n * }} Closed\n */\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'linked'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * readonly link: Layout.Link\n * chunker?: null\n * layout?: null\n * nodeQueue: Queue.Queue\n * }} Linked\n */\n\n/**\n * @template Layout\n * @typedef {Open<Layout>|Closed<Layout>|Linked<Layout>} State\n */\n\n/**\n * @template {object} Layout\n * @typedef {{\n * state: State<Layout>\n * effect: Task.Effect<Message>\n * }} Update\n */\n/**\n * @typedef {never\n * |{type:\"write\", bytes:Uint8Array}\n * |{type:\"link\", link:API.EncodedFile}\n * |{type:\"block\"}\n * |{type: \"close\"}\n * |{type: \"end\"}\n * } Message\n */\n\n/**\n * @template Layout\n * @param {Message} message\n * @param {State<Layout>} state\n */\nexport const update = (message, state) => {\n  switch (message.type) {\n    case \"write\":\n      return write(state, message.bytes)\n    case \"link\":\n      return link(state, message.link)\n    /* c8 ignore next 2 */\n    case \"block\":\n      return { state, effect: Task.none() }\n    case \"close\":\n      return close(state)\n    case \"end\":\n      return { state, effect: Task.none() }\n    default:\n      return unreachable`File Writer got unknown message ${message}`\n  }\n}\n\n/**\n * @template Layout\n * @param {API.BlockWriter} writer\n * @param {UnixFS.Metadata} metadata\n * @param {API.EncoderSettings} config\n * @returns {State<Layout>}\n */\nexport const init = (writer, metadata, config) => {\n  return {\n    status: \"open\",\n    metadata,\n    config,\n    writer,\n    chunker: Chunker.open({ chunker: config.chunker }),\n    layout: config.fileLayout.open(),\n    // Note: Writing in large slices e.g. 1GiB at a time creates large queues\n    // with around `16353` items. Immutable version ends up copying it every\n    // time state of the queue changes, which introduces significant overhead.\n    // To avoid this overhead we use mutable implementation which is API\n    // compatible but makes in place updates.\n    // TODO: We should consider using Persistent bit-partitioned vector tries\n    // instead of arrays which would provide immutable interface with neglegable\n    // overhead.\n    // @see https://github.com/Gozala/vectrie\n    nodeQueue: Queue.mutable(),\n  }\n}\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @param {Uint8Array} bytes\n * @returns {Update<Layout>}\n */\nexport const write = (state, bytes) => {\n  if (state.status === \"open\") {\n    // Chunk up provided bytes\n    const { chunks, ...chunker } = Chunker.write(state.chunker, bytes)\n\n    // Pass chunks to layout engine to produce nodes\n    const { nodes, leaves, layout } = state.config.fileLayout.write(\n      state.layout,\n      chunks\n    )\n\n    const { linked, ...nodeQueue } = Queue.addNodes(nodes, state.nodeQueue)\n\n    // Create leaf encode tasks for all new leaves\n    const tasks = [\n      ...encodeLeaves(leaves, state.config),\n      ...encodeBranches(linked, state.config),\n    ]\n\n    return {\n      state: {\n        ...state,\n        chunker,\n        layout,\n        nodeQueue,\n      },\n      effect: Task.listen({\n        link: Task.effects(tasks),\n      }),\n    }\n  } else {\n    return panic(\"Unable to perform write on closed file\")\n  }\n}\n\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @param {API.EncodedFile} entry\n * @returns {Update<Layout>}\n */\nexport const link = (state, { id, link, block }) => {\n  let { linked, ...nodeQueue } = Queue.addLink(id, link, state.nodeQueue)\n\n  const tasks = encodeBranches(linked, state.config)\n\n  /** @type {State<Layout>} */\n  const newState =\n    state.status === \"closed\" && id === state.rootID\n      ? {\n          ...state,\n          status: \"linked\",\n          link,\n          nodeQueue,\n        }\n      : { ...state, nodeQueue }\n\n  // If we just linked a root and there is a **suspended** \"end\" task we create\n  // a task to resume it.\n  const end =\n    state.status === \"closed\" && id === state.rootID && state.end\n      ? state.end.resume()\n      : Task.none()\n\n  return {\n    state: newState,\n    effect: Task.listen({\n      link: Task.effects(tasks),\n      block: writeBlock(state.writer, block),\n      end,\n    }),\n  }\n}\n\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @returns {Update<Layout>}\n */\nexport const close = state => {\n  if (state.status === \"open\") {\n    const { chunks } = Chunker.close(state.chunker)\n    const { layout, ...write } = state.config.fileLayout.write(\n      state.layout,\n      chunks\n    )\n\n    const { root, ...close } = state.config.fileLayout.close(\n      layout,\n      state.metadata\n    )\n\n    const [nodes, leaves] = isLeafNode(root)\n      ? [\n          [...write.nodes, ...close.nodes],\n          [...write.leaves, ...close.leaves, root],\n        ]\n      : [\n          [...write.nodes, ...close.nodes, root],\n          [...write.leaves, ...close.leaves],\n        ]\n\n    const { linked, ...nodeQueue } = Queue.addNodes(nodes, state.nodeQueue)\n\n    const tasks = [\n      ...encodeLeaves(leaves, state.config),\n      ...encodeBranches(linked, state.config),\n    ]\n\n    // We want to keep run loop around until root node is linked. To\n    // accomplish this we fork a task that suspends itself, which we will\n    // resume when root is linked (see link function).\n    // Below we join this forked task in our effect, this way effect is not\n    // complete until task forked task is, which will do once we link the\n    // root.\n    const fork = Task.fork(Task.suspend())\n\n    return {\n      state: {\n        ...state,\n        chunker: null,\n        layout: null,\n        rootID: root.id,\n        status: \"closed\",\n        end: fork,\n        nodeQueue,\n      },\n      effect: Task.listen({\n        link: Task.effects(tasks),\n        end: Task.join(fork),\n      }),\n    }\n  } else {\n    return { state, effect: Task.none() }\n  }\n}\n\n/**\n * Creates concurrent leaf encode tasks. Each one will have an ID corresponding\n * to index in the queue.\n *\n * @param {Layout.Leaf[]} leaves\n * @param {API.EncoderSettings} config\n */\nconst encodeLeaves = (leaves, config) =>\n  leaves.map(leaf => encodeLeaf(config, leaf, config.fileChunkEncoder))\n\n/**\n * @param {API.EncoderSettings} config\n * @param {Layout.Leaf} leaf\n * @param {API.FileChunkEncoder} encoder\n * @returns {Task.Task<API.EncodedFile, never>}\n */\nconst encodeLeaf = function* ({ hasher, linker }, { id, content }, encoder) {\n  const bytes = encoder.encode(content ? asUint8Array(content) : EMPTY_BUFFER)\n  const hash = yield* Task.wait(hasher.digest(bytes))\n  const cid = linker.createLink(encoder.code, hash)\n\n  const block = { cid, bytes }\n  const link = /** @type {UnixFS.FileLink} */ ({\n    cid,\n    contentByteLength: content ? content.byteLength : 0,\n    dagByteLength: bytes.byteLength,\n  })\n\n  return { id, block, link }\n}\n\n/**\n * @param {Queue.LinkedNode[]} nodes\n * @param {API.EncoderSettings} config\n */\nconst encodeBranches = (nodes, config) =>\n  nodes.map(node => encodeBranch(config, node))\n\n/**\n * @template Layout\n * @param {API.EncoderSettings<Layout>} config\n * @param {Queue.LinkedNode} node\n * @param {UnixFS.Metadata} [metadata]\n * @returns {Task.Task<API.EncodedFile>}\n */\nexport const encodeBranch = function* (config, { id, links }, metadata) {\n  const bytes = config.fileEncoder.encode({\n    type: UnixFS.NodeType.File,\n    layout: \"advanced\",\n    parts: links,\n    metadata,\n  })\n  const hash = yield* Task.wait(Promise.resolve(config.hasher.digest(bytes)))\n  const cid = config.linker.createLink(config.fileEncoder.code, hash)\n  const block = { bytes, cid }\n  const link = /** @type {UnixFS.FileLink} */ ({\n    cid,\n    contentByteLength: UnixFS.cumulativeContentByteLength(links),\n    dagByteLength: UnixFS.cumulativeDagByteLength(bytes, links),\n  })\n\n  return { id, block, link }\n}\n\n/**\n * @param {API.BlockWriter} writer\n * @param {UnixFS.Block} block\n * @returns {Task.Task<void, never>}\n */\n\nexport const writeBlock = function* (writer, block) {\n  if ((writer.desiredSize || 0) <= 0) {\n    yield* Task.wait(writer.ready)\n  }\n  writer.write(block)\n}\n\n/**\n *\n * @param {Uint8Array|Chunker.Chunk} buffer\n * @returns\n */\n\nconst asUint8Array = buffer =>\n  buffer instanceof Uint8Array\n    ? buffer\n    : buffer.copyTo(new Uint8Array(buffer.byteLength), 0)\n\n/**\n * @param {Layout.Node} node\n * @returns {node is Layout.Leaf}\n */\nconst isLeafNode = node => node.children == null\n", "import * as API from \"./api.js\"\n\nexport const name = \"fixed\"\n/**\n * @typedef {Object} FixedSize\n * @property {number} maxChunkSize\n */\n\n/** @type {FixedSize} */\nexport const context = {\n  maxChunkSize: 262144,\n}\n\nexport const type = \"Stateless\"\n\n/**\n * @param {number} maxChunkSize\n * @returns {API.StatelessChunker<FixedSize>}\n */\nexport const withMaxChunkSize = maxChunkSize => ({\n  type: \"Stateless\",\n  context: { maxChunkSize },\n  name,\n  cut,\n})\n\n/**\n * @param {FixedSize} maxChunkSize\n * @param {API.Chunk} buffer\n * @param {boolean} end\n * @returns {number[]}\n */\nexport const cut = ({ maxChunkSize }, { byteLength }, end) => {\n  // number of fixed size chunks that would fit\n  const n = (byteLength / maxChunkSize) | 0\n  const chunks = new Array(n).fill(maxChunkSize)\n  const lastChunkSize = end ? byteLength - n * maxChunkSize : 0\n  if (lastChunkSize > 0) {\n    chunks.push(lastChunkSize)\n  }\n  return chunks\n}\n", "import * as Layout from \"./api.js\"\nimport * as Chunker from \"./../chunker/api.js\"\n\n/**\n * Type representing a state of the balanced tree. First row hold leaves coming\n * into a builder, once number of leaves in the stack reaches `maxChildren` they\n * are moved into `RootNode` instance which is pushed into the next row of nodes.\n * If next row now contains `maxChildren` nodes from there are again moved into\n * a new `RootNode` and pushed into next row etc...\n *\n * For illustration let's assume we have `maxChildren: 3`, after 3 leafs were\n * added tree will have following layout\n *\n * ```\n *           (root1)\n *              |\n *    ----------------------\n *    |         |          |\n * (leaf1)   (leaf2)    (leaf3)\n * ```\n *\n * Which in our model before flushing is represented as follows:\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: [leaf1, leaf2, leaf3]\n *    nodeIndex: []\n *    nodes: []\n * }\n * ```\n *\n * After flushing 3 leaves (which is width) are moved into a `RootNode` that\n * is added to `nodes` array (and returned so that caller can create a block).\n * Additionally position of the added node is captured in the `index` at an\n * appropriate depth `0` (that is because we don't count leaves into depth).\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: []\n *    nodeIndex: [[0]]\n *    nodes: [new RootNode([leaf1, leaf2, leaf3])]\n * }\n * ```\n *\n * Increasing number of leaves to 10 would produce following tree layout\n *\n *```\n *                                                         (root7)\n *                                                           |\n *                                    ------------------------------------------\n *                                    |                                        |\n *                                 (root4)                                  (root6)\n *                                    |                                        |\n *            -------------------------------------------------                |\n *            |                       |                       |                |\n *         (root1)                 (root2)                 (root3)          (root5)\n *            |                       |                       |                |\n *    --------|--------       --------|--------       --------|--------        |\n *    |       |       |       |       |       |       |       |       |        |\n * (leaf1) (leaf2) (leaf3) (leaf4) (leaf5) (leaf6) (leaf7) (leaf8) (leaf9) (leaf10)\n * ```\n *\n * Which in our model will look as follows (note we do not have root5 - root7\n * in model because they are build once width is reached or once builder is\n * closed)\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: [leaf10]\n *    nodeIndex: [\n *      [0, 1, 2], // [r1, r2, r3]\n *      [3]        // [r4]\n *     ]\n *    nodes: [\n *      new Node([leaf1, leaf2, leaf3]), // r1\n *      new Node([leaf4, leaf5, leaf6]), // r2\n *      new Node([leaf7, leaf8, leaf9]), // r3\n *      new Node([ // r4\n *         new Node([leaf1, leaf2, leaf3]), // r1\n *         new Node([leaf4, leaf5, leaf6]), // r2\n *         new Node([leaf7, leaf8, leaf9]), // r3\n *      ])\n *    ]\n * }\n * ```\n *\n * @typedef {{\n * width: number\n * head: Chunker.Chunk | null\n * leafIndex: number[]\n * nodeIndex: number[][]\n * lastID: number\n * }} Balanced\n */\n\nclass Node {\n  /**\n   *\n   * @param {number} id\n   * @param {number[]} children\n   * @param {Layout.Metadata} [metadata]\n   */\n  constructor(id, children, metadata) {\n    this.id = id\n    this.children = children\n    this.metadata = metadata\n  }\n}\n\n/**\n * @typedef Options\n * @property {number} width - Max children per node.\n *\n * @param {number} width\n * @returns {Layout.LayoutEngine<Balanced>}\n */\nexport const withWidth = width => ({\n  open: () => open({ width }),\n  write,\n  close,\n})\n\nexport const defaults = { width: 174 }\n\n/**\n * @param {Options} options\n * @returns {Balanced}\n */\nexport const open = ({ width } = defaults) => ({\n  width,\n\n  head: null,\n  leafIndex: [],\n  nodeIndex: [],\n  lastID: 0,\n})\n\n/**\n *\n * @param {Balanced} layout\n * @param {Chunker.Chunk[]} chunks\n * @returns {Layout.WriteResult<Balanced>}\n */\nexport const write = (layout, chunks) => {\n  if (chunks.length === 0) {\n    return { layout, nodes: EMPTY, leaves: EMPTY }\n  } else {\n    let { lastID } = layout\n    // We need to hold on to the first chunk until we either get a second chunk\n    // (at which point we know our layout will have branches) or until we close\n    // (at which point our layout will be single leaf or node depneding on\n    // metadata)\n    const [head, slices] = layout.head\n      ? // If we had a head we have more then two chunks (we already checked\n        // chunks weren't empty) so we process head along with other chunks.\n        [null, (chunks.unshift(layout.head), chunks)]\n      : // If we have no head no leaves and got only one chunk we have to save it\n      // until we can decide what to do with it.\n      chunks.length === 1 && layout.leafIndex.length === 0\n      ? [chunks[0], EMPTY]\n      : // Otherwise we have no head but got enough chunks to know we'll have a\n        // node.\n        [null, chunks]\n\n    if (slices.length === 0) {\n      return { layout: { ...layout, head }, nodes: EMPTY, leaves: EMPTY }\n    } else {\n      const leafIndex = [...layout.leafIndex]\n      const leaves = []\n      for (const chunk of slices) {\n        const leaf = { id: ++lastID, content: chunk }\n        leaves.push(leaf)\n        leafIndex.push(leaf.id)\n      }\n\n      if (leafIndex.length > layout.width) {\n        return flush({ ...layout, leafIndex, head, lastID }, leaves)\n      } else {\n        return {\n          layout: { ...layout, head, leafIndex, lastID },\n          leaves,\n          nodes: EMPTY,\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {Balanced} state\n * @param {Layout.Leaf[]} leaves\n * @param {Layout.Branch[]} [nodes]\n * @param {boolean} [close]\n * @returns {Layout.WriteResult<Balanced>}\n */\nexport const flush = (state, leaves = EMPTY, nodes = [], close = false) => {\n  let { lastID } = state\n  const nodeIndex = state.nodeIndex.map(row => [...row])\n  const leafIndex = [...state.leafIndex]\n  const { width } = state\n\n  // Move leaves into nodes\n  while (leafIndex.length > width || (leafIndex.length > 0 && close)) {\n    grow(nodeIndex, 1)\n    const node = new Node(++lastID, leafIndex.splice(0, width))\n    nodeIndex[0].push(node.id)\n    nodes.push(node)\n  }\n\n  let depth = 0\n  while (depth < nodeIndex.length) {\n    const row = nodeIndex[depth]\n    depth++\n\n    while (\n      row.length > width ||\n      (row.length > 0 && close && depth < nodeIndex.length)\n    ) {\n      const node = new Node(++lastID, row.splice(0, width))\n      grow(nodeIndex, depth + 1)\n      nodeIndex[depth].push(node.id)\n      nodes.push(node)\n    }\n  }\n\n  return { layout: { ...state, lastID, leafIndex, nodeIndex }, leaves, nodes }\n}\n\n/**\n * @param {Balanced} layout\n * @param {Layout.Metadata} [metadata]\n * @returns {Layout.CloseResult}\n */\nexport const close = (layout, metadata) => {\n  const state = layout\n  if (layout.head) {\n    return {\n      root: { id: 1, content: layout.head, metadata },\n      leaves: EMPTY,\n      nodes: EMPTY,\n    }\n  } else if (layout.leafIndex.length === 0) {\n    return {\n      root: { id: 1, metadata },\n      leaves: EMPTY,\n      nodes: EMPTY,\n    }\n  } else {\n    // Flush with width 1 so all the items will be propagate up the tree\n    // and height of `depth-1` so we propagate nodes all but from the top\n    // most level\n    const { nodes, layout } = flush(state, EMPTY, [], true)\n\n    const { nodeIndex } = layout\n    const height = nodeIndex.length - 1\n\n    const top = nodeIndex[height]\n    if (top.length === 1) {\n      const root = nodes[nodes.length - 1]\n      nodes.length = nodes.length - 1\n      return { root, nodes, leaves: EMPTY }\n    } else {\n      const root = new Node(layout.lastID + 1, top, metadata)\n      return { root, nodes, leaves: EMPTY }\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T[][]} index\n * @param {number} length\n */\nconst grow = (index, length) => {\n  while (index.length < length) {\n    index.push([])\n  }\n  return index\n}\n\n/** @type {never[]} */\nconst EMPTY = []\n", "import * as API from \"./file/api.js\"\nimport * as UnixFS from \"./codec.js\"\nimport * as Writer from \"./file/writer.js\"\nimport * as Task from \"actor\"\nimport { panic } from \"./writer/util.js\"\nimport * as FixedSize from \"./file/chunker/fixed.js\"\nimport { sha256 } from \"multiformats/hashes/sha2\"\nimport { CID } from \"multiformats/cid\"\nimport * as Balanced from \"./file/layout/balanced.js\"\n\nexport * from \"./file/api.js\"\n\n/**\n * @returns {API.EncoderSettings}\n */\nexport const defaults = () => ({\n  chunker: FixedSize,\n  fileChunkEncoder: UnixFSLeaf,\n  smallFileEncoder: UnixFSLeaf,\n  fileEncoder: UnixFS,\n  fileLayout: Balanced.withWidth(174),\n  hasher: sha256,\n  linker: { createLink: CID.createV1 },\n})\n\n/**\n * @template {unknown} Layout\n * @param {Partial<API.EncoderSettings<Layout>>} config\n * @returns {API.EncoderSettings<Layout>}\n */\nexport const configure = config => ({\n  ...defaults(),\n  ...config,\n})\n\nexport const UnixFSLeaf = {\n  code: UnixFS.code,\n  name: UnixFS.name,\n  encode: UnixFS.encodeFileChunk,\n}\n\nexport const UnixFSRawLeaf = {\n  code: UnixFS.code,\n  name: UnixFS.name,\n  encode: UnixFS.encodeRaw,\n}\n\n/**\n * @template Layout\n * @param {API.Options<Layout>} options\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, metadata = {}, settings = defaults() }) =>\n  new FileWriterView(Writer.init(writer, metadata, configure(settings)))\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {Uint8Array} bytes\n * @return {Promise<API.View<T>>}\n */\n\nexport const write = async (view, bytes) => {\n  await perform(view, Task.send({ type: \"write\", bytes }))\n  return view\n}\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {API.CloseOptions} options\n */\nexport const close = async (\n  view,\n  { releaseLock = false, closeWriter = false } = {}\n) => {\n  await perform(view, Task.send({ type: \"close\" }))\n  const { state } = view\n  if (state.status === \"linked\") {\n    if (closeWriter) {\n      await view.state.writer.close()\n    } else if (releaseLock) {\n      view.state.writer.releaseLock()\n    }\n    return state.link\n    /* c8 ignore next 5 */\n  } else {\n    panic(\n      `Expected writer to be in 'linked' state after close, but it is in \"${state.status}\" instead`\n    )\n  }\n}\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {Task.Effect<Writer.Message>} effect\n */\nconst perform = (view, effect) =>\n  Task.fork(\n    Task.loop(effect, message => {\n      const { state, effect } = Writer.update(message, view.state)\n      view.state = state\n      return effect\n    })\n  )\n\n/**\n * @template Layout\n * @implements {API.View<Layout>}\n */\nclass FileWriterView {\n  /**\n   * @param {Writer.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.config\n  }\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {Promise<API.View<Layout>>}\n   */\n  write(bytes) {\n    return write(this, bytes)\n  }\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.FileLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n}\n", "import * as API from \"./directory/api.js\"\nimport * as File from \"./file.js\"\nimport * as UnixFS from \"./codec.js\"\nexport * from \"./directory/api.js\"\n\nexport const configure = File.configure\nexport const defaults = File.defaults\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} config\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, settings = defaults(), metadata = {} }) =>\n  new DirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new Map(),\n    closed: false,\n  })\n\n/**\n * @template {unknown} L\n * @template {{ state: API.State<L> }} View\n * @param {View} view\n * @param {string} name\n * @param {API.EntryLink} link\n * @param {API.WriteOptions} options\n */\nexport const set = (view, name, link, { overwrite = false } = {}) => {\n  const writable = asWritable(view.state)\n  if (name.includes(\"/\")) {\n    throw new Error(\n      `Directory entry name \"${name}\" contains forbidden \"/\" character`\n    )\n  }\n  if (!overwrite && writable.entries.has(name)) {\n    throw new Error(`Directory already contains entry with name \"${name}\"`)\n  } else {\n    writable.entries.set(name, link)\n    return view\n  }\n}\n\n/**\n * @template {unknown} L\n * @template {{ state: API.State<L> }} View\n * @param {View} view\n * @param {string} name\n */\nexport const remove = (view, name) => {\n  const writer = asWritable(view.state)\n  writer.entries.delete(name)\n  return view\n}\n\n/**\n * @template {API.State} Writer\n * @param {Writer} writer\n * @returns {Writer}\n */\nconst asWritable = writer => {\n  if (!writer.closed) {\n    return writer\n  } else {\n    throw new Error(\n      `Can not change written directory, but you can .fork() and make changes to it`\n    )\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @param {API.CloseOptions} options\n * @returns {Promise<UnixFS.DirectoryLink>}\n */\nexport const close = async (\n  view,\n  { closeWriter = false, releaseLock = false } = {}\n) => {\n  const { writer, settings, metadata } = asWritable(view.state)\n  view.state.closed = true\n  const entries = [...links(view)]\n  const node = UnixFS.createFlatDirectory(entries, metadata)\n  const bytes = UnixFS.encodeDirectory(node)\n  const digest = await settings.hasher.digest(bytes)\n  /** @type {UnixFS.Link<UnixFS.Directory>} */\n  const cid = settings.linker.createLink(UnixFS.code, digest)\n\n  // we make sure that writer has some capacity for this write. If it\n  // does not we await.\n  if ((writer.desiredSize || 0) <= 0) {\n    await writer.ready\n  }\n  // once writer has some capacity we write a block, however we do not\n  // await completion as we don't care when it's taken off the stream.\n  writer.write({ cid, bytes })\n\n  if (closeWriter) {\n    await writer.close()\n  } else if (releaseLock) {\n    writer.releaseLock()\n  }\n\n  return {\n    cid,\n    dagByteLength: UnixFS.cumulativeDagByteLength(bytes, entries),\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @returns {IterableIterator<UnixFS.DirectoryEntryLink>}\n */\nexport const links = function* ({ state }) {\n  for (const [name, { dagByteLength, cid }] of state.entries) {\n    yield /** @type {UnixFS.DirectoryEntryLink} */ ({\n      name,\n      dagByteLength,\n      cid,\n    })\n  }\n}\n\n/**\n * @template L1, L2\n * @param {API.View<L1>} state\n * @param {Partial<API.Options<L1|L2>>} options\n * @returns {API.View<L1|L2>}\n */\nexport const fork = (\n  { state },\n  {\n    writer = state.writer,\n    metadata = state.metadata,\n    settings = state.settings,\n  } = {}\n) =>\n  new DirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new Map(state.entries.entries()),\n    closed: false,\n  })\n\n/**\n * @template [Layout=unknown]\n * @implements {API.View<Layout>}\n */\nclass DirectoryWriter {\n  /**\n   * @param {API.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.settings\n  }\n\n  links() {\n    return links(this)\n  }\n\n  /**\n   * @param {string} name\n   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link\n   * @param {API.WriteOptions} [options]\n   */\n\n  set(name, link, options) {\n    return set(this, name, link, options)\n  }\n\n  /**\n   * @param {string} name\n   */\n  remove(name) {\n    return remove(this, name)\n  }\n\n  /**\n   * @template L\n   * @param {Partial<API.Options<L>>} [options]\n   * @returns {API.View<Layout|L>}\n   */\n  fork(options) {\n    return fork(this, options)\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.DirectoryLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n\n  entries() {\n    return this.state.entries.entries()\n  }\n  /**\n   * @param {string} name\n   */\n  has(name) {\n    return this.state.entries.has(name)\n  }\n  get size() {\n    return this.state.entries.size\n  }\n}\n", "import * as API from \"./api.js\"\n\nexport { API }\n\n/**\n * @param {API.Uint32} size\n */\nexport const empty = (size = 32) => {\n  // We could support < 32, but it seems impractical and would negatively affect\n  // performance as we would have to do extra bound checks.\n  if (size !== 32) {\n    throw new Error(`Uint32 BitField does not support size: ${size}`)\n  }\n\n  return 0\n}\n\n/**\n * @param  {API.Uint32[]} bits\n * @param {API.Uint32} [size]\n */\nexport const from = (bits, size) => {\n  let bitfield = empty(size)\n  for (const bit of bits) {\n    bitfield = set(bitfield, bit)\n  }\n  return bitfield\n}\n\n/**\n * @param {API.Uint32} _bitField\n */\nexport const size = _bitField => 32\n\n/**\n * Reads out 5 bits at the given bit offset.\n *\n * @param {API.Uint32} bitField - Bitfield in Uint32 representation.\n * @param {API.Uint32} index - Index with-in `bitField` to read bits from.\n * @returns {API.Uint32}\n */\nconst mask = (bitField, index) => (bitField >>> index) & 0b11111\n\n/**\n * Creates mask that can be used to check a bit in nodes bitmap for the give\n * key (hash) at given depth.\n *\n * @param {API.Uint32} bitField - Key hash as 32 bit integer.\n * @param {API.Uint32} index - Index with-in the 32bit bitfield\n */\nconst offset = (bitField, index) => 1 << mask(bitField, index)\n\n/**\n * Maps numbers [0, 31] to powers of two. Creates mask that can be used\n * to check a bit in nodes bitmap for the give key (hash) at given depth.\n *\n * @param {API.Uint32} bitField - Key hash as 32 bit integer.\n * @param {API.Uint32} index - Index with-in the 32bit bitfield\n */\nexport const popcount = (bitField, index = 31) =>\n  bitCount(bitField & (offset(index, 0) - 1))\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const set = (bitField, index) => bitField | (1 << index)\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const unset = (bitField, index) => bitField & (0xff ^ (1 << index))\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const get = (bitField, index) => ((bitField >> index) & 0x1) !== 0\n\n/**\n * Counts the number of bits set in n\n * @param {API.Uint32} bitField\n */\nexport const bitCount = bitField => {\n  const n1 = bitField - ((bitField >> 1) & 0x55555555)\n  const n2 = (n1 & 0x33333333) + ((n1 >> 2) & 0x33333333)\n  const n3 = ((n2 + (n2 >> 4)) & 0xf0f0f0f) * 0x1010101\n  return n3 >> 24\n}\n\n/**\n * @param {API.Uint32} left\n * @param {API.Uint32} right\n * @returns {API.Uint32}\n */\nexport const and = (left, right) => left & right\n\n/**\n * @param {API.Uint32} left\n * @param {API.Uint32} right\n * @returns {API.Uint32}\n */\nexport const or = (left, right) => left | right\n\n/**\n * Counts the number of bits set in n\n * @param {API.Uint32} bitField\n * @returns {Uint8Array}\n */\nexport const toBytes = bitField =>\n  Uint8Array.of(\n    (bitField >> 24) & 0b1111_1111,\n    (bitField >> 16) & 0b1111_1111,\n    (bitField >> 8) & 0b1111_1111,\n    bitField & 0b1111_1111\n  )\n\n/**\n *\n * @param {Uint8Array} bytes\n * @returns {API.Uint32}\n */\nexport const fromBytes = bytes => {\n  if (bytes.length !== 4) {\n    throw new Error(`Expected 4 bytes instead got ${bytes.length}`)\n  }\n  return (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3]\n}\n", "export {}\n", "import * as API from \"./api.js\"\n// @ts-expect-error - has no types\nimport murmur from \"murmurhash3js-revisited\"\n\nconst utf8 = new TextEncoder()\n\n/**\n * @typedef {(bytes:Uint8Array) => API.Uint32} Hasher\n * @type {Hasher}\n */\nexport const hash32 = murmur.x64.hash126\n\n/**\n * @param {Partial<API.Options<API.Uint32>>} options\n * @returns {API.Path<API.Uint32>}\n */\n/* c8 ignore next 45 */\nexport const configure = ({ bitWidth = 5, hash = hash32 }) => {\n  const hashSize = 4\n  if (bitWidth > hashSize * 8) {\n    throw new RangeError(\n      `Can not use bitWidth ${bitWidth} which exceeds the hashSize ${hashSize}`\n    )\n  }\n\n  if (hashSize * 8 > 32) {\n    throw new RangeError(\n      `Can not use hashSize ${hashSize} as it can not be encoded in Uint32`\n    )\n  }\n\n  // Mask for reading `bitWidth` number of bits from the end.\n  const mask = 0xffffffff >>> (32 - bitWidth)\n\n  /**\n   * Determines bit position for the path entry at the given `depth`.\n   * ```js\n   * const key = hash(\"result\") // 0b00011010010110010101111100110010\n   * // Which is following path (in reverse as we read from the right)\n   * // 10010/11001/10111/10010/00101/01101/00000 -> [ 18, 25, 23, 18, 5, 13, 0 ]\n   * at(key, 0) // 0b10010 -> 18\n   * at(key, 1) // 0b11001 -> 25\n   * at(key, 2) // 0b10111 -> 23\n   * at(key, 3) // 0b10010 -> 18\n   * at(key, 4) // 0b00101 -> 5\n   * at(key, 5) // 0b01101 -> 13\n   * at(key, 6) // 0b00000 -> 0\n   * ```\n   *\n   * @param {API.Uint32} path\n   * @param {number} depth\n   */\n  const at = (path, depth) => (path >>> (depth * bitWidth)) & mask\n\n  /**\n   * @param {string} key\n   * @returns {API.Uint32}\n   */\n  const from = key => hash(utf8.encode(key))\n\n  return { at, from, size: Math.ceil((hashSize * 8) / bitWidth) }\n}\n", "import * as API from \"./api.js\"\nexport * from \"./api.js\"\nimport * as BitField from \"./bitfield/Uint32.js\"\nimport * as Path from \"./path/Uint32.js\"\nexport { API }\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.BitmapIndexedNode<T, K, C>}\n */\nclass BitmapIndexedNode {\n  /**\n   * @param {API.Edit|null} edit\n   * @param {ReturnType<C['BitField']['empty']>} datamap\n   * @param {ReturnType<C['BitField']['empty']>} nodemap\n   * @param {API.Children<T, K, C>} children\n   * @param {C} config\n   */\n  constructor(edit, datamap, nodemap, children, config) {\n    this.edit = edit\n    this.config = config\n    this.datamap = datamap\n    this.nodemap = nodemap\n    this.children = children\n  }\n\n  get nodeArity() {\n    return this.config.BitField.popcount(this.nodemap)\n  }\n  get dataArity() {\n    return this.config.BitField.popcount(this.datamap)\n  }\n\n  /**\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  /* c8 ignore next 3 */\n  empty() {\n    return create(this.config)\n  }\n\n  /**\n   * @template X\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {X} notFound\n   * @returns {T|X}\n   */\n\n  lookup(depth, path, key, notFound) {\n    return lookup(this, depth, path, key, notFound)\n  }\n\n  /**\n   * @template {string} R\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K|R} key\n   * @param {T} value\n   * @param {{value:boolean}} addedLeaf\n   * @returns {API.BitmapIndexedNode<T, K | R, C>}\n   */\n  associate(edit, depth, path, key, value, addedLeaf) {\n    return associate(this, edit, depth, path, key, value, addedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {{value:boolean}} removedLeaf\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  dissociate(edit, depth, path, key, removedLeaf) {\n    return dissociate(this, edit, depth, path, key, removedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  fork(edit = null) {\n    return fork(this, edit)\n  }\n\n  /**\n   * @returns {IterableIterator<[K, T]>}\n   */\n  entries() {\n    return entries(this)\n  }\n\n  /**\n   * @returns {IterableIterator<K>}\n   */\n  keys() {\n    return keys(this)\n  }\n\n  /**\n   * @returns {IterableIterator<T>}\n   */\n  values() {\n    return values(this)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.HashCollisionNode<T, K, C>}\n */\nclass HashCollisionNode {\n  /**\n   * @param {API.Edit|null} edit\n   * @param {number} count\n   * @param {API.CollisionEntries<T, K>} children\n   * @param {C} config\n   */\n  /* c8 ignore next 12 */\n  constructor(edit, count, children, config) {\n    this.edit = edit\n    this.count = count\n    this.children = children\n    this.config = config\n  }\n  get nodeArity() {\n    return /** @type {0} */ (0)\n  }\n  get dataArity() {\n    return this.count\n  }\n\n  /**\n   * @template X\n   * @param {API.Uint32} _shift\n   * @param {unknown} _path\n   * @param {K} key\n   * @param {X} notFound\n   * @returns {T|X}\n   */\n  /* c8 ignore next 3 */\n  lookup(_shift, _path, key, notFound) {\n    return lookupCollision(this, key, notFound)\n  }\n\n  /**\n   * @template {string} R\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} _shift\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K|R} key\n   * @param {T} value\n   * @param {{value:boolean}} addedLeaf\n   * @returns {API.HashCollisionNode<T, K | R, C>}\n   */\n  /* c8 ignore next 3 */\n  associate(edit, _shift, path, key, value, addedLeaf) {\n    return associateCollision(this, edit, path, key, value, addedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} _shift\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {{value:boolean}} removedLeaf\n   * @returns {API.Node<T, K, C>}\n   */\n  /* c8 ignore next 3 */\n  dissociate(edit, _shift, path, key, removedLeaf) {\n    return dissociateCollision(this, edit, path, key, removedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @returns {this}\n   */\n  /* c8 ignore next 3 */\n  fork(edit = null) {\n    return /** @type {this} */ (forkCollision(this, edit))\n  }\n\n  /**\n   * @returns {IterableIterator<[K, T]>}\n   */\n  /* c8 ignore next 3 */\n  entries() {\n    return entries(this)\n  }\n\n  /**\n   * @returns {IterableIterator<K>}\n   */\n  /* c8 ignore next 3 */\n  keys() {\n    return keys(this)\n  }\n\n  /**\n   * @returns {IterableIterator<T>}\n   */\n  /* c8 ignore next 3 */\n  values() {\n    return values(this)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @template X\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {K} name\n * @param {X} notFound\n * @returns {T|X}\n */\n/* c8 ignore next 8 */\nexport const lookupCollision = (node, name, notFound) => {\n  const { children: entries, count } = node\n  // find where entry with this name belongs\n  const n = findHashCollisionNodeIndex(entries, count, name)\n  // if entry name at this index matches given name return the value otherwise\n  // return `notFound` as we have no such entry.\n  return entries[n] === name ? /** @type {T} */ (entries[n + 1]) : notFound\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @template {string} R\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {ReturnType<C['Path']['from']>} key\n * @param {K|R} name\n * @param {T} value\n * @param {{value:boolean}} addedLeaf\n * @returns {API.HashCollisionNode<T, K | R, C>}\n */\n/* c8 ignore next 26 */\nexport const associateCollision = (node, edit, key, name, value, addedLeaf) => {\n  const { children, count } = node\n\n  const index = findHashCollisionNodeIndex(children, count, name)\n  // If entry at this index has a different name we fork the node and\n  // add a new entry.\n  if (children[index] !== name) {\n    const newNode = node.fork(edit)\n    addedLeaf.value = true\n    newNode.count += 1\n    newNode.children.splice(index, key, value)\n    return newNode\n  }\n  // If name is the same but value is not we fork the node and update\n  // the value\n  else if (children[index + 1] !== value) {\n    const newNode = node.fork(edit)\n    newNode.children[index + 1] = value\n    return newNode\n  }\n  // If we got this far entry with this exact name and value is already\n  // present making this a noop, so we return this node back.\n  else {\n    return node\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {ReturnType<C['Path']['from']>} hash\n * @param {K} name\n * @param {{value:boolean}} removedLeaf\n * @returns {API.Node<T, K, C>}\n */\n/* c8 ignore next 37 */\nexport const dissociateCollision = (node, edit, hash, name, removedLeaf) => {\n  const { children: entries, count, config } = node\n  const index = findHashCollisionNodeIndex(entries, count, name)\n  // If there is no entry with a the given name this is noop so we just\n  // return back this node.\n  if (entries[index] !== name) {\n    return node\n  } else {\n    removedLeaf.value = true\n    // If conflict contained only two entries removing one of them would\n    // leave us with no conflict which is why we create a new node with a\n    // an entry other than one that would correspond provided name\n    if (count === 2) {\n      const offset = index === 0 ? 2 : 0\n      return /** @type {API.BitmapIndexedNode<T, K, C>} */ (\n        associate(\n          create(config),\n          edit,\n          0,\n          hash,\n          /** @type {K} */ (entries[offset]),\n          /** @type {T} */ (entries[offset + 1]),\n          removedLeaf\n        )\n      )\n    }\n    // otherwise we got this far we have more than two colliding entries in\n    // which case we simply remove one corresponding to given `name`.\n    //\n    else {\n      const newNode = node.fork(edit)\n      newNode.children.splice(index, 2)\n      newNode.count -= 1\n      return newNode\n    }\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @returns {API.HashCollisionNode<T, K, C>}\n */\n/* c8 ignore next 12 */\nexport const forkCollision = (node, edit = null) => {\n  if (canEdit(node.edit, edit)) {\n    return node\n  } else {\n    return new HashCollisionNode(\n      edit,\n      node.count,\n      /** @type {API.CollisionEntries<T, K>} */ (node.children.slice()),\n      node.config\n    )\n  }\n}\n\n/**\n * Finds the index inside collision entries where given `key` belongs, which is\n * index where `key <= entries[index]` is `true`. If no index satisfies this\n * constraint index will be `entries.length` indicating that key belongs in the\n * last position.\n *\n * @template T\n * @template {string} K\n * @param {API.CollisionEntries<T, K>} entries\n * @param {number} count\n * @param {K} key\n */\n/* c8 ignore next 8 */\nconst findHashCollisionNodeIndex = (entries, count, key) => {\n  let index = 0\n  // increase index until we find a index where key <= entries[index]\n  while (index < count && entries[index] > key) {\n    index += 2\n  }\n  return index\n}\n\nconst defaultConfig = { bitWidth: 32, BitField, Path }\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Edit|null} [edit]\n * @param {C} config\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const create = (config, edit = null) =>\n  new BitmapIndexedNode(\n    edit,\n    config.BitField.empty(Math.pow(2, config.bitWidth)),\n    config.BitField.empty(Math.pow(2, config.bitWidth)),\n    /** @type {API.Children<T, K, C>} */ ([]),\n    config\n  )\n\n/**\n * @template T, U\n * @template {string} K\n * @param {API.BitmapIndexedNode<T, K>} node\n * @param {K} key\n * @param {U} notFound\n */\nexport const get = (node, key, notFound) =>\n  lookup(node, 0, node.config.Path.from(key), key, notFound)\n\n/**\n * @template T, U\n * @template {string} K\n * @template Bits, BitMap\n * @param {API.BitmapIndexedNode<T, K, API.Config<Bits, BitMap>>} node\n * @param {API.Uint32} depth\n * @param {Bits} path\n * @param {K} key\n * @param {U} notFound\n * @returns {T|U}\n */\nexport const lookup = (node, depth, path, key, notFound) => {\n  const { datamap, nodemap, config } = node\n  const { Path, BitField } = config\n  const offset = Path.at(path, depth)\n\n  // If bit is set in the data bitmap we have some key, value under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    // If key matches actual key in the map we found the the value\n    // otherwise we did not.\n    if (keyAt(node, index) === key) {\n      return valueAt(node, index)\n    } else {\n      return notFound\n    }\n  }\n  // If bit is set in the node bitmapt we have a node under the\n  // matching hash segment.\n  else if (BitField.get(nodemap, offset)) {\n    // Resolve node and continue lookup within it.\n    const child = resolveNode(node, offset)\n    return child.lookup(depth + 1, path, key, notFound)\n  }\n  // If we have neither node nor key-pair for this hash segment\n  // we return notFound.\n  else {\n    return notFound\n  }\n}\n\n/**\n * @template T, U\n * @template {string} K\n * @template {string} R\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {R} key\n * @param {T} value\n * @param {{ value: boolean }} addedLeaf\n * @returns {API.BitmapIndexedNode<T, K|R, C>}\n */\nexport const set = (node, edit, key, value, addedLeaf) =>\n  associate(node, edit, 0, node.config.Path.from(key), key, value, addedLeaf)\n\n/**\n * @template T\n * @template {string} K\n * @template {string} R\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {API.Uint32} depth\n * @param {ReturnType<C['Path']['from']>} path\n * @param {K|R} key\n * @param {T} value\n * @param {{value:boolean}} addedLeaf\n * @returns {API.BitmapIndexedNode<T, K | R, C>}\n */\nexport const associate = (node, edit, depth, path, key, value, addedLeaf) => {\n  const { datamap, nodemap, config } = node\n  const { Path, BitField } = config\n  const offset = Path.at(path, depth)\n  // If bit is set in the data bitmap we have some key, value under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    const found = keyAt(node, index)\n    // If we have entry with given name and value is the same return node\n    // as is, otherwise fork node and set the value.\n    if (key === found) {\n      return valueAt(node, index) === value\n        ? node\n        : forkAndSet(node, edit, index, value)\n    }\n    // Otherwise we need to create a branch to contain current key, value and\n    // one been passed.\n    else {\n      const branch = mergeTwoLeaves(\n        config,\n        edit,\n        depth + 1,\n        Path.from(found),\n        found,\n        valueAt(node, index),\n        path,\n        key,\n        value\n      )\n      addedLeaf.value = true\n\n      return migrateLeafToBranch(node, edit, offset, branch)\n    }\n  }\n  // If bit is set in the node bitmap we have a branch under the current\n  // hash slice.\n  else if (BitField.get(nodemap, offset)) {\n    const child = resolveNode(node, offset)\n    const newChild = child.associate(\n      edit,\n      depth + 1,\n      path,\n      key,\n      value,\n      addedLeaf\n    )\n\n    if (child === newChild) {\n      return node\n    } else {\n      return copyAndSetChild(node, edit, offset, newChild)\n    }\n  }\n  // If we have neither node nor a key-value for this hash segment. We copy\n  // current children and add new key-value pair\n  else {\n    const index = BitField.popcount(datamap, offset)\n    addedLeaf.value = true\n\n    /** @type {API.BitmapIndexedNode<T, K|R, C>} */\n    const newNode = node.fork(edit)\n\n    // Capture new entry in the data bitmap\n    newNode.datamap = BitField.set(datamap, offset)\n    newNode.children.splice(keyPosition(index), 0, key, value)\n    return newNode\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {K} key\n * @param {{ value: boolean }} removedLeaf\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nconst remove = (node, edit, key, removedLeaf) =>\n  dissociate(node, edit, 0, node.config.Path.from(key), key, removedLeaf)\n\nexport { remove as delete }\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {API.Uint32} depth\n * @param {ReturnType<C['Path']['from']>} path\n * @param {K} key\n * @param {{value:boolean}} removedLeaf\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const dissociate = (source, edit, depth, path, key, removedLeaf) => {\n  const { datamap, nodemap, config } = source\n  const { BitField, Path } = config\n  const offset = Path.at(path, depth)\n  // If bit is set in the data bitmap we have an entry under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    // If key at a given index matches given `name` we fork a node and remove\n    // the entry\n    if (key === keyAt(source, index)) {\n      removedLeaf.value = true\n      const node = fork(source, edit)\n      // Update the bitmap\n      node.datamap = BitField.unset(source.datamap, offset)\n      // remove the child\n      node.children.splice(keyPosition(index), 2)\n      return node\n    }\n    // otherwise we don't have such entry so we return node back as is.\n    else {\n      return source\n    }\n  }\n  // If bit is set in the node bitmapt we have a node under the\n  // matching hash segment.\n  else if (BitField.get(nodemap, offset)) {\n    const node = resolveNode(source, offset)\n    const child = node.dissociate(edit, depth + 1, path, key, removedLeaf)\n    // if child has a single element we need to canonicalize\n    if (hasSingleLeaf(child)) {\n      // if source has a single child, we collapse and return the child\n      // otherwise we inline the child.\n      return hasSingleNode(source)\n        ? child\n        : inlineChild(source, edit, offset, child)\n    } else if (node === child) {\n      return source\n    } else {\n      return copyAndSetChild(source, edit, offset, child)\n    }\n  }\n  // If we have neither node nor a key-value for this hash segment this is a\n  // noop.\n  else {\n    return source\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<[K, T]>}\n */\nexport const entries = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      offset += 1\n      const value = children[offset]\n      yield /** @type {[K, T]} */ ([key, value])\n      offset += 1\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K, C>} */ (\n      children[offset]\n    )\n    yield* node.entries()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const fork = (node, edit) => {\n  if (canEdit(node.edit, edit)) {\n    return node\n  } else {\n    const newNode = new BitmapIndexedNode(\n      edit,\n      node.datamap,\n      node.nodemap,\n      node.children.slice(),\n      node.config\n    )\n    return newNode\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<K>}\n */\nexport const keys = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      yield /** @type {K} */ (key)\n      offset += 2\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K>} */ (children[offset])\n    yield* node.keys()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<T>}\n */\nexport const values = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      offset += 1\n      yield /** @type {T} */ (children[offset])\n      offset += 1\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K>} */ (children[offset])\n    yield* node.values()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {T} value\n */\nexport const forkAndSet = (node, edit, offset, value) => {\n  const newNode = node.fork(edit)\n  newNode.children[valuePosition(offset)] = value\n  return newNode\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} child\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const inlineChild = (source, edit, offset, child) => {\n  const { datamap, nodemap, config } = source\n  const { BitField } = config\n  const node = fork(source, edit)\n\n  // remove the node that we are inlining\n  node.children.splice(nodePosition(source, offset), 1)\n  // add key-value pair where it wolud fall\n  node.children.splice(\n    keyPosition(BitField.popcount(datamap, offset)),\n    0,\n    child.children[0],\n    child.children[1]\n  )\n\n  node.datamap = BitField.set(datamap, offset)\n  node.nodemap = BitField.unset(nodemap, offset)\n\n  return node\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} child\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const copyAndSetChild = (node, edit, offset, child) => {\n  const newNode = fork(node, edit)\n  newNode.children[nodePosition(node, offset)] = child\n  return newNode\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} branch\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const migrateLeafToBranch = (source, edit, offset, branch) => {\n  const { nodemap, datamap, config } = source\n  const { BitField } = config\n  const index = BitField.popcount(datamap, offset)\n  // Previous id corresponds to the key position\n  const oldId = keyPosition(index)\n  const newId = nodePosition(source, offset)\n\n  const node = fork(source, edit)\n\n  // remove an old leaf\n  node.datamap = BitField.unset(datamap, offset)\n  node.children.splice(oldId, 2)\n\n  // add a new branch\n  node.nodemap = BitField.set(nodemap, offset)\n  node.children.splice(newId - 1, 0, branch)\n\n  return node\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {C} config\n * @param {API.Edit|null} edit\n * @param {number} depth\n * @param {ReturnType<C['Path']['from']>} oldPath\n * @param {K} oldKey\n * @param {T} oldValue\n * @param {ReturnType<C['Path']['from']>} newPath\n * @param {K} newKey\n * @param {T} newValue\n * @returns {API.Node<T, K, C>}\n */\nexport const mergeTwoLeaves = (\n  config,\n  edit,\n  depth,\n  oldPath,\n  oldKey,\n  oldValue,\n  newPath,\n  newKey,\n  newValue\n) => {\n  const { BitField, Path } = config\n  // If we have reached end of the path we can no longer create another\n  // `BitmapIndexedNode`, instead we create a node containing (hash) colliding\n  // entries\n  /* c8 ignore next 7 */\n  if (Path.size < depth) {\n    return new HashCollisionNode(\n      edit,\n      2,\n      [oldKey, oldValue, newKey, newValue],\n      config\n    )\n  } else {\n    const oldOffset = Path.at(oldPath, depth)\n    const newOffset = Path.at(newPath, depth)\n    // If offsets still match create another intermediery node and merge these\n    // two nodes at next depth level.\n    if (oldOffset === newOffset) {\n      return new BitmapIndexedNode(\n        edit,\n        BitField.empty(Math.pow(2, config.bitWidth)),\n        BitField.from([oldOffset], Math.pow(2, config.bitWidth)),\n        [\n          mergeTwoLeaves(\n            config,\n            edit,\n            depth + 1,\n            oldPath,\n            oldKey,\n            oldValue,\n            newPath,\n            newKey,\n            newValue\n          ),\n        ],\n        config\n      )\n    }\n    // otherwise create new node with both key-value pairs as it's children\n    else {\n      return new BitmapIndexedNode(\n        edit,\n        BitField.from([oldOffset, newOffset], Math.pow(2, config.bitWidth)),\n        BitField.empty(Math.pow(2, config.bitWidth)),\n        /** @type {API.Children<T, K, C>} */\n        (\n          // We insert child with a lower index first so that we can derive it's\n          // index on access via popcount\n          oldOffset < newOffset\n            ? [oldKey, oldValue, newKey, newValue]\n            : [newKey, newValue, oldKey, oldValue]\n        ),\n        config\n      )\n    }\n  }\n}\n\n/**\n * @template {string} K\n * @param {API.BitmapIndexedNode<unknown, K>} node\n * @param {number} index\n */\nexport const keyAt = ({ children }, index) =>\n  /** @type {K} */ (children[keyPosition(index)])\n\n/**\n * @param {number} index\n */\nexport const keyPosition = index => index * 2\n\n/**\n * @template T\n * @param {API.BitmapIndexedNode<T>} node\n * @param {number} index\n */\nexport const valueAt = ({ children }, index) =>\n  /** @type {T} */ (children[valuePosition(index)])\n\n/**\n * @param {number} index\n */\nexport const valuePosition = index => index * 2 + 1\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {number} offset\n * @returns {API.BitmapIndexedNode<T, K, C>|API.HashCollisionNode<T, K, C>}\n */\nexport const resolveNode = (node, offset) =>\n  /** @type {API.BitmapIndexedNode<T, K, C>|API.HashCollisionNode<T, K, C>} */ (\n    node.children[nodePosition(node, offset)]\n  )\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {number} offset\n */\nconst nodePosition = ({ children, nodemap, config }, offset) =>\n  children.length - 1 - config.BitField.popcount(nodemap, offset)\n\n/**\n * @param {API.Edit|null} owner\n * @param {API.Edit|null} editor\n */\nconst canEdit = (owner, editor) => owner != null && owner === editor\n\n/**\n * Returns `true` if node has a single entry. It also refines type to\n * `BitmapIndexedNode` because `HashCollisionNode` is normalized to\n * `BitmapIndexedNode` when it contains only a single entry.\n *\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {node is API.BitmapIndexedNode<T, K, C>}\n */\nconst hasSingleLeaf = node => node.nodeArity === 0 && node.dataArity === 1\n\n/**\n * Returns `true` if node has a single childe node and 0 child leaves.\n *\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @returns {node is API.BitmapIndexedNode<T, K, C>}\n */\nconst hasSingleNode = ({ config: { BitField }, datamap, nodemap }) =>\n  BitField.popcount(datamap) === 0 && BitField.popcount(nodemap) === 1\n", "import { bytes } from 'multiformats'\nimport { from } from 'multiformats/hashes/hasher'\n// @ts-expect-error no types\nimport mur from 'murmurhash3js-revisited'\n\n/**\n * @param {number} number\n * @returns {Uint8Array}\n */\nfunction fromNumberTo32BitBuf (number) {\n  const bytes = new Array(4)\n  for (let i = 0; i < 4; i++) {\n    bytes[i] = number & 0xff\n    number = number >> 8\n  }\n  return new Uint8Array(bytes)\n}\n\nexport const murmur332 = from({\n  name: 'murmur3-32',\n  code: 0x23,\n  encode: (input) => fromNumberTo32BitBuf(mur.x86.hash32(input))\n})\n\nexport const murmur3128 = from({\n  name: 'murmur3-128',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input))\n})\n\n// A special-use 0x22 that truncates 64 bits, specifically for use in the UnixFS HAMT\nexport const murmur364 = from({\n  name: 'murmur3-x64-64',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input)).subarray(0, 8)\n})\n", "import * as API from \"./api.js\"\nconst utf8 = new TextEncoder()\nimport { murmur364 } from \"@multiformats/murmur3\"\n\n/**\n * @param {Uint8Array} bytes\n */\n/* c8 ignore next 2 */\nexport const hash64 = bytes =>\n  /** @type {Uint8Array} */ (murmur364.encode(bytes))\n\n/**\n * @param {Partial<API.Options<Uint8Array>>} options\n * @returns {API.Path<Uint8Array>}\n */\n/* c8 ignore next 25 */\nexport const configure = ({ bitWidth = 8, hash = hash64 } = {}) => {\n  const hashSize = hash(new Uint8Array()).byteLength\n\n  /**\n   * @param {Uint8Array} path\n   * @param {number} depth\n   * @returns {API.Uint32}\n   */\n  const at = (path, depth) => {\n    const offset = depth * bitWidth\n    if (offset > hashSize) {\n      throw new RangeError(`Out of bounds`)\n    }\n\n    return toInt(path, offset, bitWidth)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Uint8Array}\n   */\n  const from = key => hash(utf8.encode(key))\n\n  return { from, at, size: Math.ceil((hashSize * 8) / bitWidth) }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset - bit offset\n * @param {number} count - number of bits to consume\n */\nexport const toInt = (bytes, offset, count) => {\n  let byteOffset = (offset / 8) | 0\n  let bitOffset = offset % 8\n  let desired = count\n  let bits = 0\n  while (desired > 0 && byteOffset < bytes.byteLength) {\n    const byte = bytes[byteOffset]\n    const available = 8 - bitOffset\n\n    const taking = available < desired ? available : desired\n    const bitsLeft = 8 - bitOffset - taking\n    // mask to turn of bits before bitOffset\n    const mask = 0xff >> bitOffset\n    // turn off offset bits and shift to drop remaining bit on the right\n    const value = (mask & byte) >> bitsLeft\n    bits = (bits << taking) + value\n\n    desired -= taking\n    byteOffset++\n    bitOffset = 0\n  }\n\n  return bits\n}\n", "import { bitCount, popcount as popcount32 } from \"./Uint32.js\"\nimport * as API from \"./api.js\"\n\n/**\n * @param {number} size\n */\nexport const empty = (size = 256) => {\n  if (size % 8 !== 0) {\n    throw new Error(`Must be multiple of 8`)\n  }\n\n  return new Uint8Array(size / 8)\n}\n\n/**\n * Creates bitfield with specific bits set.\n *\n * @param {number[]} bits\n * @param {number} [size]\n * @returns {Uint8Array}\n */\nexport const from = (bits, size) => {\n  let bitfield = empty(size)\n  for (const index of bits) {\n    const { byte, byteOffset, bitOffset } = at(bitfield, index)\n    bitfield[byteOffset] = byte | (1 << bitOffset)\n  }\n  return bitfield\n}\n\n/**\n * @param {Uint8Array} bitfield\n */\nexport const size = bitfield => bitfield.byteLength * 8\n\n/**\n * Compute offset for the given index\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nconst at = (bitfield, index) => {\n  const byteOffset = bitfield.byteLength - 1 - ((index / 8) | 0)\n  const bitOffset = index % 8\n  const byte = bitfield[byteOffset]\n\n  return { byte, byteOffset, bitOffset }\n}\n\n/**\n * Set a particular bit.\n *\n * @param {Uint8Array} bytes\n * @param {number} index\n * @param {number} byte\n * @returns {Uint8Array}\n */\nconst setByte = (bytes, index, byte) => {\n  if (bytes[index] !== byte) {\n    const result = bytes.slice(0)\n    result[index] = byte\n    return result\n  }\n  return bytes\n}\n\n/**\n * Set a particular bit.\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n * @returns {Uint8Array}\n */\nexport const set = (bitfield, index) => {\n  const { byte, byteOffset, bitOffset } = at(bitfield, index)\n  return setByte(bitfield, byteOffset, byte | (1 << bitOffset))\n}\n\n/**\n * Unsets a particular bit.\n\n * @param {Uint8Array} bitfield\n * @param {number} index\n * @returns {Uint8Array}\n */\nexport const unset = (bitfield, index) => {\n  const { byte, byteOffset, bitOffset } = at(bitfield, index)\n  return setByte(bitfield, byteOffset, byte & (0xff ^ (1 << bitOffset)))\n}\n\n/**\n * Returns `true` if bit at given index is set.\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nexport const get = (bitfield, index) => {\n  var { byte, bitOffset } = at(bitfield, index)\n  return ((byte >> bitOffset) & 0x1) !== 0\n}\n\n/**\n * @param {Uint8Array} bitfield\n */\nexport const toBytes = bitfield => bitfield\n\n/**\n * @param {Uint8Array} bytes\n */\nexport const fromBytes = bytes => bytes\n\n/**\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nexport const popcount = (bitfield, index = bitfield.byteLength * 8) => {\n  const { byteOffset, bitOffset, byte } = at(bitfield, index)\n\n  let count = popcount32(byte, bitOffset)\n  let offset = bitfield.byteLength - 1\n  while (offset > byteOffset) {\n    const byte = bitfield[offset]\n    count += bitCount(byte)\n    offset--\n  }\n\n  return count\n}\n\n/**\n * @param {Uint8Array} left\n * @param {Uint8Array} right\n */\nexport const or = (left, right) => {\n  const result = left.slice()\n  let offset = 0\n  while (offset < left.length) {\n    result[offset] |= right[offset]\n    offset++\n  }\n  return result\n}\n\n/**\n * @param {Uint8Array} left\n * @param {Uint8Array} right\n */\nexport const and = (left, right) => {\n  const result = left.slice()\n  let offset = 0\n  while (offset < left.length) {\n    result[offset] &= right[offset]\n    offset++\n  }\n  return result\n}\n\nexport { API }\n", "export * from \"./api.js\"\nimport * as Node from \"./node.js\"\nimport { create as createBitmapIndexedNode } from \"./node.js\"\nimport * as API from \"./api.js\"\nimport * as Uint32Path from \"./path/Uint32.js\"\nimport * as Uint8ArrayPath from \"./path/Uint8Array.js\"\nimport * as Uint32BitField from \"./bitfield/Uint32.js\"\nimport * as Uint8ArrayBitField from \"./bitfield/Uint8Array.js\"\n\nconst NOT_FOUND = new RangeError(\"Not Found\")\n\n/**\n * A `bitWidth` determines the number of bits of the hash to use for index\n * calculation at each level of the tree. In first layer will distribute\n * children by the first `bitWidth` bits of the key hash. In the next layer\n * next `bitWidth` number of bits of the key hash are used to determine\n * placement of it's children and so on. Each node in the tree will hold\n * `2 ** bitWidth` number of elements.\n *\n * For example when we insert an entry named `result` it will generate a\n * folowing hash (with murmur3 32) `442064690` which in binary would be\n *\n * ```\n * 11010010110010101111100110010\n * ```\n *\n * Which will correspond to a following key path\n *\n * ```\n * 11010/01011/00101/01111/10011/0010\n * ```\n *\n * Whis in decimals would be\n *\n * ```ts\n * 26/11/5/15/19/2'\n * ```\n *\n * If we then insert `fish` it would produce following path\n *\n * ```ts\n * 26/3/4/18/28/19/1\n * ```\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Partial<C>} [options]\n * @returns {API.PersistentHashMap<V, K, C>}\n */\nexport const empty = options => {\n  const config = configure(options)\n  return new PersistentHashMap(0, createBitmapIndexedNode(config, null), config)\n}\n\n/**\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Partial<C>} config\n * @returns {C}\n */\nconst configure = ({\n  bitWidth = 5,\n  /* c8 ignore next 4 */\n  BitField = bitWidth === 5 ? Uint32BitField : Uint8ArrayBitField,\n  Path = bitWidth === 5\n    ? Uint32Path.configure({ bitWidth })\n    : Uint8ArrayPath.configure({ bitWidth }),\n} = {}) => /** @type {C} */ ({ bitWidth, BitField, Path })\n\n/**\n * Creates HashMap from the provided entries.\n *\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Iterable<[K, V]>} entries\n * @param {Partial<C>} [options]\n * @returns {API.PersistentHashMap<V, K, C>}\n */\nexport const from = (entries, options) => {\n  const node = /** @type {API.HashMapBuilder<V, K, C>} */ (builder(options))\n  for (const [key, value] of entries) {\n    node.set(key, value)\n  }\n\n  return node.build()\n}\n\n/**\n * @template T\n * @template {string} K\n * @param {API.HAMT<T, K>} hamt\n * @param {K} key\n */\nexport const has = (hamt, key) =>\n  Node.get(hamt.root, key, NOT_FOUND) !== NOT_FOUND\n\n/**\n * @template T\n * @template {string} K\n * @template [U=undefined]\n * @param {API.HAMT<T, K>} hamt\n * @param {K} key\n * @param {U} notFound\n * @returns {T|U}\n */\nexport const get = (hamt, key, notFound = /** @type {U} */ (undefined)) =>\n  Node.get(hamt.root, key, notFound)\n\n/**\n * @template {string} K\n * @template T\n * @template {API.Config} C\n * @param {Partial<C>} [options]\n * @returns {API.HashMapBuilder<T, K, C>}\n */\nexport const builder = options => {\n  const edit = {}\n  const config = configure(options)\n  return new HashMapBuilder(\n    edit,\n    0,\n    createBitmapIndexedNode(config, edit),\n    config\n  )\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.PersistentHashMap<T, K, C>}\n */\nclass PersistentHashMap {\n  /**\n   *\n   * @param {number} count\n   * @param {API.BitmapIndexedNode<T, K, C>} root\n   * @param {C} config\n   */\n  constructor(count = 0, root, config) {\n    this.count = count\n    this.root = root\n    this.config = config\n  }\n\n  get size() {\n    return this.count\n  }\n\n  clone() {\n    return new PersistentHashMap(this.count, this.root, this.config)\n  }\n\n  /**\n   * @returns {API.PersistentHashMap<T, K, C>}\n   */\n  empty() {\n    return new PersistentHashMap(\n      0,\n      createBitmapIndexedNode(this.config, null),\n      this.config\n    )\n  }\n  /**\n   * @param {K} key\n   * @returns {boolean}\n   */\n  has(key) {\n    return has(this, key)\n  }\n  /**\n   * @param {K} key\n   * @returns {T|undefined}\n   */\n  get(key) {\n    return Node.get(this.root, key, undefined)\n  }\n  /**\n   * @template {string} R\n   * @param {R} key\n   * @param {T} value\n   * @returns {PersistentHashMap<T, K|R, C>}\n   */\n  set(key, value) {\n    const addedLeaf = { value: false }\n    const root = Node.set(this.root, null, key, value, addedLeaf)\n    if (root === this.root) {\n      return this\n    } else {\n      return new PersistentHashMap(\n        addedLeaf.value ? this.count + 1 : this.count,\n        root,\n        this.config\n      )\n    }\n  }\n  /**\n   * @param {K} key\n   */\n  delete(key) {\n    const root = Node.delete(this.root, null, key, { value: false })\n\n    if (root === this.root) {\n      return this\n    } else {\n      return new PersistentHashMap(this.count - 1, root, this.config)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  get bitField() {\n    return this.config.BitField.or(this.root.datamap, this.root.nodemap)\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  entries() {\n    return this.root.entries()\n  }\n  keys() {\n    return this.root.keys()\n  }\n  values() {\n    return this.root.values()\n  }\n\n  /**\n   * @returns {API.HashMapBuilder<T, K, C>}\n   */\n\n  createBuilder() {\n    return new HashMapBuilder({}, this.count, this.root, this.config)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n */\nclass HashMapBuilder {\n  /**\n   * @param {API.Edit} edit\n   * @param {number} count\n   * @param {API.BitmapIndexedNode<T, K, C>} root\n   * @param {C} config\n   */\n  constructor(edit, count, root, config) {\n    /**\n     * @type {API.Edit|null}\n     * @private\n     */\n    this.edit = edit\n    /**\n     * @private\n     */\n    this.count = count\n    this.root = root\n    this.config = config\n  }\n\n  get size() {\n    if (this.edit) {\n      return this.count\n    } else {\n      throw new Error(`.size was accessed on the finalized builder`)\n    }\n  }\n  /**\n   * @template {string} R\n   * @param {R} key\n   * @param {T} value\n   * @returns {HashMapBuilder<T, K|R, C>}\n   */\n  set(key, value) {\n    if (this.edit) {\n      const addedLeaf = { value: false }\n      const root = Node.set(this.root, this.edit, key, value, addedLeaf)\n\n      if (this.root !== root) {\n        this.root = /** @type {API.BitmapIndexedNode<T, K, C>} */ (root)\n      }\n\n      if (addedLeaf.value) {\n        this.count += 1\n      }\n\n      return this\n    } else {\n      throw new Error(`.set was called on the finalized builder`)\n    }\n  }\n  /**\n   * @param {K} key\n   */\n  delete(key) {\n    if (this.edit) {\n      if (this.count === 0) {\n        return this\n      }\n      const removedLeaf = { value: false }\n      const root = Node.delete(this.root, this.edit, key, removedLeaf)\n\n      if (root !== this.root) {\n        this.root = root\n      }\n      if (removedLeaf.value) {\n        this.count -= 1\n      }\n      return this\n    } else {\n      throw new Error(`.delete was called on the finalized builder`)\n    }\n  }\n\n  build() {\n    if (this.edit) {\n      this.edit = null\n      return new PersistentHashMap(this.count, this.root, this.config)\n    } else {\n      throw new Error(`.build was called on the finalized builder`)\n    }\n  }\n}\n", "import * as API from \"./api.js\"\nimport { toInt } from \"./Uint8Array.js\"\nimport { murmur364 } from \"@multiformats/murmur3\"\nconst utf8 = new TextEncoder()\n\n/**\n * @param {Uint8Array} bytes\n */\nexport const hash64 = bytes =>\n  /** @type {Uint8Array} */ (murmur364.encode(bytes))\n\n/**\n * @param {Partial<API.Options<Uint8Array>>} options\n * @returns {API.Path<Uint8Array>}\n */\nexport const configure = ({ bitWidth = 8, hash = hash64 }) => {\n  const hashSize = hash(new Uint8Array()).byteLength\n  const options = { bitWidth, hash, hashSize }\n\n  /**\n   * @param {Uint8Array} path\n   * @param {number} depth\n   * @returns {API.Uint32}\n   */\n  const at = (path, depth) => read(path, depth, options)\n\n  /**\n   * @param {string} key\n   */\n  const from = key => utf8.encode(key)\n\n  return { at, from, size: Infinity }\n}\n\n/**\n * @param {Uint8Array} key\n * @param {number} depth\n * @param {object} options\n * @param {number} [options.bitWidth]\n * @param {number} options.hashSize\n * @param {(input:Uint8Array) => Uint8Array} options.hash\n */\nexport const read = (key, depth = 0, { bitWidth = 8, hash, hashSize }) => {\n  // key digest consists of infinite number of hash frames that are computed\n  // from key + frame n which looks like\n  // [hash(key), hash([key, 1]), hash([key, n])]\n  // You can think of the hash as concatination of all frames. Here we calculate\n  // frame bit size from hash size as we going to use that several times.\n  const frameBitSize = hashSize * 8\n\n  // We start with 0 digest and required `bitCount` corresponding to `bitWith`.\n  // In the loop we'll going to consume `bitCount` hash bits.\n  let digest = 0\n  let bitCount = bitWidth\n  // Calculate absolute bit offset within the key digest.\n  let bitOffset = bitWidth * depth\n  while (bitCount > 0) {\n    // We derive frame number based on current bit offset.\n    const frameOffset = (bitOffset / frameBitSize) >> 0\n    // Then we compute that hash frame\n    const frame =\n      frameOffset === 0 ? hash(key) : hash(appendByte(key, frameOffset))\n\n    // compute bit offset within the current frame\n    const offset =\n      frameBitSize <= bitOffset ? bitOffset % frameBitSize : bitOffset\n    // calculate number of bits remaining in this frame\n    const maxBits = frameBitSize - offset\n    // we will consume all required bits from frame if enough are available\n    // otherwise we consume whatever's available and continue rest in the next\n    // cycle(s).\n    const count = maxBits < bitCount ? maxBits : bitCount\n    digest = (digest << count) + toInt(frame, offset, count)\n    bitCount -= count\n    bitOffset += count\n  }\n\n  return digest\n}\n\n/**\n * @param {Uint8Array} source\n * @param {number} byte\n */\nconst appendByte = (source, byte) => {\n  const bytes = new Uint8Array(source.byteLength + 1).fill(\n    byte,\n    source.byteLength\n  )\n  bytes.set(source)\n  return bytes\n}\n", "import * as HAMT from \"./lib.js\"\nimport * as Node from \"./node.js\"\nimport * as Path from \"./path/InfiniteUint8Array.js\"\n\nexport * from \"./api.js\"\n\nexport { Path }\n\nexport const bitWidth = 8\nexport const config = {\n  bitWidth,\n  Path: Path.configure({ bitWidth }),\n}\n\n/**\n * @param {HAMT.PersistentHashMap} hamt\n */\nexport const tableSize = hamt => Math.pow(2, hamt.config.bitWidth)\n\n/**\n * @template [T=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Partial<C>} options\n * @returns {HAMT.PersistentHashMap<T, K, C>}\n */\nexport const empty = (options = /** @type {C} */ (config)) =>\n  HAMT.empty(options)\n\n/**\n * @template [T=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Partial<C>} options\n * @returns {HAMT.HashMapBuilder<T, K, C>}\n */\nexport const builder = (options = /** @type {C} */ (config)) =>\n  HAMT.builder(options)\n\n/**\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Iterable<[K, V]>} entries\n * @param {Partial<C>} options\n */\nexport const from = (entries, options = /** @type {C} */ (config)) =>\n  HAMT.from(entries, options)\n\n/**\n * @template T\n * @template {string} K\n * @template Bits, Bitmap\n * @param {HAMT.BitmapIndexedNode<T, K, HAMT.Config<Bits, Bitmap>>} hamt\n */\nexport const bitField = ({ datamap, nodemap, config: { BitField } }) =>\n  withoutLeadingZeros(BitField.toBytes(BitField.or(datamap, nodemap)))\n\n/**\n * @param {Uint8Array} bytes\n */\nconst withoutLeadingZeros = bytes => {\n  let offset = 0\n  while (offset < bytes.byteLength) {\n    if (bytes[offset] !== 0) {\n      return bytes.subarray(offset)\n    }\n    offset += 1\n  }\n  return bytes.subarray(offset)\n}\n\n/**\n * Maps HAMT node into IPFS UnixFS compatible format.\n *\n * @template T\n * @template {string} K\n * @template {HAMT.Config} C\n * @param {HAMT.BitmapIndexedNode<T, K, C>} root\n * @returns {IterableIterator<{prefix:string, key:K, value:T, node?:void}|{prefix:string, node:HAMT.BitmapIndexedNode<T, K, C>}>}\n */\nexport const iterate = function* (root) {\n  const { config, datamap, nodemap } = root\n  const { BitField: bitfield } = config\n  const size = bitfield.size(datamap)\n  let bitOffset = 0\n  let dataCount = 0\n  while (bitOffset < size) {\n    const prefix = bitOffset.toString(16).toUpperCase().padStart(2, \"0\")\n    if (bitfield.get(datamap, bitOffset)) {\n      const key = Node.keyAt(root, dataCount)\n      yield {\n        prefix,\n        key,\n        value: Node.valueAt(root, dataCount),\n      }\n      dataCount++\n    } else if (bitfield.get(nodemap, bitOffset)) {\n      yield {\n        prefix,\n        // UnixFS never contains hash collision nodes because it uses\n        // inifinite hashes\n        node: /** @type {HAMT.BitmapIndexedNode<T, K, C>} */ (\n          Node.resolveNode(root, bitOffset)\n        ),\n      }\n    }\n    bitOffset++\n  }\n}\n", "import { bytes as binary, CID } from './index.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\nfunction readonly ({ enumerable = true, configurable = false } = {}) {\n  return { enumerable, configurable, writable: false }\n}\n\n/**\n * @param {[string|number, string]} path\n * @param {any} value\n * @returns {Iterable<[string, CID]>}\n */\nfunction * linksWithin (path, value) {\n  if (value != null && typeof value === 'object') {\n    if (Array.isArray(value)) {\n      for (const [index, element] of value.entries()) {\n        const elementPath = [...path, index]\n        const cid = CID.asCID(element)\n        if (cid) {\n          yield [elementPath.join('/'), cid]\n        } else if (typeof element === 'object') {\n          yield * links(element, elementPath)\n        }\n      }\n    } else {\n      const cid = CID.asCID(value)\n      if (cid) {\n        yield [path.join('/'), cid]\n      } else {\n        yield * links(value, path)\n      }\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nfunction * links (source, base) {\n  if (source == null || source instanceof Uint8Array) {\n    return\n  }\n  const cid = CID.asCID(source)\n  if (cid) {\n    yield [base.join('/'), cid]\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = /** @type {[string|number, string]} */ ([...base, key])\n    yield * linksWithin(path, value)\n  }\n}\n\n/**\n * @param {[string|number, string]} path\n * @param {any} value\n * @returns {Iterable<string>}\n */\nfunction * treeWithin (path, value) {\n  if (Array.isArray(value)) {\n    for (const [index, element] of value.entries()) {\n      const elementPath = [...path, index]\n      yield elementPath.join('/')\n      if (typeof element === 'object' && !CID.asCID(element)) {\n        yield * tree(element, elementPath)\n      }\n    }\n  } else {\n    yield * tree(value, path)\n  }\n}\n\n/**\n * @template T\n * @param {T} source\n * @param {Array<string|number>} base\n * @returns {Iterable<string>}\n */\nfunction * tree (source, base) {\n  if (source == null || typeof source !== 'object') {\n    return\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = /** @type {[string|number, string]} */ ([...base, key])\n    yield path.join('/')\n    if (value != null && !(value instanceof Uint8Array) && typeof value === 'object' && !CID.asCID(value)) {\n      yield * treeWithin(path, value)\n    }\n  }\n}\n\n/**\n *\n * @template T\n * @param {T} source\n * @param {string[]} path\n * @returns {API.BlockCursorView<unknown>}\n */\nfunction get (source, path) {\n  let node = /** @type {Record<string, any>} */(source)\n  for (const [index, key] of path.entries()) {\n    node = node[key]\n    if (node == null) {\n      throw new Error(`Object has no property at ${path.slice(0, index + 1).map(part => `[${JSON.stringify(part)}]`).join('')}`)\n    }\n    const cid = CID.asCID(node)\n    if (cid) {\n      return { value: cid, remaining: path.slice(index + 1).join('/') }\n    }\n  }\n  return { value: node }\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} C - multicodec code corresponding to codec used to encode the block\n * @template {number} A - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @implements {API.BlockView<T, C, A, V>}\n */\nclass Block {\n  /**\n   * @param {object} options\n   * @param {CID<T, C, A, V>} options.cid\n   * @param {API.ByteView<T>} options.bytes\n   * @param {T} options.value\n   */\n  constructor ({ cid, bytes, value }) {\n    if (!cid || !bytes || typeof value === 'undefined') { throw new Error('Missing required argument') }\n\n    this.cid = cid\n    this.bytes = bytes\n    this.value = value\n    this.asBlock = this\n\n    // Mark all the properties immutable\n    Object.defineProperties(this, {\n      cid: readonly(),\n      bytes: readonly(),\n      value: readonly(),\n      asBlock: readonly()\n    })\n  }\n\n  links () {\n    return links(this.value, [])\n  }\n\n  tree () {\n    return tree(this.value, [])\n  }\n\n  /**\n   *\n   * @param {string} [path]\n   * @returns {API.BlockCursorView<unknown>}\n   */\n  get (path = '/') {\n    return get(this.value, path.split('/').filter(Boolean))\n  }\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @param {object} options\n * @param {T} options.value\n * @param {API.BlockEncoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg>>}\n */\nasync function encode ({ value, codec, hasher }) {\n  if (typeof value === 'undefined') throw new Error('Missing required argument \"value\"')\n  if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher')\n\n  const bytes = codec.encode(value)\n  const hash = await hasher.digest(bytes)\n  /** @type {CID<T, Code, Alg, 1>} */\n  const cid = CID.create(\n    1,\n    codec.code,\n    hash\n  )\n\n  return new Block({ value, bytes, cid })\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @param {object} options\n * @param {API.ByteView<T>} options.bytes\n * @param {API.BlockDecoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg>>}\n */\nasync function decode ({ bytes, codec, hasher }) {\n  if (!bytes) throw new Error('Missing required argument \"bytes\"')\n  if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher')\n\n  const value = codec.decode(bytes)\n  const hash = await hasher.digest(bytes)\n  /** @type {CID<T, Code, Alg, 1>} */\n  const cid = CID.create(1, codec.code, hash)\n\n  return new Block({ value, bytes, cid })\n}\n\n/**\n * @typedef {object} RequiredCreateOptions\n * @property {CID} options.cid\n */\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @param {{ cid: API.Link<T, Code, Alg, V>, value:T, codec?: API.BlockDecoder<Code, T>, bytes: API.ByteView<T> }|{cid:API.Link<T, Code, Alg, V>, bytes:API.ByteView<T>, value?:void, codec:API.BlockDecoder<Code, T>}} options\n * @returns {API.BlockView<T, Code, Alg, V>}\n */\nfunction createUnsafe ({ bytes, cid, value: maybeValue, codec }) {\n  const value = maybeValue !== undefined\n    ? maybeValue\n    : (codec && codec.decode(bytes))\n\n  if (value === undefined) throw new Error('Missing required argument, must either provide \"value\" or \"codec\"')\n\n  return new Block({\n    // eslint-disable-next-line object-shorthand\n    cid: /** @type {CID<T, Code, Alg, V>} */ (cid),\n    bytes,\n    value\n  })\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @param {object} options\n * @param {API.Link<T, Code, Alg, V>} options.cid\n * @param {API.ByteView<T>} options.bytes\n * @param {API.BlockDecoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg, V>>}\n */\nasync function create ({ bytes, cid, hasher, codec }) {\n  if (!bytes) throw new Error('Missing required argument \"bytes\"')\n  if (!hasher) throw new Error('Missing required argument \"hasher\"')\n  const value = codec.decode(bytes)\n  const hash = await hasher.digest(bytes)\n  if (!binary.equals(cid.multihash.bytes, hash.bytes)) {\n    throw new Error('CID hash does not match bytes')\n  }\n\n  return createUnsafe({\n    bytes,\n    cid,\n    value,\n    codec\n  })\n}\n\nexport { encode, decode, create, createUnsafe, Block }\n", "\nimport * as PermaMap from \"@perma/map\"\nimport * as UnixFSPermaMap from \"@perma/map/unixfs\"\nimport * as PB from \"@ipld/dag-pb\"\nimport { murmur364 } from \"@multiformats/murmur3\"\nimport { Block } from 'multiformats/block'\nimport * as API from \"./directory/api.js\"\nimport * as File from \"./file.js\"\nimport * as UnixFS from \"./codec.js\"\nimport { set, remove } from \"./directory.js\"\n\nexport * from \"./directory/api.js\"\nexport { set, remove } from \"./directory.js\"\n\nexport const configure = File.configure\nexport const defaults = File.defaults\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} config\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, settings = defaults(), metadata = {} }) =>\n  new HAMTDirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new HashMap(),\n    closed: false,\n  })\n\n/**\n * @template {API.State} Writer\n * @param {Writer} writer\n * @returns {Writer}\n */\nconst asWritable = writer => {\n  if (!writer.closed) {\n    return writer\n  } else {\n    throw new Error(\"Can not change written HAMT directory, but you can .fork() and make changes to it\")\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @param {API.CloseOptions} options\n * @returns {Promise<UnixFS.DirectoryLink>}\n */\nexport const close = async (\n  view,\n  { closeWriter = false, releaseLock = false } = {}\n) => {\n  const { writer, settings, metadata } = asWritable(view.state)\n  view.state.closed = true\n\n  const { entries } = view.state\n  /* c8 ignore next 3 */\n  if (!(entries instanceof HashMap)) {\n    throw new Error(`not a HAMT: ${entries}`)\n  }\n\n  const hamt = entries.builder.build()\n  const blocks = iterateBlocks(hamt, hamt.root, settings)\n\n  /** @type {UnixFS.BlockView<UnixFS.DirectoryShard>?} */\n  let root = null\n  for await (const block of blocks) {\n    root = block\n    // we make sure that writer has some capacity for this write. If it\n    // does not we await.\n    if ((writer.desiredSize || 0) <= 0) {\n      await writer.ready\n    }\n    // once writer has some capacity we write a block, however we do not\n    // await completion as we don't care when it's taken off the stream.\n    writer.write(block)\n  }\n  /* c8 ignore next */\n  if (root == null) throw new Error(\"no root block yielded\")\n\n  if (closeWriter) {\n    await writer.close()\n  } else if (releaseLock) {\n    writer.releaseLock()\n  }\n\n  return {\n    cid: root.cid,\n    dagByteLength: UnixFS.cumulativeDagByteLength(root.bytes, root.value.entries),\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {UnixFSPermaMap.PersistentHashMap<API.EntryLink>} hamt\n * @param {UnixFSPermaMap.BitmapIndexedNode<API.EntryLink>} node\n * @param {API.EncoderSettings<Layout>} settings\n * @returns {AsyncIterableIterator<UnixFS.BlockView<UnixFS.DirectoryShard>>}\n */\nconst iterateBlocks = async function* (hamt, node, settings) {\n  /** @type {UnixFS.DirectoryEntryLink[]} */\n  const entries = []\n  for (const ent of UnixFSPermaMap.iterate(node)) {\n    if ('key' in ent) {\n      entries.push(/** @type {UnixFS.DirectoryEntryLink} */ ({\n        name: `${ent.prefix ?? ''}${ent.key ?? ''}`,\n        dagByteLength: ent.value.dagByteLength,\n        cid: ent.value.cid,\n      }))\n    } else {\n      /** @type {UnixFS.BlockView<UnixFS.DirectoryShard>?} */\n      let root = null\n      for await (const block of iterateBlocks(hamt, ent.node, settings)) {\n        yield block\n        root = block\n      }\n      /* c8 ignore next */\n      if (root == null) throw new Error(\"no root block yielded\")\n\n      entries.push(/** @type {UnixFS.ShardedDirectoryLink} */ ({\n        name: ent.prefix,\n        dagByteLength: UnixFS.cumulativeDagByteLength(root.bytes, root.value.entries),\n        cid: root.cid\n      }))\n    }\n  }\n\n  const shard = UnixFS.createDirectoryShard(\n    entries,\n    UnixFSPermaMap.bitField(node),\n    UnixFSPermaMap.tableSize(hamt),\n    murmur364.code\n  )\n  yield await encodeHAMTShardBlock(shard, settings)\n}\n\n/**\n * @template {unknown} Layout\n * @param {UnixFS.DirectoryShard} shard\n * @param {API.EncoderSettings<Layout>} settings\n * @returns {Promise<UnixFS.BlockView<UnixFS.DirectoryShard>>}\n */\nasync function encodeHAMTShardBlock (shard, settings) {\n  const bytes = UnixFS.encodeHAMTShard(shard)\n  const hash = await settings.hasher.digest(bytes)\n  const cid = settings.linker.createLink(PB.code, hash)\n  // @ts-ignore Link is not CID\n  return new Block({ cid, bytes, value: shard })\n}\n\n/**\n * @template L1, L2\n * @param {API.View<L1>} state\n * @param {Partial<API.Options<L1|L2>>} options\n * @returns {API.View<L1|L2>}\n */\nexport const fork = (\n  { state },\n  {\n    writer = state.writer,\n    metadata = state.metadata,\n    settings = state.settings,\n  } = {}\n) =>\n  new HAMTDirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new HashMap(UnixFSPermaMap.from(state.entries.entries()).createBuilder()),\n    closed: false,\n  })\n\n/**\n * @template [Layout=unknown]\n * @implements {API.View<Layout>}\n */\nclass HAMTDirectoryWriter {\n  /**\n   * @param {API.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.settings\n  }\n\n  /**\n   * @param {string} name\n   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link\n   * @param {API.WriteOptions} [options]\n   */\n\n  set(name, link, options) {\n    return set(this, name, link, options)\n  }\n\n  /**\n   * @param {string} name\n   */\n  remove(name) {\n    return remove(this, name)\n  }\n\n  /**\n   * @template L\n   * @param {Partial<API.Options<L>>} [options]\n   * @returns {API.View<Layout|L>}\n   */\n  fork(options) {\n    return fork(this, options)\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.DirectoryLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n\n  entries() {\n    return this.state.entries.entries()\n  }\n  /**\n   * @param {string} name\n   */\n  has(name) {\n    return this.state.entries.has(name)\n  }\n  get size() {\n    return this.state.entries.size\n  }\n}\n\n/**\n * @implements {Map<string, API.EntryLink>}\n */\nclass HashMap extends Map {\n  /**\n   * @param {UnixFSPermaMap.HashMapBuilder} [builder]\n   */\n  constructor (builder = UnixFSPermaMap.builder()) {\n    super()\n    /** @type {UnixFSPermaMap.HashMapBuilder} */\n    this.builder = builder\n  }\n\n  clear() {\n    this.builder = UnixFSPermaMap.builder()\n  }\n\n  /**\n   * @param {string} key\n   */\n  delete(key) {\n    const { root } = this.builder\n    this.builder.delete(key)\n    return this.builder.root !== root\n  }\n\n  /**\n   * @param {(value: API.EntryLink, key: string, map: Map<string, API.EntryLink>) => void} callbackfn\n   * @param {any} [thisArg]\n   */\n  forEach(callbackfn, thisArg = this) {\n    for (const [k, v] of this.builder.root.entries()) {\n      callbackfn.call(thisArg, v, k, this)\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  get(key) {\n    return PermaMap.get(this.builder, key)\n  }\n\n  /**\n   * @param {string} key\n   */\n  has(key) {\n    return PermaMap.has(this.builder, key)\n  }\n\n  /**\n   * @param {string} key \n   * @param {API.EntryLink} value \n   */\n  set(key, value) {\n    this.builder.set(key, value)\n    return this\n  }\n\n  get size () {\n    return this.builder.size\n  }\n\n  [Symbol.iterator]() {\n    return this.builder.root.entries()\n  }\n\n  entries() {\n    return this.builder.root.entries()\n  }\n\n  keys() {\n    return this.builder.root.keys()\n  }\n\n  values() {\n    return this.builder.root.values()\n  }\n}\n", "import * as API from \"./api.js\"\nimport * as File from \"./file.js\"\nimport * as Directory from \"./directory.js\"\n\nexport * from \"./api.js\"\n\nexport { encode, decode, NodeType, code } from \"./codec.js\"\nexport {\n  create as createFileWriter,\n  close as closeFile,\n  write,\n  configure,\n  defaults,\n  UnixFSLeaf,\n  UnixFSRawLeaf,\n} from \"./file.js\"\nexport {\n  create as createDirectoryWriter,\n  close as closeDirectory,\n  fork as forkDirectory,\n  set,\n  remove,\n} from \"./directory.js\"\nexport {\n  create as createShardedDirectoryWriter,\n  close as closeShardedDirectory,\n  fork as forkShardedDirectory,\n} from \"./sharded-directory.js\"\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} options\n * @returns {API.View<Layout>}\n */\nexport const createWriter = ({ writable, settings = File.defaults() }) =>\n  new FileSystemWriter({\n    writer: writable.getWriter(),\n    settings,\n  })\n\n/**\n * @template {{writer:API.BlockWriter}} View\n * @param {View} view\n * @param {API.CloseOptions} options\n */\nexport const close = async (\n  view,\n  { releaseLock = true, closeWriter = true } = {}\n) => {\n  if (closeWriter) {\n    await view.writer.close()\n  } else if (releaseLock) {\n    view.writer.releaseLock()\n  }\n\n  return view\n}\n\n/**\n * @template [Layout=unknown]\n * @implemets {API.View<Layout>}\n */\nclass FileSystemWriter {\n  /**\n   * @param {object} options\n   * @param {API.BlockWriter} options.writer\n   * @param {Partial<API.EncoderSettings<Layout>>} options.settings\n   */\n  constructor({ writer, settings }) {\n    this.writer = writer\n    this.settings = File.configure(settings)\n  }\n\n  /**\n   * @template [L=unknown]\n   * @param {API.WriterOptions<L|Layout>} config\n   */\n  createFileWriter({ settings = this.settings, metadata } = {}) {\n    return File.create({\n      writer: this.writer,\n      settings,\n      metadata,\n    })\n  }\n\n  /**\n   * @template [L=unknown]\n   * @param {API.WriterOptions<L|Layout>} config\n   */\n  createDirectoryWriter({ settings = this.settings, metadata } = {}) {\n    return Directory.create({\n      writer: this.writer,\n      settings,\n      metadata,\n    })\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   */\n  close(options) {\n    return close(this, options)\n  }\n}\n\n// BlockSizeLimit specifies the maximum size an imported block can have.\n// @see https://github.com/ipfs/go-unixfs/blob/68c015a6f317ed5e21a4870f7c423a4b38b90a96/importer/helpers/helpers.go#L7-L8\nexport const BLOCK_SIZE_LIMIT = 1048576 // 1 MB\nexport const defaultCapacity = BLOCK_SIZE_LIMIT * 100\n\n/**\n * Creates `QueuingStrategy` that can fit blocks with total size up to given\n * byteLength.\n *\n * @param {number} byteLength\n * @returns {Required<QueuingStrategy<API.Block>>}\n */\nexport const withCapacity = (byteLength = defaultCapacity) => ({\n  highWaterMark: byteLength,\n  size: block => block.bytes.length,\n})\n", null, "import fs from 'fs'\nimport { Readable } from 'stream'\nimport { CID } from 'multiformats/cid'\nimport { CarIndexer } from './indexer.js'\nimport { CarReader as NodeCarReader } from './reader.js'\n\n/**\n * @typedef {import('fs').promises.FileHandle} FileHandle\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockIndex} BlockIndex\n * @typedef {import('./api').CarReader} CarReaderIface\n * @typedef {import('./reader-browser').CarReader} CarReader\n * @typedef {{ blockLength:number, blockOffset:number }} RawLocation\n */\n\n/**\n * A form of {@link CarReader} that pre-indexes a CAR archive from a file and\n * provides random access to blocks within the file using the index data. This\n * function is **only available in Node.js** and not a browser environment.\n *\n * For large CAR files, using this form of `CarReader` can be singificantly more\n * efficient in terms of memory. The index consists of a list of `CID`s and\n * their location within the archive (see {@link CarIndexer}). For large numbers\n * of blocks, this index can also occupy a significant amount of memory. In some\n * cases it may be necessary to expand the memory capacity of a Node.js instance\n * to allow this index to fit. (e.g. by running with\n * `NODE_OPTIONS=\"--max-old-space-size=16384\"`).\n *\n * As an `CarIndexedReader` instance maintains an open file descriptor for its\n * CAR file, an additional {@link CarReader#close} method is attached. This\n * _must_ be called to have full clean-up of resources after use.\n *\n * Load this class with either\n * `import { CarIndexedReader } from '@ipld/car/indexed-reader'`\n * (`const { CarIndexedReader } = require('@ipld/car/indexed-reader')`). Or\n * `import { CarIndexedReader } from '@ipld/car'`\n * (`const { CarIndexedReader } = require('@ipld/car')`). The former will likely\n * result in smaller bundle sizes where this is important.\n *\n * @name CarIndexedReader\n * @class\n * @implements {CarReaderIface}\n * @extends {CarReader}\n * @property {number} version The version number of the CAR referenced by this\n * reader (should be `1`).\n */\nexport class CarIndexedReader {\n  /**\n   * @param {number} version\n   * @param {string} path\n   * @param {CID[]} roots\n   * @param {Map<string, RawLocation>} index\n   * @param {string[]} order\n   */\n  constructor (version, path, roots, index, order) {\n    this._version = version\n    this._path = path\n    this._roots = roots\n    this._index = index\n    this._order = order\n    this._fd = null\n  }\n\n  get version () {\n    return this._version\n  }\n\n  /**\n   * See {@link CarReader#getRoots}\n   *\n   * @function\n   * @memberof CarIndexedReader\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._roots\n  }\n\n  /**\n   * See {@link CarReader#has}\n   *\n   * @function\n   * @memberof CarIndexedReader\n   * @instance\n   * @async\n   * @param {CID} key\n   * @returns {Promise<boolean>}\n   */\n  async has (key) {\n    return this._index.has(key.toString())\n  }\n\n  /**\n   * See {@link CarReader#get}\n   *\n   * @function\n   * @memberof CarIndexedReader\n   * @instance\n   * @async\n   * @param {CID} key\n   * @returns {Promise<Block | undefined>}\n   */\n  async get (key) {\n    const blockIndex = this._index.get(key.toString())\n    if (!blockIndex) {\n      return undefined\n    }\n    if (!this._fd) {\n      this._fd = await fs.promises.open(this._path, 'r')\n    }\n    const readIndex = {\n      cid: key,\n      length: 0,\n      offset: 0,\n      blockLength: blockIndex.blockLength,\n      blockOffset: blockIndex.blockOffset\n    }\n    return NodeCarReader.readRaw(this._fd, readIndex)\n  }\n\n  /**\n   * See {@link CarReader#blocks}\n   *\n   * @function\n   * @memberof CarIndexedReader\n   * @instance\n   * @async\n   * @generator\n   * @returns {AsyncGenerator<Block>}\n   */\n  async * blocks () {\n    for (const cidStr of this._order) {\n      const block = await this.get(CID.parse(cidStr))\n      /* c8 ignore next 3 */\n      if (!block) {\n        throw new Error('Unexpected internal error')\n      }\n      yield block\n    }\n  }\n\n  /**\n   * See {@link CarReader#cids}\n   *\n   * @function\n   * @memberof CarIndexedReader\n   * @instance\n   * @async\n   * @generator\n   * @returns {AsyncGenerator<CID>}\n   */\n  async * cids () {\n    for (const cidStr of this._order) {\n      yield CID.parse(cidStr)\n    }\n  }\n\n  /**\n   * Close the underlying file descriptor maintained by this `CarIndexedReader`.\n   * This must be called for proper resource clean-up to occur.\n   *\n   * @function\n   * @memberof CarIndexedReader\n   * @instance\n   * @async\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this._fd) {\n      return this._fd.close()\n    }\n  }\n\n  /**\n   * Instantiate an {@link CarIndexedReader} from a file with the provided\n   * `path`. The CAR file is first indexed with a full path that collects `CID`s\n   * and block locations. This index is maintained in memory. Subsequent reads\n   * operate on a read-only file descriptor, fetching the block from its in-file\n   * location.\n   *\n   * For large archives, the initial indexing may take some time. The returned\n   * `Promise` will resolve only after this is complete.\n   *\n   * @async\n   * @static\n   * @memberof CarIndexedReader\n   * @param {string} path\n   * @returns {Promise<CarIndexedReader>}\n   */\n  static async fromFile (path) {\n    if (typeof path !== 'string') {\n      throw new TypeError('fromFile() requires a file path string')\n    }\n\n    const iterable = await CarIndexer.fromIterable(Readable.from(fs.createReadStream(path)))\n    /** @type {Map<string, RawLocation>} */\n    const index = new Map()\n    /** @type {string[]} */\n    const order = []\n    for await (const { cid, blockLength, blockOffset } of iterable) {\n      const cidStr = cid.toString()\n      index.set(cidStr, { blockLength, blockOffset })\n      order.push(cidStr)\n    }\n    return new CarIndexedReader(iterable.version, path, await iterable.getRoots(), index, order)\n  }\n}\n\nexport const __browser = false\n", "import { decode as decodeDagCbor } from '@ipld/dag-cbor'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js'\nimport { CarV1HeaderOrV2Pragma } from './header-validator.js'\n\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockHeader} BlockHeader\n * @typedef {import('./api').BlockIndex} BlockIndex\n * @typedef {import('./coding').BytesReader} BytesReader\n * @typedef {import('./coding').CarHeader} CarHeader\n * @typedef {import('./coding').CarV2Header} CarV2Header\n * @typedef {import('./coding').CarV2FixedHeader} CarV2FixedHeader\n * @typedef {import('./coding').CarDecoder} CarDecoder\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name async decoder.readHeader(reader)\n * @param {BytesReader} reader\n * @param {number} [strictVersion]\n * @returns {Promise<CarHeader|CarV2Header>}\n */\nexport async function readHeader (reader, strictVersion) {\n  const length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)')\n  }\n  const header = await reader.exactly(length, true)\n  const block = decodeDagCbor(header)\n  if (CarV1HeaderOrV2Pragma.toTyped(block) === undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  if ((block.version !== 1 && block.version !== 2) || (strictVersion !== undefined && block.version !== strictVersion)) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`)\n  }\n  if (block.version === 1) {\n    // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory\n    if (!Array.isArray(block.roots)) {\n      throw new Error('Invalid CAR header format')\n    }\n    return block\n  }\n  // version 2\n  if (block.roots !== undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true))\n  reader.seek(v2Header.dataOffset - reader.pos)\n  const v1Header = await readHeader(reader, 1)\n  return Object.assign(v1Header, v2Header)\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<CID>}\n */\nasync function readCid (reader) {\n  const first = await reader.exactly(2, false)\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = await reader.exactly(34, true)\n    const multihash = Digest.decode(bytes)\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash)\n  }\n\n  const version = decodeVarint(await reader.upTo(8), reader)\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`)\n  }\n  const codec = decodeVarint(await reader.upTo(8), reader)\n  const bytes = await reader.exactly(getMultihashLength(await reader.upTo(8)), true)\n  const multihash = Digest.decode(bytes)\n  return CID.create(version, codec, multihash)\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesReader} reader\n * @returns {Promise<BlockHeader>}\n */\nexport async function readBlockHead (reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos\n  let length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)')\n  }\n  length += (reader.pos - start)\n  const cid = await readCid(reader)\n  const blockLength = length - Number(reader.pos - start) // subtract CID length\n\n  return { cid, length, blockLength }\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<Block>}\n */\nasync function readBlock (reader) {\n  const { cid, blockLength } = await readBlockHead(reader)\n  const bytes = await reader.exactly(blockLength, true)\n  return { bytes, cid }\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<BlockIndex>}\n */\nasync function readBlockIndex (reader) {\n  const offset = reader.pos\n  const { cid, length, blockLength } = await readBlockHead(reader)\n  const index = { cid, length, blockLength, offset, blockOffset: reader.pos }\n  reader.seek(index.blockLength)\n  return index\n}\n\n/**\n * Creates a `CarDecoder` from a `BytesReader`. The `CarDecoder` is as async\n * interface that will consume the bytes from the `BytesReader` to yield a\n * `header()` and either `blocks()` or `blocksIndex()` data.\n *\n * @name decoder.createDecoder(reader)\n * @param {BytesReader} reader\n * @returns {CarDecoder}\n */\nexport function createDecoder (reader) {\n  const headerPromise = (async () => {\n    const header = await readHeader(reader)\n    if (header.version === 2) {\n      const v1length = reader.pos - header.dataOffset\n      reader = limitReader(reader, header.dataSize - v1length)\n    }\n    return header\n  })()\n\n  return {\n    header: () => headerPromise,\n\n    async * blocks () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader)\n      }\n    },\n\n    async * blocksIndex () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader)\n      }\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesReader}\n */\nexport function bytesReader (bytes) {\n  let pos = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      const out = bytes.subarray(pos, pos + Math.min(length, bytes.length - pos))\n      return out\n    },\n\n    async exactly (length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = bytes.subarray(pos, pos + length)\n      if (seek) {\n        pos += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * @ignore\n * reusable reader for streams and files, we just need a way to read an\n * additional chunk (of some undetermined size) and a way to close the\n * reader when finished\n * @param {() => Promise<Uint8Array|null>} readChunk\n * @returns {BytesReader}\n */\nexport function chunkReader (readChunk /*, closer */) {\n  let pos = 0\n  let have = 0\n  let offset = 0\n  let currentChunk = new Uint8Array(0)\n\n  const read = async (/** @type {number} */ length) => {\n    have = currentChunk.length - offset\n    const bufa = [currentChunk.subarray(offset)]\n    while (have < length) {\n      const chunk = await readChunk()\n      if (chunk == null) {\n        break\n      }\n      /* c8 ignore next 8 */\n      // undo this ignore ^ when we have a fd implementation that can seek()\n      if (have < 0) { // because of a seek()\n        /* c8 ignore next 4 */\n        // toohard to test the else\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have))\n        } // else discard\n      } else {\n        bufa.push(chunk)\n      }\n      have += chunk.length\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0))\n    let off = 0\n    for (const b of bufa) {\n      currentChunk.set(b, off)\n      off += b.length\n    }\n    offset = 0\n  }\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length))\n    },\n\n    async exactly (length, seek = false) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = currentChunk.subarray(offset, offset + length)\n      if (seek) {\n        pos += length\n        offset += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n      offset += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from an `AsyncIterable<Uint8Array>`, which allows for\n * consumption of CAR data from a streaming source.\n *\n * @name decoder.asyncIterableReader(asyncIterable)\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {BytesReader}\n */\nexport function asyncIterableReader (asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]()\n\n  async function readChunk () {\n    const next = await iterator.next()\n    if (next.done) {\n      return null\n    }\n    return next.value\n  }\n\n  return chunkReader(readChunk)\n}\n\n/**\n * Wraps a `BytesReader` in a limiting `BytesReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesReader} reader\n * @param {number} byteLimit\n * @returns {BytesReader}\n */\nexport function limitReader (reader, byteLimit) {\n  let bytesRead = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      let bytes = await reader.upTo(length)\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead)\n      }\n      return bytes\n    },\n\n    async exactly (length, seek = false) {\n      const bytes = await reader.exactly(length, seek)\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data')\n      }\n      if (seek) {\n        bytesRead += length\n      }\n      return bytes\n    },\n\n    seek (length) {\n      bytesRead += length\n      reader.seek(length)\n    },\n\n    get pos () {\n      return reader.pos\n    }\n  }\n}\n", "import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').RootsReader} RootsReader\n * @typedef {import('./coding').BytesReader} BytesReader\n */\n\n/**\n * @class\n * @implements {RootsReader}\n * @property {number} version The version number of the CAR referenced by this reader (should be `1`).\n */\nexport class CarIteratorBase {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {AsyncIterable<Block>|void} iterable\n   */\n  constructor (version, roots, iterable) {\n    this._version = version\n    this._roots = roots\n    this._iterable = iterable\n    this._decoded = false\n  }\n\n  get version () {\n    return this._version\n  }\n\n  /**\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._roots\n  }\n}\n\n/**\n * Provides an iterator over all of the `Block`s in a CAR. Implements a\n * `BlockIterator` interface, or `AsyncIterable<Block>`. Where a `Block` is\n * a `{ cid:CID, bytes:Uint8Array }` pair.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const block of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarBlockiterator.fromBytes} or\n * {@link CarBlockiterator.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarBlockIterator` also implements the `RootsReader` interface and provides\n * the {@link CarBlockiterator.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarBlockIterator } from '@ipld/car/iterator'`\n * (`const { CarBlockIterator } = require('@ipld/car/iterator')`). Or\n * `import { CarBlockIterator } from '@ipld/car'`\n * (`const { CarBlockIterator } = require('@ipld/car')`).\n *\n * @name CarBlockIterator\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<Block>}\n * @property {number} version The version number of the CAR referenced by this\n * iterator (should be `1`).\n */\nexport class CarBlockIterator extends CarIteratorBase {\n  // inherited method\n  /**\n   * Get the list of roots defined by the CAR referenced by this iterator. May be\n   * zero or more `CID`s.\n   *\n   * @function getRoots\n   * @memberof CarBlockIterator\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n\n  /**\n   * @returns {AsyncIterator<Block>}\n   */\n  [Symbol.asyncIterator] () {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once')\n    }\n    /* c8 ignore next 3 */\n    if (!this._iterable) {\n      throw new Error('Block iterable not found')\n    }\n    this._decoded = true\n    return this._iterable[Symbol.asyncIterator]()\n  }\n\n  /**\n   * Instantiate a {@link CarBlockIterator} from a `Uint8Array` blob. Rather\n   * than decoding the entire byte array prior to returning the iterator, as in\n   * {@link CarReader.fromBytes}, only the header is decoded and the remainder\n   * of the CAR is parsed as the `Block`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarBlockIterator\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarBlockIterator>}\n   */\n  static async fromBytes (bytes) {\n    const { version, roots, iterator } = await fromBytes(bytes)\n    return new CarBlockIterator(version, roots, iterator)\n  }\n\n  /**\n   * Instantiate a {@link CarBlockIterator} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * Rather than decoding the entire byte array prior to returning the iterator,\n   * as in {@link CarReader.fromIterable}, only the header is decoded and the\n   * remainder of the CAR is parsed as the `Block`s as yielded.\n   *\n   * @async\n   * @static\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarBlockIterator>}\n   */\n  static async fromIterable (asyncIterable) {\n    const { version, roots, iterator } = await fromIterable(asyncIterable)\n    return new CarBlockIterator(version, roots, iterator)\n  }\n}\n\n/**\n * Provides an iterator over all of the `CID`s in a CAR. Implements a\n * `CIDIterator` interface, or `AsyncIterable<CID>`. Similar to\n * {@link CarBlockIterator} but only yields the CIDs in the CAR.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const cid of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarCIDiterator.fromBytes} or\n * {@link CarCIDiterator.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarCIDIterator` also implements the `RootsReader` interface and provides\n * the {@link CarCIDiterator.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarCIDIterator } from '@ipld/car/iterator'`\n * (`const { CarCIDIterator } = require('@ipld/car/iterator')`). Or\n * `import { CarCIDIterator } from '@ipld/car'`\n * (`const { CarCIDIterator } = require('@ipld/car')`).\n *\n * @name CarCIDIterator\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<CID>}\n * @property {number} version The version number of the CAR referenced by this\n * iterator (should be `1`).\n */\nexport class CarCIDIterator extends CarIteratorBase {\n  // inherited method\n  /**\n   * Get the list of roots defined by the CAR referenced by this iterator. May be\n   * zero or more `CID`s.\n   *\n   * @function getRoots\n   * @memberof CarCIDIterator\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n\n  /**\n   * @returns {AsyncIterator<CID>}\n   */\n  [Symbol.asyncIterator] () {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once')\n    }\n    /* c8 ignore next 3 */\n    if (!this._iterable) {\n      throw new Error('Block iterable not found')\n    }\n    this._decoded = true\n    const iterable = this._iterable[Symbol.asyncIterator]()\n    return {\n      async next () {\n        const next = await iterable.next()\n        if (next.done) {\n          return next\n        }\n        return { done: false, value: next.value.cid }\n      }\n    }\n  }\n\n  /**\n   * Instantiate a {@link CarCIDIterator} from a `Uint8Array` blob. Rather\n   * than decoding the entire byte array prior to returning the iterator, as in\n   * {@link CarReader.fromBytes}, only the header is decoded and the remainder\n   * of the CAR is parsed as the `CID`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarCIDIterator\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarCIDIterator>}\n   */\n  static async fromBytes (bytes) {\n    const { version, roots, iterator } = await fromBytes(bytes)\n    return new CarCIDIterator(version, roots, iterator)\n  }\n\n  /**\n   * Instantiate a {@link CarCIDIterator} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * Rather than decoding the entire byte array prior to returning the iterator,\n   * as in {@link CarReader.fromIterable}, only the header is decoded and the\n   * remainder of the CAR is parsed as the `CID`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarCIDIterator\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarCIDIterator>}\n   */\n  static async fromIterable (asyncIterable) {\n    const { version, roots, iterator } = await fromIterable(asyncIterable)\n    return new CarCIDIterator(version, roots, iterator)\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function fromBytes (bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError('fromBytes() requires a Uint8Array')\n  }\n  return decodeIterator(bytesReader(bytes))\n}\n\n/**\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function fromIterable (asyncIterable) {\n  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n    throw new TypeError('fromIterable() requires an async iterable')\n  }\n  return decodeIterator(asyncIterableReader(asyncIterable))\n}\n\n/**\n * @private\n * @param {BytesReader} reader\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function decodeIterator (reader) {\n  const decoder = createDecoder(reader)\n  const { version, roots } = await decoder.header()\n  return { version, roots, iterator: decoder.blocks() }\n}\n", "import { encode as dagCborEncode } from '@ipld/dag-cbor'\nimport varint from 'varint'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./coding').CarEncoder} CarEncoder\n * @typedef {import('./coding').IteratorChannel_Writer<Uint8Array>} IteratorChannel_Writer\n */\n\nconst CAR_V1_VERSION = 1\n\n/**\n * Create a header from an array of roots.\n *\n * @param {CID[]} roots\n * @returns {Uint8Array}\n */\nexport function createHeader (roots) {\n  const headerBytes = dagCborEncode({ version: CAR_V1_VERSION, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n  const header = new Uint8Array(varintBytes.length + headerBytes.length)\n  header.set(varintBytes, 0)\n  header.set(headerBytes, varintBytes.length)\n  return header\n}\n\n/**\n * @param {IteratorChannel_Writer} writer\n * @returns {CarEncoder}\n */\nfunction createEncoder (writer) {\n  // none of this is wrapped in a mutex, that needs to happen above this to\n  // avoid overwrites\n\n  return {\n    /**\n     * @param {CID[]} roots\n     * @returns {Promise<void>}\n     */\n    async setRoots (roots) {\n      const bytes = createHeader(roots)\n      await writer.write(bytes)\n    },\n\n    /**\n     * @param {Block} block\n     * @returns {Promise<void>}\n     */\n    async writeBlock (block) {\n      const { cid, bytes } = block\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)))\n      await writer.write(cid.bytes)\n      if (bytes.length) {\n        // zero-length blocks are valid, but it'd be safer if we didn't write them\n        await writer.write(bytes)\n      }\n    },\n\n    /**\n     * @returns {Promise<void>}\n     */\n    async close () {\n      await writer.end()\n    },\n\n    /**\n     * @returns {number}\n     */\n    version () {\n      return CAR_V1_VERSION\n    }\n  }\n}\n\nexport { createEncoder }\n", "/**\n * @template {any} T\n * @typedef {import('./coding').IteratorChannel<T>} IteratorChannel\n */\n\nfunction noop () {}\n\n/**\n * @template {any} T\n * @returns {IteratorChannel<T>}\n */\nexport function create () {\n  /** @type {T[]} */\n  const chunkQueue = []\n  /** @type {Promise<void> | null} */\n  let drainer = null\n  let drainerResolver = noop\n  let ended = false\n  /** @type {Promise<IteratorResult<T>> | null} */\n  let outWait = null\n  let outWaitResolver = noop\n\n  const makeDrainer = () => {\n    if (!drainer) {\n      drainer = new Promise((resolve) => {\n        drainerResolver = () => {\n          drainer = null\n          drainerResolver = noop\n          resolve()\n        }\n      })\n    }\n    return drainer\n  }\n\n  /**\n   * @returns {IteratorChannel<T>}\n   */\n  const writer = {\n    /**\n     * @param {T} chunk\n     * @returns {Promise<void>}\n     */\n    write (chunk) {\n      chunkQueue.push(chunk)\n      const drainer = makeDrainer()\n      outWaitResolver()\n      return drainer\n    },\n\n    async end () {\n      ended = true\n      const drainer = makeDrainer()\n      outWaitResolver()\n      await drainer\n    }\n  }\n\n  /** @type {AsyncIterator<T>} */\n  const iterator = {\n    /** @returns {Promise<IteratorResult<T>>} */\n    async next () {\n      const chunk = chunkQueue.shift()\n      if (chunk) {\n        if (chunkQueue.length === 0) {\n          drainerResolver()\n        }\n        return { done: false, value: chunk }\n      }\n\n      if (ended) {\n        drainerResolver()\n        return { done: true, value: undefined }\n      }\n\n      if (!outWait) {\n        outWait = new Promise((resolve) => {\n          outWaitResolver = () => {\n            outWait = null\n            outWaitResolver = noop\n            return resolve(iterator.next())\n          }\n        })\n      }\n\n      return outWait\n    }\n  }\n\n  return { writer, iterator }\n}\n", "import { CID } from 'multiformats/cid'\nimport { bytesReader, readHeader } from './decoder.js'\nimport { createEncoder, createHeader } from './encoder.js'\nimport { create as iteratorChannel } from './iterator-channel.js'\n\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockWriter} BlockWriter\n * @typedef {import('./api').WriterChannel} WriterChannel\n * @typedef {import('./coding').CarEncoder} CarEncoder\n * @typedef {import('./coding').IteratorChannel<Uint8Array>} IteratorChannel\n */\n\n/**\n * Provides a writer interface for the creation of CAR files.\n *\n * Creation of a `CarWriter` involves the instatiation of an input / output pair\n * in the form of a `WriterChannel`, which is a\n * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair. These two\n * components form what can be thought of as a stream-like interface. The\n * `writer` component (an instantiated `CarWriter`), has methods to\n * {@link CarWriter.put `put()`} new blocks and {@link CarWriter.put `close()`}\n * the writing operation (finalising the CAR archive). The `out` component is\n * an `AsyncIterable` that yields the bytes of the archive. This can be\n * redirected to a file or other sink. In Node.js, you can use the\n * [`Readable.from()`](https://nodejs.org/api/stream.html#stream_stream_readable_from_iterable_options)\n * API to convert this to a standard Node.js stream, or it can be directly fed\n * to a\n * [`stream.pipeline()`](https://nodejs.org/api/stream.html#stream_stream_pipeline_source_transforms_destination_callback).\n *\n * The channel will provide a form of backpressure. The `Promise` from a\n * `write()` won't resolve until the resulting data is drained from the `out`\n * iterable.\n *\n * It is also possible to ignore the `Promise` from `write()` calls and allow\n * the generated data to queue in memory. This should be avoided for large CAR\n * archives of course due to the memory costs and potential for memory overflow.\n *\n * Load this class with either\n * `import { CarWriter } from '@ipld/car/writer'`\n * (`const { CarWriter } = require('@ipld/car/writer')`). Or\n * `import { CarWriter } from '@ipld/car'`\n * (`const { CarWriter } = require('@ipld/car')`). The former will likely\n * result in smaller bundle sizes where this is important.\n *\n * @name CarWriter\n * @class\n * @implements {BlockWriter}\n */\nexport class CarWriter {\n  /**\n   * @param {CID[]} roots\n   * @param {CarEncoder} encoder\n   */\n  constructor (roots, encoder) {\n    this._encoder = encoder\n    /** @type {Promise<void>} */\n    this._mutex = encoder.setRoots(roots)\n    this._ended = false\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {Promise<void>} The returned promise will only resolve once the\n   * bytes this block generates are written to the `out` iterable.\n   */\n  async put (block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects')\n    }\n    if (this._ended) {\n      throw new Error('Already closed')\n    }\n    const cid = CID.asCID(block.cid)\n    if (!cid) {\n      throw new TypeError('Can only write {cid, bytes} objects')\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid, bytes: block.bytes }))\n    return this._mutex\n  }\n\n  /**\n   * Finalise the CAR archive and signal that the `out` iterable should end once\n   * any remaining bytes are written.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this._ended) {\n      throw new Error('Already closed')\n    }\n    await this._mutex\n    this._ended = true\n    return this._encoder.close()\n  }\n\n  /**\n   * Returns the version number of the CAR file being written\n   *\n   * @returns {number}\n   */\n  version () {\n    return this._encoder.version()\n  }\n\n  /**\n   * Create a new CAR writer \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {CID[] | CID | void} roots\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static create (roots) {\n    roots = toRoots(roots)\n    const { encoder, iterator } = encodeWriter()\n    const writer = new CarWriter(roots, encoder)\n    const out = new CarWriterOut(iterator)\n    return { writer, out }\n  }\n\n  /**\n   * Create a new CAR appender \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   * This appender does not consider roots and does not produce a CAR header.\n   * It is designed to append blocks to an _existing_ CAR archive. It is\n   * expected that `out` will be concatenated onto the end of an existing\n   * archive that already has a properly formatted header.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static createAppender () {\n    const { encoder, iterator } = encodeWriter()\n    encoder.setRoots = () => Promise.resolve()\n    const writer = new CarWriter([], encoder)\n    const out = new CarWriterOut(iterator)\n    return { writer, out }\n  }\n\n  /**\n   * Update the list of roots in the header of an existing CAR as represented\n   * in a Uint8Array.\n   *\n   * This operation is an _overwrite_, the total length of the CAR will not be\n   * modified. A rejection will occur if the new header will not be the same\n   * length as the existing header, in which case the CAR will not be modified.\n   * It is the responsibility of the user to ensure that the roots being\n   * replaced encode as the same length as the new roots.\n   *\n   * The byte array passed in an argument will be modified and also returned\n   * upon successful modification.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {Uint8Array} bytes\n   * @param {CID[]} roots - A new list of roots to replace the existing list in\n   * the CAR header. The new header must take up the same number of bytes as the\n   * existing header, so the roots should collectively be the same byte length\n   * as the existing roots.\n   * @returns {Promise<Uint8Array>}\n   */\n  static async updateRootsInBytes (bytes, roots) {\n    const reader = bytesReader(bytes)\n    await readHeader(reader)\n    const newHeader = createHeader(roots)\n    if (Number(reader.pos) !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`)\n    }\n    bytes.set(newHeader, 0)\n    return bytes\n  }\n}\n\n/**\n * @class\n * @implements {AsyncIterable<Uint8Array>}\n */\nexport class CarWriterOut {\n  /**\n   * @param {AsyncIterator<Uint8Array>} iterator\n   */\n  constructor (iterator) {\n    this._iterator = iterator\n  }\n\n  [Symbol.asyncIterator] () {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported')\n    }\n    this._iterating = true\n    return this._iterator\n  }\n}\n\nfunction encodeWriter () {\n  /** @type {IteratorChannel} */\n  const iw = iteratorChannel()\n  const { writer, iterator } = iw\n  const encoder = createEncoder(writer)\n  return { encoder, iterator }\n}\n\n/**\n * @private\n * @param {CID[] | CID | void} roots\n * @returns {CID[]}\n */\nfunction toRoots (roots) {\n  if (roots === undefined) {\n    return []\n  }\n\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots)\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs')\n    }\n    return [cid]\n  }\n\n  const _roots = []\n  for (const root of roots) {\n    const _root = CID.asCID(root)\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs')\n    }\n    _roots.push(_root)\n  }\n  return _roots\n}\n\nexport const __browser = true\n", "/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n", "/**\n * Can be used with Array.sort to sort and array with Uint8Array entries\n */\nexport function compare (a: Uint8Array, b: Uint8Array): number {\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] < b[i]) {\n      return -1\n    }\n\n    if (a[i] > b[i]) {\n      return 1\n    }\n  }\n\n  if (a.byteLength > b.byteLength) {\n    return 1\n  }\n\n  if (a.byteLength < b.byteLength) {\n    return -1\n  }\n\n  return 0\n}\n", "import { allocUnsafe } from '#alloc'\nimport { asUint8Array } from '#util/as-uint8array'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat (arrays: Uint8Array[], length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n", "import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n", "import { from } from './base.js'\n\nconst alphabet = Array.from('\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42')\nconst alphabetBytesToChars: string[] = (alphabet.reduce<string[]>((p, c, i) => { p[i] = c; return p }, ([])))\nconst alphabetCharsToBytes: number[] = (alphabet.reduce<number[]>((p, c, i) => {\n  const codePoint = c.codePointAt(0)\n  if (codePoint == null) {\n    throw new Error(`Invalid character: ${c}`)\n  }\n  p[codePoint] = i\n  return p\n}, ([])))\n\nfunction encode (data: Uint8Array): string {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\nfunction decode (str: string): Uint8Array {\n  const byts = []\n  for (const char of str) {\n    const codePoint = char.codePointAt(0)\n    if (codePoint == null) {\n      throw new Error(`Invalid character: ${char}`)\n    }\n    const byt = alphabetCharsToBytes[codePoint]\n    if (byt == null) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '\uD83D\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n", "import { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n", "import type { ArrayBufferView, ByteView } from './interface.js'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\nexport function encode <T> (node: T): ByteView<T> {\n  return textEncoder.encode(JSON.stringify(node))\n}\n\nexport function decode <T> (data: ByteView<T> | ArrayBufferView<T>): T {\n  return JSON.parse(textDecoder.decode(data))\n}\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code: 0x0 = 0x0\nconst name = 'identity'\n\nconst encode: (input: Uint8Array) => Uint8Array = coerce\n\nfunction digest (input: Uint8Array): Digest.Digest<typeof code, number> {\n  return Digest.create(code, encode(input))\n}\n\nexport const identity = { code, name, encode, digest }\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\nfunction sha (name: AlgorithmIdentifier): (data: Uint8Array) => Promise<Uint8Array> {\n  return async data => new Uint8Array(await crypto.subtle.digest(name, data))\n}\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nexport const hashes = { ...sha2, ...identity }\nexport const codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes }\n", "import { bases } from 'multiformats/basics'\nimport type { MultibaseCodec } from 'multiformats'\nimport { allocUnsafe } from '#alloc'\n\nfunction createCodec (name: string, prefix: string, encode: (buf: Uint8Array) => string, decode: (str: string) => Uint8Array): MultibaseCodec<any> {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: {\n      decode\n    }\n  }\n}\n\nconst string = createCodec('utf8', 'u', (buf) => {\n  const decoder = new TextDecoder('utf8')\n  return 'u' + decoder.decode(buf)\n}, (str) => {\n  const encoder = new TextEncoder()\n  return encoder.encode(str.substring(1))\n})\n\nconst ascii = createCodec('ascii', 'a', (buf) => {\n  let string = 'a'\n\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i])\n  }\n  return string\n}, (str) => {\n  str = str.substring(1)\n  const buf = allocUnsafe(str.length)\n\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i)\n  }\n\n  return buf\n})\n\nexport type SupportedEncodings = 'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof typeof bases\n\nconst BASES: Record<SupportedEncodings, MultibaseCodec<any>> = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii,\n  binary: ascii,\n\n  ...bases\n}\n\nexport default BASES\n", "import * as API from './api.js'\nimport { base58btc } from 'multiformats/bases/base58'\n\n/** @type {WeakMap<Uint8Array, string>} */\nconst cache = new WeakMap()\n\n/** @param {API.MultihashDigest} digest */\nconst toBase58String = (digest) => {\n  let str = cache.get(digest.bytes)\n  if (!str) {\n    str = base58btc.encode(digest.bytes)\n    cache.set(digest.bytes, str)\n  }\n  return str\n}\n\n/**\n * @template {API.MultihashDigest} Key\n * @template Value\n * @implements {Map<Key, Value>}\n */\nexport class DigestMap {\n  /** @type {Map<string, [Key, Value]>} */\n  #data\n\n  /**\n   * @param {Array<[Key, Value]>} [entries]\n   */\n  constructor(entries) {\n    this.#data = new Map()\n    for (const [k, v] of entries ?? []) {\n      this.set(k, v)\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'DigestMap'\n  }\n\n  clear() {\n    this.#data.clear()\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {boolean}\n   */\n  delete(key) {\n    const mhstr = toBase58String(key)\n    return this.#data.delete(mhstr)\n  }\n\n  /**\n   * @param {(value: Value, key: Key, map: Map<Key, Value>) => void} callbackfn\n   * @param {any} [thisArg]\n   */\n  forEach(callbackfn, thisArg) {\n    for (const [k, v] of this.#data.values()) {\n      callbackfn.call(thisArg, v, k, this)\n    }\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {Value|undefined}\n   */\n  get(key) {\n    const data = this.#data.get(toBase58String(key))\n    if (data) return data[1]\n  }\n\n  /**\n   * @param {Key} key\n   * @returns {boolean}\n   */\n  has(key) {\n    return this.#data.has(toBase58String(key))\n  }\n\n  /**\n   * @param {Key} key\n   * @param {Value} value\n   */\n  set(key, value) {\n    this.#data.set(toBase58String(key), [key, value])\n    return this\n  }\n\n  /** @returns {number} */\n  get size() {\n    return this.#data.size\n  }\n\n  /** @returns */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /** @returns {IterableIterator<[Key, Value]>} */\n  *entries() {\n    yield* this.#data.values()\n  }\n\n  /** @returns {IterableIterator<Key>} */\n  *keys() {\n    for (const [k] of this.#data.values()) {\n      yield k\n    }\n  }\n\n  /** @returns {IterableIterator<Value>} */\n  *values() {\n    for (const [, v] of this.#data.values()) {\n      yield v\n    }\n  }\n}\n", "import * as API from './api.js'\nimport { CAR, ok, error, Schema, Failure } from '@ucanto/core'\nimport { compare } from 'uint8arrays'\nimport * as dagCBOR from '@ipld/dag-cbor'\nimport * as Digest from 'multiformats/hashes/digest'\nimport * as Link from 'multiformats/link'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { DigestMap } from './digest-map.js'\n\nexport const version = 'index/sharded/dag@0.1'\n\nexport const ShardedDAGIndexSchema = Schema.variant({\n  [version]: Schema.struct({\n    /** DAG root. */\n    content: Schema.link(),\n    /** Shards the DAG can be found in. */\n    shards: Schema.array(Schema.link()),\n  }),\n})\n\nexport const MultihashSchema = Schema.bytes()\n\nexport const BlobIndexSchema = Schema.tuple([\n  MultihashSchema,\n  Schema.array(\n    /** multihash bytes, offset, length. */\n    Schema.tuple([\n      MultihashSchema,\n      Schema.tuple([Schema.number(), Schema.number()]),\n    ])\n  ),\n])\n\n/**\n * @param {Uint8Array} archive\n * @returns {API.Result<API.ShardedDAGIndexView, API.DecodeFailure|API.UnknownFormat>}\n */\nexport const extract = (archive) => {\n  const { roots, blocks } = CAR.decode(archive)\n\n  if (!roots.length) {\n    return error(new UnknownFormat('missing root block'))\n  }\n\n  const { code } = roots[0].cid\n  if (code !== dagCBOR.code) {\n    return error(\n      new UnknownFormat(`unexpected root CID codec: 0x${code.toString(16)}`)\n    )\n  }\n\n  return view({ root: roots[0], blocks })\n}\n\n/**\n * @param {object} source\n * @param {API.IPLDBlock} source.root\n * @param {Map<string, API.IPLDBlock>} source.blocks\n * @returns {API.Result<API.ShardedDAGIndexView, API.DecodeFailure|API.UnknownFormat>}\n */\nexport const view = ({ root, blocks }) => {\n  const [version, dagIndexData] = ShardedDAGIndexSchema.match(\n    dagCBOR.decode(root.bytes)\n  )\n  switch (version) {\n    case version: {\n      const dagIndex = create(dagIndexData.content)\n      for (const shardLink of dagIndexData.shards) {\n        const shard = blocks.get(shardLink.toString())\n        if (!shard) {\n          return error(new DecodeFailure(`missing shard block: ${shardLink}`))\n        }\n\n        const blobIndexData = BlobIndexSchema.from(dagCBOR.decode(shard.bytes))\n        const blobIndex = new DigestMap()\n        for (const [digest, [offset, length]] of blobIndexData[1]) {\n          blobIndex.set(Digest.decode(digest), [offset, length])\n        }\n        dagIndex.shards.set(Digest.decode(blobIndexData[0]), blobIndex)\n      }\n      return ok(dagIndex)\n    }\n    default:\n      return error(new UnknownFormat(`unknown index version: ${version}`))\n  }\n}\n\n/** @implements {API.ShardedDAGIndexView} */\nclass ShardedDAGIndex {\n  #content\n  #shards\n\n  /** @param {API.UnknownLink} content */\n  constructor(content) {\n    this.#content = content\n    /** @type {DigestMap<API.ShardDigest, API.Position>} */\n    this.#shards = new DigestMap()\n  }\n\n  get content() {\n    return this.#content\n  }\n\n  get shards() {\n    return this.#shards\n  }\n\n  /**\n   * @param {API.ShardDigest} shard\n   * @param {API.SliceDigest} slice\n   * @param {API.Position} pos\n   */\n  setSlice(shard, slice, pos) {\n    let index = this.#shards.get(shard)\n    if (!index) {\n      index = new DigestMap()\n      this.#shards.set(shard, index)\n    }\n    index.set(slice, pos)\n  }\n\n  archive() {\n    return archive(this)\n  }\n}\n\nexport class UnknownFormat extends Failure {\n  #reason\n\n  /** @param {string} [reason] */\n  constructor(reason) {\n    super()\n    this.name = /** @type {const} */ ('UnknownFormat')\n    this.#reason = reason\n  }\n\n  describe() {\n    return this.#reason ?? 'unknown format'\n  }\n}\n\nexport class DecodeFailure extends Failure {\n  #reason\n\n  /** @param {string} [reason] */\n  constructor(reason) {\n    super()\n    this.name = /** @type {const} */ ('DecodeFailure')\n    this.#reason = reason\n  }\n\n  describe() {\n    return this.#reason ?? 'failed to decode'\n  }\n}\n\n/**\n * @param {API.UnknownLink} content\n * @returns {API.ShardedDAGIndexView}\n */\nexport const create = (content) => new ShardedDAGIndex(content)\n\n/**\n * @param {API.ShardedDAGIndex} model\n * @returns {Promise<API.Result<Uint8Array>>}\n */\nexport const archive = async (model) => {\n  const blocks = new Map()\n  const shards = [...model.shards.entries()].sort((a, b) =>\n    compare(a[0].digest, b[0].digest)\n  )\n  const index = {\n    content: model.content,\n    shards: /** @type {API.Link[]} */ ([]),\n  }\n  for (const s of shards) {\n    const slices = [...s[1].entries()]\n      .sort((a, b) => compare(a[0].digest, b[0].digest))\n      .map((e) => [e[0].bytes, e[1]])\n    const bytes = dagCBOR.encode([s[0].bytes, slices])\n    const digest = await sha256.digest(bytes)\n    const cid = Link.create(dagCBOR.code, digest)\n    blocks.set(cid.toString(), { cid, bytes })\n    index.shards.push(cid)\n  }\n  const bytes = dagCBOR.encode({ [version]: index })\n  const digest = await sha256.digest(bytes)\n  const cid = Link.create(dagCBOR.code, digest)\n  return ok(CAR.encode({ roots: [{ cid, bytes }], blocks }))\n}\n", "/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc'\nimport { concat } from 'uint8arrays/concat'\nimport { equals } from 'uint8arrays/equals'\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist')\n\nexport type Appendable = Uint8ArrayList | Uint8Array\n\nfunction findBufAndOffset (bufs: Uint8Array[], index: number): { buf: Uint8Array, index: number } {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds')\n  }\n\n  let offset = 0\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      }\n    }\n\n    offset = bufEnd\n  }\n\n  throw new RangeError('index is out of bounds')\n}\n\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList (value: any): value is Uint8ArrayList {\n  return Boolean(value?.[symbol])\n}\n\nexport class Uint8ArrayList implements Iterable<Uint8Array> {\n  private bufs: Uint8Array[]\n  public length: number\n  public readonly [symbol] = true\n\n  constructor (...data: Appendable[]) {\n    this.bufs = []\n    this.length = 0\n\n    if (data.length > 0) {\n      this.appendAll(data)\n    }\n  }\n\n  * [Symbol.iterator] (): Iterator<Uint8Array> {\n    yield * this.bufs\n  }\n\n  get byteLength (): number {\n    return this.length\n  }\n\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append (...bufs: Appendable[]): void {\n    this.appendAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.push(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.push(...buf.bufs)\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend (...bufs: Appendable[]): void {\n    this.prependAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.unshift(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.unshift(...buf.bufs)\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Read the value at `index`\n   */\n  get (index: number): number {\n    const res = findBufAndOffset(this.bufs, index)\n\n    return res.buf[res.index]\n  }\n\n  /**\n   * Set the value at `index` to `value`\n   */\n  set (index: number, value: number): void {\n    const res = findBufAndOffset(this.bufs, index)\n\n    res.buf[res.index] = value\n  }\n\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write (buf: Appendable, offset: number = 0): void {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i])\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i))\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList')\n    }\n  }\n\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume (bytes: number): void {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes)\n\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return\n    }\n\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = []\n      this.length = 0\n      return\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength\n        this.length -= this.bufs[0].byteLength\n        this.bufs.shift()\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes)\n        this.length -= bytes\n        break\n      }\n    }\n  }\n\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    if (bufs.length === 1) {\n      return bufs[0]\n    }\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist (beginInclusive?: number, endExclusive?: number): Uint8ArrayList {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    const list = new Uint8ArrayList()\n    list.length = length\n    // don't loop, just set the bufs\n    list.bufs = [...bufs]\n\n    return list\n  }\n\n  private _subList (beginInclusive?: number, endExclusive?: number): { bufs: Uint8Array[], length: number } {\n    beginInclusive = beginInclusive ?? 0\n    endExclusive = endExclusive ?? this.length\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds')\n    }\n\n    if (beginInclusive === endExclusive) {\n      return { bufs: [], length: 0 }\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return { bufs: this.bufs, length: this.length }\n    }\n\n    const bufs: Uint8Array[] = []\n    let offset = 0\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i]\n      const bufStart = offset\n      const bufEnd = bufStart + buf.byteLength\n\n      // for next loop\n      offset = bufEnd\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        const start = beginInclusive - bufStart\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)))\n        break\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf)\n          continue\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart))\n        continue\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart))\n        break\n      }\n\n      // slice started before this buffer and ends after it\n      bufs.push(buf)\n    }\n\n    return { bufs, length: endExclusive - beginInclusive }\n  }\n\n  indexOf (search: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array')\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray()\n\n    offset = Number(offset ?? 0)\n\n    if (isNaN(offset)) {\n      offset = 0\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset\n    }\n\n    if (offset < 0) {\n      offset = 0\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset\n    }\n\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M: number = needle.byteLength\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long')\n    }\n\n    // radix\n    const radix: number = 256\n    const rightmostPositions: Int32Array = new Int32Array(radix)\n\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c: number = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j\n    }\n\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions\n    const lastIndex = this.byteLength - needle.byteLength\n    const lastPatIndex = needle.byteLength - 1\n    let skip: number\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char: number = this.get(i + j)\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char])\n          break\n        }\n      }\n\n      if (skip === 0) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getInt8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt8(0)\n  }\n\n  setInt8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt16(0, littleEndian)\n  }\n\n  setInt16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt32(0, littleEndian)\n  }\n\n  setInt32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigInt64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigInt64(0, littleEndian)\n  }\n\n  setBigInt64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigInt64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint8(0)\n  }\n\n  setUint8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint16(0, littleEndian)\n  }\n\n  setUint16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint32(0, littleEndian)\n  }\n\n  setUint32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigUint64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigUint64(0, littleEndian)\n  }\n\n  setBigUint64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigUint64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat32(0, littleEndian)\n  }\n\n  setFloat32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat64 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat64(0, littleEndian)\n  }\n\n  setFloat64 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  equals (other: any): other is Uint8ArrayList {\n    if (other == null) {\n      return false\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays (bufs: Uint8Array[], length?: number): Uint8ArrayList {\n    const list = new Uint8ArrayList()\n    list.bufs = bufs\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0)\n    }\n\n    list.length = length\n\n    return list\n  }\n}\n\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n", "const MSB = 0x80\nconst REST = 0x7F\nconst MSBALL = ~REST\nconst INT = Math.pow(2, 31)\n\n/**\n * @param {number} num\n */\nexport const encode = num => {\n  /** @type {number[]} */\n  const out = []\n  let offset = 0\n\n  while (num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while (num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n\n  return out\n}\n\n/**\n * @param {import('uint8arraylist').Uint8ArrayList} buf\n * @param {number} [offset]\n */\nexport const decode = (buf, offset) => {\n  let res = 0\n  offset = offset || 0\n  let shift = 0\n  let counter = offset\n  let b\n  const l = buf.length\n\n  do {\n    if (counter >= l || shift > 49) throw new RangeError('Could not decode varint')\n    b = buf.get(counter++)\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  return [res, counter - offset]\n}\n", "/* eslint-env browser */\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { decode as decodeDagCBOR } from '@ipld/dag-cbor'\nimport { decode as decodeDigest } from 'multiformats/hashes/digest'\nimport { create as createLink, createLegacy as createLegacyLink } from 'multiformats/link'\nimport { decode as decodeVarint } from './varint.js'\n\nconst State = {\n  ReadHeaderLength: 0,\n  ReadHeader: 1,\n  ReadBlockLength: 2,\n  ReadBlock: 3\n}\n\nconst CIDV0_BYTES = {\n  SHA2_256: 0x12,\n  LENGTH: 0x20,\n  DAG_PB: 0x70\n}\n\n/** @extends {TransformStream<Uint8Array, import('./api.js').Block & import('./api.js').Position>} */\nexport class CARReaderStream extends TransformStream {\n  /** @type {Promise<import('./api.js').CARHeader>} */\n  #headerPromise\n\n  /**\n   * @param {QueuingStrategy<Uint8Array>} [writableStrategy]\n   * An object that optionally defines a queuing strategy for the stream.\n   * @param {QueuingStrategy<import('./api.js').Block & import('./api.js').Position>} [readableStrategy]\n   * An object that optionally defines a queuing strategy for the stream.\n   * Defaults to a CountQueuingStrategy with highWaterMark of `1` to allow\n   * `getHeader` to be called before the stream is consumed.\n   */\n  constructor (writableStrategy, readableStrategy) {\n    const buffer = new Uint8ArrayList()\n    let offset = 0\n    let prevOffset = offset\n    let wanted = 8\n    let state = State.ReadHeaderLength\n\n    /** @type {(value: import('./api.js').CARHeader) => void} */\n    let resolveHeader\n    const headerPromise = new Promise(resolve => { resolveHeader = resolve })\n\n    super({\n      transform (chunk, controller) {\n        buffer.append(chunk)\n        while (true) {\n          if (buffer.length < wanted) break\n          if (state === State.ReadHeaderLength) {\n            const [length, bytes] = decodeVarint(buffer)\n            buffer.consume(bytes)\n            prevOffset = offset\n            offset += bytes\n            state = State.ReadHeader\n            wanted = length\n          } else if (state === State.ReadHeader) {\n            const header = decodeDagCBOR(buffer.slice(0, wanted))\n            resolveHeader && resolveHeader(header)\n            buffer.consume(wanted)\n            prevOffset = offset\n            offset += wanted\n            state = State.ReadBlockLength\n            wanted = 8\n          } else if (state === State.ReadBlockLength) {\n            const [length, bytes] = decodeVarint(buffer)\n            buffer.consume(bytes)\n            prevOffset = offset\n            offset += bytes\n            state = State.ReadBlock\n            wanted = length\n          } else if (state === State.ReadBlock) {\n            const _offset = prevOffset\n            const length = offset - prevOffset + wanted\n\n            prevOffset = offset\n            /** @type {import('multiformats').UnknownLink} */\n            let cid\n            if (buffer.get(0) === CIDV0_BYTES.SHA2_256 && buffer.get(1) === CIDV0_BYTES.LENGTH) {\n              const bytes = buffer.subarray(0, 34)\n              const multihash = decodeDigest(bytes)\n              // @ts-expect-error\n              cid = createLegacyLink(multihash)\n              buffer.consume(34)\n              offset += 34\n            } else {\n              const [version, versionBytes] = decodeVarint(buffer)\n              if (version !== 1) throw new Error(`unexpected CID version (${version})`)\n              buffer.consume(versionBytes)\n              offset += versionBytes\n\n              const [codec, codecBytes] = decodeVarint(buffer)\n              buffer.consume(codecBytes)\n              offset += codecBytes\n\n              const multihashBytes = getMultihashLength(buffer)\n              const multihash = decodeDigest(buffer.subarray(0, multihashBytes))\n              cid = createLink(codec, multihash)\n              buffer.consume(multihashBytes)\n              offset += multihashBytes\n            }\n\n            const blockBytes = wanted - (offset - prevOffset)\n            const bytes = buffer.subarray(0, blockBytes)\n            controller.enqueue({ cid, bytes, offset: _offset, length, blockOffset: offset, blockLength: blockBytes })\n\n            buffer.consume(blockBytes)\n            prevOffset = offset\n            offset += blockBytes\n            state = State.ReadBlockLength\n            wanted = 8\n          }\n        }\n      },\n      flush (controller) {\n        if (state !== State.ReadBlockLength) {\n          controller.error(new Error('unexpected end of data'))\n        }\n      }\n    }, writableStrategy, readableStrategy ?? new CountQueuingStrategy({ highWaterMark: 1 }))\n\n    this.#headerPromise = headerPromise\n  }\n\n  /**\n   * Get the decoded CAR header.\n   */\n  getHeader () {\n    return this.#headerPromise\n  }\n}\n\n/** @param {Uint8ArrayList} bytes */\nconst getMultihashLength = bytes => {\n  const [, codeBytes] = decodeVarint(bytes)\n  const [length, lengthBytes] = decodeVarint(bytes, codeBytes)\n  return codeBytes + lengthBytes + length\n}\n", "/* eslint-env browser */\nimport { encode as encodeCBOR } from '@ipld/dag-cbor'\nimport { encode as encodeVarint } from './varint.js'\n\n/**\n * @param {import('multiformats').UnknownLink[]} roots\n * @returns {Uint8Array}\n */\nconst encodeHeader = roots => {\n  const headerBytes = encodeCBOR({ version: 1, roots })\n  const varintBytes = encodeVarint(headerBytes.length)\n  const header = new Uint8Array(varintBytes.length + headerBytes.length)\n  header.set(varintBytes, 0)\n  header.set(headerBytes, varintBytes.length)\n  return header\n}\n\n/**\n * @param {import('./api.js').Block} block\n * @returns {Uint8Array}\n */\nconst encodeBlock = block => {\n  const varintBytes = encodeVarint(block.cid.bytes.length + block.bytes.length)\n  const bytes = new Uint8Array(varintBytes.length + block.cid.bytes.length + block.bytes.length)\n  bytes.set(varintBytes)\n  bytes.set(block.cid.bytes, varintBytes.length)\n  bytes.set(block.bytes, varintBytes.length + block.cid.bytes.length)\n  return bytes\n}\n\n/** @extends {TransformStream<import('./api.js').Block, Uint8Array>} */\nexport class CARWriterStream extends TransformStream {\n  /**\n   * @param {import('multiformats').UnknownLink[]} [roots]\n   * @param {QueuingStrategy<import('./api.js').Block>} [writableStrategy]\n   * @param {QueuingStrategy<Uint8Array>} [readableStrategy]\n   */\n  constructor (roots = [], writableStrategy, readableStrategy) {\n    super({\n      start: controller => controller.enqueue(encodeHeader(roots)),\n      transform: (block, controller) => controller.enqueue(encodeBlock(block))\n    }, writableStrategy, readableStrategy)\n  }\n}\n", "import { CARReaderStream } from 'carstream'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as API from './api.js'\nimport { create } from './sharded-dag-index.js'\n\n/**\n * Create a sharded DAG index by indexing blocks in the passed CAR shards.\n *\n * @param {API.UnknownLink} content\n * @param {Uint8Array[]} shards\n * @returns {Promise<API.ShardedDAGIndexView>}\n */\nexport const fromShardArchives = async (content, shards) => {\n  const index = create(content)\n  for (const s of shards) {\n    const digest = await sha256.digest(s)\n\n    await new ReadableStream({\n      pull: (c) => {\n        c.enqueue(s)\n        c.close()\n      },\n    })\n      .pipeThrough(new CARReaderStream())\n      .pipeTo(\n        new WritableStream({\n          write({ cid, blockOffset, blockLength }) {\n            index.setSlice(digest, cid.multihash, [blockOffset, blockLength])\n          },\n        })\n      )\n  }\n  return index\n}\n\n/**\n * Indexes a sharded DAG\n *\n * @param {import('multiformats').Link} root\n * @param {import('@web3-storage/capabilities/types').CARLink[]} shards\n * @param {Array<Map<API.SliceDigest, API.Position>>} shardIndexes\n */\nexport async function indexShardedDAG(root, shards, shardIndexes) {\n  const index = create(root)\n  for (const [i, shard] of shards.entries()) {\n    const slices = shardIndexes[i]\n    index.shards.set(shard.multihash, slices)\n  }\n  return await index.archive()\n}\n", null, null],
  "mappings": "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AAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,E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",
  "names": ["require_retry_operation", "__commonJSMin", "exports", "module", "RetryOperation", "timeouts", "options", "err", "currentTime", "timeout", "self", "fn", "timeoutOps", "counts", "mainError", "mainErrorCount", "i", "error", "message", "count", "require_retry", "__commonJSMin", "exports", "RetryOperation", "options", "timeouts", "opts", "key", "i", "a", "b", "attempt", "random", "timeout", "obj", "methods", "method", "original", "op", "args", "callback", "err", "require_retry", "__commonJSMin", "exports", "module", "require_longbits", "__commonJSMin", "exports", "module", "LongBits", "util", "lo", "hi", "zero", "zeroHash", "value", "sign", "unsigned", "charCodeAt", "hash", "mask", "part0", "part1", "part2", "require_minimal", "__commonJSMin", "exports", "util", "value", "obj", "prop", "Buffer", "sizeOrArray", "hash", "unsigned", "bits", "merge", "dst", "src", "ifNotSet", "keys", "i", "str", "newError", "name", "CustomError", "message", "properties", "fieldNames", "fieldMap", "encoding", "size", "require_writer", "__commonJSMin", "exports", "module", "Writer", "util", "BufferWriter", "LongBits", "base64", "utf8", "Op", "fn", "len", "val", "noop", "State", "writer", "create", "size", "writeByte", "buf", "pos", "writeVarint32", "VarintOp", "value", "writeVarint64", "bits", "writeFixed32", "writeBytes", "i", "head", "tail", "BufferWriter_", "require_writer_buffer", "__commonJSMin", "exports", "module", "BufferWriter", "Writer", "util", "val", "buf", "pos", "i", "value", "len", "writeStringBuffer", "require_reader", "__commonJSMin", "exports", "module", "Reader", "util", "BufferReader", "LongBits", "utf8", "indexOutOfRange", "reader", "writeLength", "buffer", "create_array", "create", "value", "readLongVarint", "bits", "i", "readFixed32_end", "buf", "end", "readFixed64", "length", "start", "nativeBuffer", "bytes", "wireType", "BufferReader_", "fn", "require_reader_buffer", "__commonJSMin", "exports", "module", "BufferReader", "Reader", "util", "buffer", "len", "require_service", "__commonJSMin", "exports", "module", "Service", "util", "rpcImpl", "requestDelimited", "responseDelimited", "rpcCall", "method", "requestCtor", "responseCtor", "request", "callback", "self", "err", "response", "endedByRPC", "require_rpc", "__commonJSMin", "exports", "rpc", "require_roots", "__commonJSMin", "exports", "module", "require_index_minimal", "__commonJSMin", "exports", "protobuf", "configure", "require_minimal", "__commonJSMin", "exports", "module", "require_murmurHash3js", "__commonJSMin", "exports", "module", "root", "undefined", "library", "_validBytes", "bytes", "i", "_x86Multiply", "m", "n", "_x86Rotl", "_x86Fmix", "h", "_x64Add", "o", "_x64Multiply", "_x64Rotl", "_x64LeftShift", "_x64Xor", "_x64Fmix", "seed", "remainder", "blocks", "h1", "k1", "c1", "c2", "h2", "h3", "h4", "k2", "k3", "k4", "c3", "c4", "require_murmurhash3js_revisited", "__commonJSMin", "exports", "module", "multihash_exports", "__export", "digest_exports", "MAX_HEIGHT", "MAX_PAYLOAD_SIZE", "code", "create", "digest", "name", "LEAFS_PER_QUAD", "IN_BITS_FR", "OUT_BITS_FR", "IN_BYTES_PER_QUAD", "OUT_BYTES_PER_QUAD", "PADDED_BYTES_PER_QUAD", "EXPANDED_BYTES_PER_QUAD", "BYTES_PER_FR", "FR_RATIO", "NODE_SIZE", "EXPANDED_BYTES_PER_NODE", "MIN_PAYLOAD_SIZE", "from", "bytes", "NODE_SIZE", "node", "empty", "EMPTY", "bytes_exports", "__export", "coerce", "empty", "equals", "fromHex", "fromString", "isBinary", "toHex", "toString", "d", "hex", "byte", "hexes", "b", "aa", "bb", "ii", "o", "str", "sha256_exports", "__export", "code", "digest", "name", "size", "sha256", "name", "size", "prefix", "Digest", "bytes", "name", "digest", "payload", "prefix", "sha256", "Digest", "code", "typeofs", "objectTypeNames", "is", "value", "typeOf", "isBuffer", "objectType", "getObjectType", "objectTypeName", "Type", "major", "name", "terminal", "typ", "Token", "type", "value", "encodedLength", "useBuffer", "textDecoder", "textEncoder", "isBuffer", "buf", "asU8A", "toString", "bytes", "start", "end", "utf8Slice", "fromString", "string", "utf8ToBytes", "fromArray", "arr", "slice", "concat", "chunks", "length", "c", "out", "off", "b", "alloc", "size", "compare", "b1", "b2", "isBuffer", "i", "utf8ToBytes", "str", "out", "p", "c", "utf8Slice", "buf", "offset", "end", "res", "firstByte", "codePoint", "bytesPerSequence", "secondByte", "thirdByte", "fourthByte", "tempCodePoint", "decodeCodePointsArray", "MAX_ARGUMENTS_LENGTH", "codePoints", "len", "defaultChunkSize", "Bl", "chunkSize", "bytes", "topChunk", "chunkPos", "alloc", "reset", "byts", "chunk", "slice", "concat", "decodeErrPrefix", "encodeErrPrefix", "uintMinorPrefixBytes", "assertEnoughData", "data", "pos", "need", "uintBoundaries", "readUint8", "data", "offset", "options", "assertEnoughData", "value", "decodeErrPrefix", "readUint16", "readUint32", "readUint64", "hi", "lo", "decodeUint8", "pos", "_minor", "Token", "Type", "decodeUint16", "decodeUint32", "decodeUint64", "encodeUint", "buf", "token", "encodeUintValue", "major", "uint", "nuint", "buint", "set", "tok1", "tok2", "decodeNegint8", "data", "pos", "_minor", "options", "Token", "Type", "readUint8", "decodeNegint16", "readUint16", "decodeNegint32", "readUint32", "neg1b", "pos1b", "decodeNegint64", "int", "readUint64", "value", "decodeErrPrefix", "encodeNegint", "buf", "token", "negint", "unsigned", "encodeUintValue", "uintBoundaries", "tok1", "tok2", "toToken", "data", "pos", "prefix", "length", "assertEnoughData", "buf", "slice", "Token", "Type", "decodeBytesCompact", "minor", "_options", "decodeBytes8", "_minor", "options", "readUint8", "decodeBytes16", "readUint16", "decodeBytes32", "readUint32", "decodeBytes64", "l", "readUint64", "decodeErrPrefix", "tokenBytes", "token", "fromString", "encodeBytes", "bytes", "encodeUintValue", "tok1", "tok2", "compareBytes", "b1", "b2", "compare", "toToken", "data", "pos", "prefix", "length", "options", "totLength", "assertEnoughData", "tok", "Token", "Type", "toString", "slice", "decodeStringCompact", "minor", "decodeString8", "_minor", "readUint8", "decodeString16", "readUint16", "decodeString32", "readUint32", "decodeString64", "l", "readUint64", "decodeErrPrefix", "encodeString", "encodeBytes", "toToken", "_data", "_pos", "prefix", "length", "Token", "Type", "decodeArrayCompact", "data", "pos", "minor", "_options", "decodeArray8", "_minor", "options", "readUint8", "decodeArray16", "readUint16", "decodeArray32", "readUint32", "decodeArray64", "l", "readUint64", "decodeErrPrefix", "decodeArrayIndefinite", "encodeArray", "buf", "token", "encodeUintValue", "encodeUint", "toToken", "_data", "_pos", "prefix", "length", "Token", "Type", "decodeMapCompact", "data", "pos", "minor", "_options", "decodeMap8", "_minor", "options", "readUint8", "decodeMap16", "readUint16", "decodeMap32", "readUint32", "decodeMap64", "l", "readUint64", "decodeErrPrefix", "decodeMapIndefinite", "encodeMap", "buf", "token", "encodeUintValue", "encodeUint", "decodeTagCompact", "_data", "_pos", "minor", "_options", "Token", "Type", "decodeTag8", "data", "pos", "_minor", "options", "readUint8", "decodeTag16", "readUint16", "decodeTag32", "readUint32", "decodeTag64", "readUint64", "encodeTag", "buf", "token", "encodeUintValue", "encodeUint", "MINOR_FALSE", "MINOR_TRUE", "MINOR_NULL", "MINOR_UNDEFINED", "decodeUndefined", "_data", "_pos", "_minor", "options", "decodeErrPrefix", "Token", "Type", "decodeBreak", "createToken", "value", "bytes", "decodeFloat16", "data", "pos", "readFloat16", "decodeFloat32", "readFloat32", "decodeFloat64", "readFloat64", "encodeFloat", "buf", "token", "float", "decoded", "success", "encodeFloat16", "ui8a", "encodeFloat32", "encodeFloat64", "buffer", "dataView", "inp", "valu32", "exponent", "mantissa", "logicalExponent", "half", "exp", "mant", "val", "offset", "encodeUint", "invalidMinor", "data", "pos", "minor", "decodeErrPrefix", "errorer", "msg", "jump", "i", "decodeUint8", "decodeUint16", "decodeUint32", "decodeUint64", "decodeNegint8", "decodeNegint16", "decodeNegint32", "decodeNegint64", "decodeBytesCompact", "decodeBytes8", "decodeBytes16", "decodeBytes32", "decodeBytes64", "decodeStringCompact", "decodeString8", "decodeString16", "decodeString32", "decodeString64", "decodeArrayCompact", "decodeArray8", "decodeArray16", "decodeArray32", "decodeArray64", "decodeArrayIndefinite", "decodeMapCompact", "decodeMap8", "decodeMap16", "decodeMap32", "decodeMap64", "decodeMapIndefinite", "decodeTagCompact", "decodeTag8", "decodeTag16", "decodeTag32", "decodeTag64", "decodeUndefined", "decodeFloat16", "decodeFloat32", "decodeFloat64", "decodeBreak", "quick", "Token", "Type", "quickEncodeToken", "token", "fromArray", "defaultEncodeOptions", "mapSorter", "quickEncodeToken", "makeCborEncoders", "encoders", "Type", "encodeUint", "encodeNegint", "encodeBytes", "encodeString", "encodeArray", "encodeMap", "encodeTag", "encodeFloat", "cborEncoders", "buf", "Bl", "Ref", "_Ref", "obj", "parent", "p", "stack", "encodeErrPrefix", "simpleTokens", "Token", "typeEncoders", "_typ", "_options", "_refStack", "_obj", "options", "refStack", "entries", "i", "e", "objectToTokens", "typ", "isMap", "keys", "length", "key", "sortMapEntries", "is", "customTypeEncoder", "tokens", "typeEncoder", "e1", "e2", "keyToken1", "keyToken2", "major", "tcmp", "tokensToEncoded", "token", "encodeCustom", "data", "quickBytes", "encoder", "size", "asU8A", "encode", "defaultDecodeOptions", "Tokeniser", "data", "options", "byt", "token", "quick", "decoder", "jump", "decodeErrPrefix", "minor", "DONE", "BREAK", "tokenToArray", "tokeniser", "arr", "i", "value", "tokensToObject", "tokenToMap", "useMaps", "obj", "m", "key", "Type", "tagged", "decodeFirst", "decoded", "decode", "remainder", "base32_exports", "__export", "base32", "base32hex", "base32hexpad", "base32hexpadupper", "base32hexupper", "base32pad", "base32padupper", "base32upper", "base32z", "base", "ALPHABET", "name", "BASE_MAP", "j", "i", "x", "xc", "BASE", "LEADER", "FACTOR", "iFACTOR", "encode", "source", "zeroes", "length", "pbegin", "pend", "size", "b58", "carry", "it1", "it2", "str", "decodeUnsafe", "psz", "b256", "it3", "it4", "vch", "decode", "string", "buffer", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "Encoder", "name", "prefix", "baseEncode", "__publicField", "bytes", "Decoder", "baseDecode", "prefixCodePoint", "text", "decoder", "or", "ComposedDecoder", "decoders", "input", "left", "right", "Codec", "from", "encode", "decode", "baseX", "alphabet", "base_x_default", "coerce", "string", "bitsPerChar", "codes", "i", "end", "out", "bits", "buffer", "written", "value", "data", "pad", "mask", "rfc4648", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "base36_exports", "__export", "base36", "base36upper", "base36", "baseX", "base36upper", "base58_exports", "__export", "base58btc", "base58flickr", "base58btc", "baseX", "base58flickr", "varint_exports", "__export", "decode", "encodeTo", "encodingLength", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "num", "out", "offset", "oldOffset", "decode", "read", "MSB$1", "REST$1", "buf", "res", "shift", "counter", "b", "l", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "value", "varint", "_brrp_varint", "varint_default", "decode", "data", "offset", "varint_default", "encodeTo", "int", "target", "encodingLength", "create", "code", "digest", "size", "sizeOffset", "encodingLength", "digestOffset", "bytes", "encodeTo", "Digest", "decode", "multihash", "coerce", "equals", "a", "b", "data", "__publicField", "format", "link", "base", "bytes", "version", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "cid", "_a", "CID", "_CID", "version", "code", "multihash", "bytes", "__publicField", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "other", "self", "unknown", "equals", "base", "format", "input", "value", "encodeCID", "cidSymbol", "decode", "remainder", "specs", "prefixSize", "multihashBytes", "coerce", "digestBytes", "Digest", "initialBytes", "offset", "next", "i", "length", "codec", "multihashCode", "digestSize", "size", "multihashSize", "source", "prefix", "parseCIDtoBytes", "decoder", "base58btc", "base32", "base36", "toStringV0", "toStringV1", "codeOffset", "encodingLength", "hashOffset", "encodeTo", "CID_CBOR_TAG", "toByteView", "buf", "cidEncoder", "obj", "cid", "CID", "bytes", "Token", "Type", "undefinedEncoder", "numberEncoder", "num", "_encodeOptions", "encodeOptions", "cidDecoder", "_decodeOptions", "decodeOptions", "name", "code", "encode", "node", "decode", "data", "DAG_PB_CODE", "createLegacy", "digest", "CID", "DAG_PB_CODE", "create", "code", "truncatedHash", "payload", "options", "hasher", "sha256_exports", "digest", "truncate", "computeNode", "left", "right", "node", "NODE_SIZE", "MAX_LEVEL", "ZeroComm", "NODE_SIZE", "empty", "start", "end", "computeNode", "ZERO_COMM", "fromLevel", "level", "MAX_LEAF_COUNT", "split", "source", "count", "NODE_SIZE", "chunks", "offset", "chunk", "toZeroPaddedSize", "payloadSize", "size", "MIN_PAYLOAD_SIZE", "highestBit", "bound", "FR_RATIO", "toPieceSize", "pad", "source", "output", "toPieceSize", "quadCount", "toZeroPaddedSize", "IN_BYTES_PER_QUAD", "n", "readOffset", "writeOffset", "OUT_BYTES_PER_QUAD", "i", "log2Floor", "n", "result", "log2Ceil", "fromHeight", "height", "PADDED_BYTES_PER_QUAD", "unpadded_exports", "__export", "fromPiece", "toExpanded", "toHeight", "toPadded", "toPadding", "toWidth", "fromPiece", "height", "padding", "fromHeight", "toPadding", "size", "toPadded", "toQauds", "PADDED_BYTES_PER_QUAD", "toExpanded", "EXPANDED_BYTES_PER_QUAD", "toWidth", "LEAFS_PER_QUAD", "toHeight", "log2Ceil", "quadCount", "fromHeight", "height", "fromWidth", "fromWidth", "width", "EXPANDED_BYTES_PER_NODE", "digest_exports", "__export", "HEIGHT_SIZE", "MAX_DIGEST_SIZE", "MAX_HEIGHT", "MAX_PAYLOAD_SIZE", "MAX_SIZE", "ROOT_SIZE", "TAG_SIZE", "code", "fromBytes", "fromPiece", "height", "name", "padding", "root", "toBytes", "from", "name", "code", "encode", "Hasher", "__publicField", "input", "result", "create", "digest", "name", "code", "MAX_PADDING_SIZE", "HEIGHT_SIZE", "ROOT_SIZE", "sha256_exports", "MAX_DIGEST_SIZE", "TAG_SIZE", "varint_exports", "MAX_SIZE", "MAX_HEIGHT", "MAX_PAYLOAD_SIZE", "fromHeight", "IN_BITS_FR", "OUT_BITS_FR", "fromPiece", "padding", "height", "root", "paddingLength", "size", "sizeLength", "multihashLength", "offset", "bytes", "Digest", "fromBytes", "toBytes", "digest", "prefixByteLength", "tag", "length", "name", "code", "MAX_HEIGHT", "MAX_PAYLOAD_SIZE", "fromHeight", "IN_BITS_FR", "OUT_BITS_FR", "digest", "payload", "hasher", "Hasher", "create", "IN_BYTES_PER_QUAD", "bytes", "MAX_SIZE", "count", "fromBytes", "output", "byteOffset", "asMultihash", "buffer", "layers", "offset", "bytesWritten", "leaves", "nodes", "split", "pad", "tree", "build", "height", "root", "padding", "unpadded_exports", "paddingLength", "varint_exports", "endOffset", "TAG_SIZE", "size", "HEIGHT_SIZE", "ROOT_SIZE", "sizeLength", "length", "bytesRequired", "readOffset", "quad", "prune", "flush", "level", "next", "layer", "fromLevel", "index", "node", "computeNode", "storefront_exports", "__export", "connection", "filecoinAccept", "filecoinInfo", "filecoinOffer", "filecoinSubmit", "delegation_exports", "__export", "ArchiveSchema", "Delegation", "allows", "archive", "create", "delegate", "exportDAG", "extract", "importDAG", "isDelegation", "isLink", "view", "encoder", "decoder", "encode", "text", "decode", "bytes", "varint_exports", "__export", "decode", "encodeTo", "encodingLength", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "num", "out", "offset", "oldOffset", "decode", "read", "MSB$1", "REST$1", "buf", "res", "shift", "counter", "b", "l", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "value", "varint", "_brrp_varint", "varint_default", "decode", "data", "offset", "varint_default", "encodeTo", "int", "target", "encodingLength", "empty", "equals", "aa", "bb", "ii", "coerce", "o", "create", "code", "digest", "size", "sizeOffset", "encodingLength", "digestOffset", "bytes", "encodeTo", "Digest", "decode", "multihash", "coerce", "equals", "a", "b", "data", "base", "ALPHABET", "name", "BASE_MAP", "j", "i", "x", "xc", "BASE", "LEADER", "FACTOR", "iFACTOR", "encode", "source", "zeroes", "length", "pbegin", "pend", "size", "b58", "carry", "it1", "it2", "str", "decodeUnsafe", "psz", "b256", "it3", "it4", "vch", "decode", "string", "buffer", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "Encoder", "name", "prefix", "baseEncode", "bytes", "Decoder", "baseDecode", "text", "decoder", "or", "ComposedDecoder", "decoders", "input", "left", "right", "Codec", "from", "encode", "decode", "baseX", "alphabet", "base_x_default", "coerce", "string", "bitsPerChar", "codes", "i", "end", "out", "bits", "buffer", "written", "value", "data", "pad", "mask", "rfc4648", "base58btc", "baseX", "base58flickr", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "format", "link", "base", "bytes", "version", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "cid", "CID", "_CID", "version", "code", "multihash", "bytes", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "other", "self", "unknown", "equals", "base", "format", "input", "value", "encodeCID", "cidSymbol", "decode", "remainder", "specs", "prefixSize", "multihashBytes", "coerce", "digestBytes", "Digest", "initialBytes", "offset", "next", "i", "length", "codec", "multihashCode", "digestSize", "size", "multihashSize", "source", "prefix", "parseCIDtoBytes", "decoder", "base58btc", "base32", "toStringV0", "toStringV1", "codeOffset", "encodingLength", "hashOffset", "encodeTo", "DAG_PB_CODE", "createLegacy", "digest", "CID", "DAG_PB_CODE", "create", "code", "isLink", "value", "withSlash", "parse", "source", "base", "code", "name", "encode", "coerce", "digest", "input", "create", "identity", "from", "name", "code", "encode", "Hasher", "input", "result", "create", "digest", "DID_PREFIX", "DID_PREFIX_SIZE", "DID_KEY_PREFIX", "DID_KEY_PREFIX_SIZE", "ED25519", "RSA", "P256", "P384", "P521", "SECP256K1", "BLS12381G1", "BLS12381G2", "DID_CORE", "METHOD_OFFSET", "varint_exports", "parse", "did", "key", "base58btc", "decode", "suffix", "encode", "bytes", "DID", "format", "id", "from", "principal", "code", "buffer", "byteOffset", "byteLength", "DIDKey", "code", "signature_exports", "__export", "BLS12381G1", "BLS12381G2", "EIP191", "ES256", "ES256K", "ES384", "ES512", "EdDSA", "NON_STANDARD", "RS256", "Signature", "create", "createNamed", "createNonStandard", "decode", "encode", "format", "fromJSON", "nameCode", "parse", "toJSON", "view", "base64", "rfc4648", "base64pad", "base64url", "base64urlpad", "NON_STANDARD", "ES256K", "BLS12381G1", "BLS12381G2", "EdDSA", "ES256", "ES384", "ES512", "RS256", "EIP191", "codeName", "code", "nameCode", "name", "Signature", "varint_exports", "value", "size", "algorithm", "buffer", "byteOffset", "codeSize", "rawSize", "signer", "payload", "cause", "toJSON", "signature", "raw", "offset", "bytes", "decode", "create", "_", "createNamed", "createNonStandard", "nameBytes", "encode", "view", "format", "base", "base64url", "parse", "base64", "fromJSON", "json", "readPayload", "data", "readPayloadWith", "readPrincipal", "readProof", "readJWTPayload", "readStringPrincipal", "readStringProof", "readCapabilities", "readOptionalArray", "readNullable", "readInt", "readOptional", "readFact", "readString", "readSignature", "source", "decode", "input", "name", "ParseError", "readCapability", "context", "readStruct", "asCapability", "readArray", "readAbility", "readResource", "parseURL", "read", "element", "n", "reader", "isLink", "fail", "parseProof", "parse", "create", "code", "identity", "encode", "readBytes", "readVersion", "readLiteral", "literal", "message", "reason", "JSONEncoder", "buf", "recurs", "Type", "token", "is", "isa", "i", "_buf", "_token", "encodeErrPrefix", "byts", "fromString", "asU8A", "dp", "mapSorter", "e1", "e2", "keyToken1", "keyToken2", "defaultEncodeOptions", "encode", "data", "options", "encodeCustom", "Tokenizer", "data", "options", "c", "str", "decodeErrPrefix", "i", "startPos", "negative", "float", "swallow", "chars", "ch", "Token", "Type", "numStr", "num", "l", "readu4", "u4", "readUtf8Char", "firstByte", "codePoint", "bytesPerSequence", "secondByte", "thirdByte", "fourthByte", "tempCodePoint", "ch1", "decodeCodePointsArray", "token", "decode", "base64_exports", "__export", "base64", "base64pad", "base64url", "base64urlpad", "base64", "rfc4648", "base64pad", "base64url", "base64urlpad", "toByteView", "buf", "cidEncoder", "obj", "cid", "CID", "cidString", "Token", "Type", "bytesEncoder", "bytes", "bytesString", "base64", "taBytesEncoder", "abBytesEncoder", "ab", "undefinedEncoder", "numberEncoder", "num", "encodeOptions", "DagJsonTokenizer", "Tokenizer", "data", "options", "token", "keyToken", "valueToken", "innerKeyToken", "innerValueToken", "i", "decodeOptions", "encode", "node", "encodeOptions", "decode", "data", "buf", "toByteView", "options", "decodeOptions", "DagJsonTokenizer", "utf8Decoder", "utf8Encoder", "format", "model", "header", "formatHeader", "payload", "formatPayload", "signature", "formatSignature", "formatSignPayload", "version", "alg", "base64url", "encodeHeader", "data", "encodePayload", "v", "encode", "encodeProof", "proof", "toJSON", "data", "decode", "encode", "View", "model", "from", "exp", "v", "iss", "aud", "s", "att", "prf", "fct", "nnc", "nbf", "code", "from", "model", "CBORView", "encode", "fct", "nnc", "nbf", "payload", "readPayload", "readVersion", "encodeSignature", "signature", "context", "cause", "decode", "bytes", "readSignature", "CBORView", "View", "code", "format", "encode", "parse", "jwt", "segments", "header", "payload", "signature", "fail", "ucv", "alg", "parseHeader", "parsePayload", "createNamed", "base64url", "typ", "decode", "readLiteral", "readVersion", "readString", "source", "readJWTPayload", "decode", "bytes", "jwt", "JWTView", "parse", "encode", "format", "View", "model", "code", "sha", "name", "data", "sha256", "from", "sha512", "VERSION", "defaultHasher", "sha256", "decode", "bytes", "write", "ucan", "hasher", "defaultHasher", "code", "bytes", "encode", "digest", "create", "issue", "issuer", "audience", "capabilities", "lifetimeInSeconds", "expiration", "now", "notBefore", "facts", "proofs", "nonce", "v", "VERSION", "data", "readPayload", "parse", "payload", "encodeSignaturePayload", "from", "version", "algorithm", "encode", "formatSignPayload", "now", "cbor_exports", "__export", "code", "contentType", "decode", "encode", "link", "name", "write", "contentType", "prepare", "data", "seen", "isLink", "items", "item", "json", "object", "key", "value", "encode", "link", "bytes", "hasher", "sha256", "create", "code", "write", "options", "iterate", "value", "createStore", "blocks", "store", "addEveryInto", "EMBED_CODE", "identity", "get", "cid", "fallback", "block", "notFound", "notFound", "link", "writeInto", "source", "store", "options", "codec", "cbor_exports", "hasher", "sha256", "bytes", "digest", "create", "addInto", "cid", "addEveryInto", "block", "car_exports", "__export", "code", "contentType", "createWriter", "decode", "encode", "link", "name", "write", "import_varint", "CIDV0_BYTES", "V2_HEADER_LENGTH", "decodeVarint", "bytes", "seeker", "i", "varint", "decodeV2Header", "dv", "offset", "getMultihashLength", "codeLength", "length", "lengthLength", "Kinds", "obj", "Types", "i", "v", "ret", "j", "entries", "requiredCount", "key", "value", "Reprs", "CarV1HeaderOrV2Pragma", "readHeader", "reader", "strictVersion", "length", "decodeVarint", "header", "block", "decode", "CarV1HeaderOrV2Pragma", "v2Header", "decodeV2Header", "V2_HEADER_LENGTH", "v1Header", "readCid", "first", "CIDV0_BYTES", "bytes", "multihash", "CID", "version", "codec", "getMultihashLength", "readBlockHead", "start", "cid", "blockLength", "fromBytes", "bytesReader", "v1length", "limitReader", "blocks", "pos", "seek", "out", "byteLimit", "bytesRead", "CarBufferReader", "_CarBufferReader", "header", "blocks", "key", "b", "bytes", "fromBytes", "cborEncoders", "makeCborEncoders", "defaultEncodeOptions", "quickEncodeToken", "tokensToLength", "tokens", "encoders", "cborEncoders", "options", "defaultEncodeOptions", "len", "token", "encoder", "import_varint", "CarBufferWriter", "bytes", "headerSize", "root", "options", "addRoot", "block", "addBlock", "close", "writer", "resize", "byteOffset", "roots", "size", "headerLength", "resizeHeader", "blockLength", "cid", "varint", "byteLength", "writeBytes", "headerBytes", "encode", "varintBytes", "writeHeader", "header", "headerPreludeTokens", "Token", "Type", "CID_TAG", "calculateHeaderLength", "rootLengths", "tokens", "rootLength", "length", "tokensToLength", "createWriter", "buffer", "options", "roots", "byteOffset", "byteLength", "headerSize", "headerLength", "bytes", "writer", "CarBufferWriter", "root", "contentType", "name", "code", "Writer", "blocks", "byteLength", "block", "id", "base32", "blockLength", "rootBlocks", "roots", "headerLength", "buffer", "writer", "createWriter", "encode", "decode", "bytes", "reader", "CarBufferReader", "root", "link", "hasher", "sha256", "create", "write", "data", "options", "cid", "schema_exports", "__export", "API", "Bytes", "did_exports", "link_exports", "text_exports", "uri_exports", "and", "array", "boolean", "bytes", "dictionary", "match", "endsWith", "createEnum", "error", "float", "greaterThan", "integer", "intersection", "lessThan", "literal", "memberError", "never", "nullable", "number", "ok", "optional", "or", "refine", "startsWith", "string", "struct", "toString", "tuple", "typeError", "uint64", "unknown", "variant", "uri_exports", "__export", "from", "match", "read", "uri", "ok", "value", "error", "cause", "panic", "message", "Failure", "fail", "name", "stack", "API", "settings", "input", "value", "result", "optional", "nullable", "array", "schema", "or", "and", "refine", "kind", "fallback", "Default", "Never", "typeError", "never", "Unknown", "unknown", "Nullable", "reader", "UnionError", "Optional", "ArrayOf", "results", "index", "memberError", "Tuple", "shape", "error", "tuple", "Dictionary", "_Dictionary", "key", "dict", "k", "v", "keyResult", "valueResult", "dictionary", "string", "Enum", "variants", "type", "createEnum", "Union", "API", "input", "variants", "causes", "reader", "result", "UnionError", "type", "union", "or", "left", "right", "Intersection", "schemas", "schema", "IntersectionError", "intersection", "and", "Boolean", "typeError", "anyBoolean", "boolean", "UnknownNumber", "n", "greaterThan", "lessThan", "RefinedNumber", "AnyNumber", "anyNumber", "number", "base", "LessThan", "error", "GreaterThan", "Integer", "anyInteger", "integer", "MAX_UINT64", "Uint64Schema", "Uint64", "uint64", "Float", "anyFloat", "float", "UnknownString", "other", "RefinedString", "prefix", "startsWith", "suffix", "endsWith", "AnyString", "anyString", "string", "BytesSchema", "Bytes", "bytes", "StartsWith", "EndsWith", "Refine", "refine", "Literal", "expect", "LiteralError", "value", "toString", "literal", "Struct", "_Struct", "shape", "source", "struct", "entries", "at", "memberError", "key", "optional", "data", "extension", "fields", "field", "Variant", "keys", "fallback", "variant", "message", "SchemaError", "Failure", "TypeError", "actual", "ElementError", "cause", "li", "FieldError", "indent", "URISchema", "API", "input", "protocol", "error", "url", "schema", "uri", "read", "match", "options", "from", "link_exports", "__export", "create", "createLegacy", "isLink", "link", "match", "optional", "parse", "read", "schema", "LinkSchema", "API", "cid", "code", "multihash", "version", "error", "isLink", "expectDigest", "actualDigest", "base32", "schema", "link", "match", "options", "read", "input", "optional", "did_exports", "__export", "did", "from", "match", "read", "DIDSchema", "API", "source", "method", "prefix", "error", "schema", "string", "did", "read", "input", "match", "options", "from", "text_exports", "__export", "match", "read", "text", "schema", "string", "match", "options", "Match", "text", "read", "input", "API", "source", "pattern", "error", "isLink", "isDelegation", "proof", "allows", "delegations", "allow", "delegation", "uri", "can", "nb", "iterateCapabilities", "resource", "issuer", "capabilities", "proofs", "own", "capability", "matchAbility", "provided", "claimed", "Delegation", "root", "blocks", "_attachedLinks", "ucanView", "links", "getLinksFromObject", "link", "fact", "e", "data", "decode", "block", "exportDAG", "archive", "it", "store", "variant", "write", "bytes", "encode", "ok", "cause", "error", "ArchiveSchema", "match", "extract", "roots", "view", "decodeCache", "delegate", "audience", "attachedBlocks", "input", "options", "issue", "cid", "attachedLinks", "exportSubDAG", "importDAG", "dag", "entries", "last", "create", "fallback", "get", "notFound", "obj", "recurse", "key", "value", "invocation_exports", "__export", "Invocation", "create", "invoke", "isInvocation", "view", "isInvocation", "value", "isDelegation", "invoke", "options", "IssuedInvocation", "create", "root", "blocks", "Invocation", "view", "fallback", "block", "get", "notFound", "issuer", "audience", "capability", "proofs", "expiration", "lifetimeInSeconds", "notBefore", "nonce", "facts", "delegate", "connection", "invocation", "result", "Delegation", "message_exports", "__export", "MessageSchema", "build", "view", "receipt_exports", "__export", "issue", "view", "view", "root", "blocks", "fallback", "block", "get", "notFound", "data", "decode", "Receipt", "store", "ran", "issuer", "signature", "proofs", "prf", "link", "proof", "iss", "parse", "fx", "fork", "join", "signingPrincipal", "encode", "iterate", "ReceptBuilder", "result", "NOFX", "meta", "hasher", "sha256", "codec", "cbor_exports", "createStore", "addEveryInto", "outcome", "writeInto", "issue", "options", "MessageSchema", "variant", "struct", "match", "dictionary", "string", "build", "invocations", "receipts", "MessageBuilder", "view", "root", "store", "fallback", "block", "get", "notFound", "data", "cbor_exports", "branch", "value", "Message", "options", "executeField", "writeInvocations", "receiptsField", "writeReceipts", "writeInto", "run", "execute", "invocation", "source", "report", "n", "receipt", "key", "link", "panic", "invocation_exports", "connect", "options", "Connection", "sha256", "invocations", "execute", "connection", "input", "message_exports", "request", "response", "output", "link", "error", "message", "name", "cause", "receipts", "ran", "receipt", "receipt_exports", "signature_exports", "delegate", "delegation_exports", "car_exports", "__export", "contentType", "inbound", "outbound", "request_exports", "response_exports", "request_exports", "__export", "car_exports", "contentType", "decode", "encode", "contentType", "car_exports", "HEADERS", "encode", "message", "options", "blocks", "block", "body", "decode", "headers", "roots", "message_exports", "response_exports", "__export", "car_exports", "contentType", "decode", "encode", "contentType", "car_exports", "HEADERS", "encode", "message", "options", "blocks", "block", "body", "decode", "headers", "roots", "message_exports", "inbound", "source", "Inbound", "headers", "contentType", "decoder", "accept", "parseAcceptHeader", "category", "type", "encoder", "formatAcceptHeader", "decoders", "encoders", "mediaType", "parseMediaType", "a", "b", "outbound", "Outbound", "message", "response", "mediaRange", "params", "preference", "formatMediaType", "contentType", "car_exports", "inbound", "request_exports", "response_exports", "outbound", "http_exports", "__export", "open", "open", "url", "method", "fetch", "Channel", "headers", "body", "response", "buffer", "HTTPError", "message", "options", "status", "statusText", "encoder", "decoder", "response_exports", "__export", "contentType", "encode", "contentType", "HEADERS", "encode", "message", "options", "legacyResults", "receipt", "result", "body", "request_exports", "__export", "contentType", "decode", "contentType", "decode", "body", "roots", "blocks", "run", "cid", "invocation", "invocation_exports", "message_exports", "contentType", "request_exports", "inbound", "contentType", "request_exports", "response_exports", "the", "value", "entries", "object", "combine", "first", "rest", "results", "values", "tuples", "tuple", "intersection", "left", "right", "result", "other", "item", "EscalatedCapability", "Failure", "claimed", "delegated", "cause", "the", "DelegationError", "causes", "context", "li", "value", "MalformedCapability", "Failure", "capability", "cause", "the", "format", "li", "UnknownCapability", "format", "capability", "space", "_key", "value", "isLink", "indent", "message", "li", "capability", "derives", "defaultDerives", "nb", "defaultNBSchema", "etc", "Capability", "schema_exports", "or", "left", "right", "Or", "and", "selectors", "And", "derive", "from", "to", "Derive", "View", "source", "UnknownCapability", "capabilities", "select", "Unit", "other", "descriptor", "options", "can", "decoders", "data", "resource", "createCapability", "with_", "invoke", "input", "readers", "delegate", "result", "parseCapability", "Match", "isEmpty", "object", "_", "_And", "group", "selector", "AndMatch", "selectGroup", "match", "DerivedMatch", "_Match", "value", "proofs", "context", "unknown", "errors", "matches", "resolveCapability", "claim", "DelegationError", "EscalatedCapability", "_DerivedMatch", "selected", "delegation", "direct", "derived", "intersection", "error", "_AndMatch", "pruned", "resolveAbility", "pattern", "fallback", "resolveResource", "uri", "MalformedCapability", "CapabilityView", "claimed", "matcher", "self", "combine", "delegated", "caveats", "kv", "entries", "name", "FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE", "RAW_CODE", "PieceLink", "schema_exports", "equals", "a", "b", "i", "ProviderDID", "did_exports", "SpaceDID", "AccountDID", "Await", "schema_exports", "equalWith", "child", "parent", "ok", "fail", "equal", "constraint", "equalLink", "claimed", "delegated", "equalBlob", "equals", "equalBody", "checkLink", "claimed", "imposed", "at", "equal", "and", "result", "filecoinOffer", "capability", "schema_exports", "PieceLink", "claim", "from", "and", "equalWith", "checkLink", "ok", "filecoinSubmit", "filecoinAccept", "filecoinInfo", "services", "parse", "connection", "connect", "services", "car_exports", "http_exports", "filecoinOffer", "issuer", "resource", "proofs", "audience", "content", "piece", "options", "conn", "filecoinSubmit", "filecoinAccept", "filecoinInfo", "pieceOffer", "capability", "schema_exports", "PieceLink", "claim", "from", "and", "equalWith", "checkLink", "equal", "ok", "pieceAccept", "connection", "connect", "services", "car_exports", "http_exports", "aggregateOffer", "capability", "schema_exports", "PieceLink", "claim", "from", "and", "equalWith", "checkLink", "ok", "aggregateAccept", "connection", "connect", "services", "car_exports", "http_exports", "dealInfo", "capability", "schema_exports", "PieceLink", "claim", "from", "and", "equalWith", "checkLink", "ok", "connection", "connect", "services", "car_exports", "http_exports", "base", "ALPHABET", "name", "BASE_MAP", "j", "i", "x", "xc", "BASE", "LEADER", "FACTOR", "iFACTOR", "encode", "source", "zeroes", "length", "pbegin", "pend", "size", "b58", "carry", "it1", "it2", "str", "decodeUnsafe", "psz", "b256", "it3", "it4", "vch", "decode", "string", "buffer", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "empty", "equals", "aa", "bb", "ii", "coerce", "o", "Encoder", "name", "prefix", "baseEncode", "bytes", "Decoder", "baseDecode", "text", "decoder", "or", "ComposedDecoder", "decoders", "input", "left", "right", "Codec", "from", "encode", "decode", "baseX", "alphabet", "base_x_default", "coerce", "string", "bitsPerChar", "codes", "i", "end", "out", "bits", "buffer", "written", "value", "data", "pad", "mask", "rfc4648", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "base58btc", "baseX", "base58flickr", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "num", "out", "offset", "oldOffset", "decode", "read", "MSB$1", "REST$1", "buf", "res", "shift", "counter", "b", "l", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "value", "varint", "_brrp_varint", "varint_default", "decode", "data", "offset", "varint_default", "encodeTo", "int", "target", "encodingLength", "create", "code", "digest", "size", "sizeOffset", "encodingLength", "digestOffset", "bytes", "encodeTo", "Digest", "decode", "multihash", "coerce", "equals", "a", "b", "data", "format", "link", "base", "bytes", "version", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "cid", "CID", "_CID", "version", "code", "multihash", "bytes", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "other", "self", "unknown", "equals", "base", "format", "input", "value", "encodeCID", "cidSymbol", "decode", "remainder", "specs", "prefixSize", "multihashBytes", "coerce", "digestBytes", "Digest", "initialBytes", "offset", "next", "i", "length", "codec", "multihashCode", "digestSize", "size", "multihashSize", "source", "prefix", "parseCIDtoBytes", "decoder", "base58btc", "base32", "toStringV0", "toStringV1", "codeOffset", "encodingLength", "hashOffset", "encodeTo", "create", "code", "digest", "CID", "raw_exports", "__export", "code", "decode", "encode", "name", "name", "code", "encode", "node", "coerce", "decode", "data", "from", "name", "code", "encode", "Hasher", "input", "result", "create", "digest", "sha", "name", "data", "sha256", "from", "sha512", "store_exports", "__export", "add", "get", "list", "remove", "code", "CARLink", "schema_exports", "store", "capability", "SpaceDID", "equalWith", "add", "link_exports", "claim", "from", "result", "equalLink", "fail", "ok", "get", "remove", "list", "claimed", "delegated", "all", "import_retry", "networkErrorMsgs", "AbortError", "message", "decorateErrorWithCounts", "error", "attemptNumber", "options", "retriesLeft", "isNetworkError", "errorMessage", "getDOMException", "pRetry", "input", "resolve", "reject", "operation", "retry", "reason", "serviceURL", "servicePrincipal", "parse", "receiptsEndpoint", "connection", "connect", "car_exports", "http_exports", "createUploadProgressHandler", "url", "handler", "onUploadProgress", "total", "loaded", "lengthComputable", "add", "issuer", "resource", "proofs", "audience", "car", "options", "bytes", "link", "car_exports", "conn", "connection", "result", "pRetry", "servicePrincipal", "SpaceDID", "responseAddUpload", "fetchWithUploadProgress", "fetchDidCallUploadProgressCb", "res", "status", "AbortError", "err", "carBlob", "get", "list", "remove", "blob_exports", "__export", "add", "get", "list", "remove", "ed25519_exports", "__export", "PUB_KEY_OFFSET", "signer_exports", "verifier_exports", "code", "decode", "derive", "encode", "format", "from", "generate", "name", "or", "parse", "signatureAlgorithm", "signatureCode", "signer_exports", "__export", "PUB_KEY_OFFSET", "code", "decode", "derive", "encode", "format", "from", "generate", "name", "or", "parse", "signatureAlgorithm", "signatureCode", "init_empty", "_0n", "_1n", "_2n", "_8n", "CU_O", "CURVE", "POW_2_256", "SQRT_M1", "SQRT_D", "SQRT_AD_MINUS_ONE", "INVSQRT_A_MINUS_D", "ONE_MINUS_D_SQ", "D_MINUS_ONE_SQ", "ExtendedPoint", "_ExtendedPoint", "x", "y", "z", "t", "p", "Point", "_1n", "mod", "points", "toInv", "invertBatch", "i", "other", "assertExtPoint", "X1", "Y1", "Z1", "X2", "Y2", "Z2", "X1Z2", "X2Z1", "Y1Z2", "Y2Z1", "a", "CURVE", "A", "B", "C", "_2n", "D", "x1y1", "E", "G", "F", "H", "X3", "Y3", "T3", "Z3", "T1", "T2", "_0n", "W", "windows", "base", "window", "n", "affinePoint", "precomputes", "pointPrecomputes", "f", "windowSize", "mask", "maxNumber", "shiftBy", "offset", "wbits", "offset1", "offset2", "cond1", "cond2", "constTimeNegate", "scalar", "normalizeScalar", "P0", "d", "invZ", "is0", "_8n", "invert", "ax", "ay", "zz", "legacyRist", "condition", "item", "neg", "assertRstPoint", "RistrettoPoint", "_RistrettoPoint", "ep", "r0", "r", "Ns", "c", "Ns_D_is_sq", "s", "uvRatio", "s_", "edIsNegative", "Nt", "s2", "W0", "W1", "W2", "W3", "hex", "ensureBytes", "r1", "bytes255ToNumberLE", "R1", "r2", "R2", "emsg", "equalBytes", "numberTo32BytesLE", "u1", "u2", "u1_2", "u2_2", "v", "isValid", "I", "invertSqrt", "Dx", "Dy", "u2sq", "invsqrt", "D1", "D2", "zInv", "_x", "_y", "bytesToHex", "b", "one", "two", "_Point", "strict", "P", "normed", "bytesToNumberLE", "y2", "u", "isXOdd", "privateKey", "getExtendedPublicKey", "bytes", "Signature", "_Signature", "u8", "concatBytes", "arrays", "a", "length", "arr", "result", "i", "pad", "hexes", "v", "bytesToHex", "uint8a", "hex", "hexToBytes", "array", "j", "hexByte", "byte", "numberTo32BytesBE", "num", "numberTo32BytesLE", "edIsNegative", "mod", "_1n", "bytesToNumberLE", "MAX_255B", "bytes255ToNumberLE", "bytes", "b", "CURVE", "res", "_0n", "invert", "number", "modulo", "x", "y", "u", "q", "r", "m", "n", "invertBatch", "nums", "p", "tmp", "lastMultiplied", "acc", "inverted", "pow2", "power", "P", "pow_2_252_3", "_5n", "_10n", "_20n", "_40n", "_80n", "b2", "b4", "_2n", "b5", "b10", "b20", "b40", "b80", "b160", "b240", "b250", "uvRatio", "v3", "v7", "pow", "vx2", "root1", "root2", "SQRT_M1", "useRoot1", "useRoot2", "noRoot", "invertSqrt", "modlLE", "hash", "equalBytes", "b1", "ensureBytes", "expectedLength", "normalizeScalar", "max", "strict", "adjustBytes25519", "checkPrivateKey", "key", "numberTo32BytesBE", "normalizeScalar", "POW_2_256", "ensureBytes", "getKeyFromHash", "hashed", "head", "adjustBytes25519", "prefix", "scalar", "modlLE", "point", "Point", "pointBytes", "_sha512Sync", "getExtendedPublicKey", "key", "getKeyFromHash", "utils", "checkPrivateKey", "getPublicKey", "privateKey", "getExtendedPublicKey", "sign", "message", "privateKey", "ensureBytes", "prefix", "scalar", "pointBytes", "getExtendedPublicKey", "r", "modlLE", "utils", "R", "Point", "k", "s", "mod", "CURVE", "Signature", "prepareVerification", "sig", "message", "publicKey", "ensureBytes", "Point", "r", "s", "Signature", "SB", "ExtendedPoint", "finishVerification", "hashed", "k", "modlLE", "kA", "CURVE", "verify", "msg", "pub", "utils", "Point", "crypto", "empty_exports", "utils", "bytesToHex", "hexToBytes", "concatBytes", "getExtendedPublicKey", "mod", "invert", "hash", "ensureBytes", "bytesToNumberLE", "CURVE", "_1n", "bytesLength", "randomBytes", "messages", "message", "buffer", "windowSize", "point", "Point", "cached", "_2n", "_sha512Sync", "val", "verifier_exports", "__export", "code", "decode", "encode", "format", "name", "or", "parse", "signatureAlgorithm", "signatureCode", "parseWith", "did", "parsers", "parser", "or", "left", "right", "Parser", "_Parser", "variants", "withDID", "key", "id", "VerifierWithDID", "payload", "signature", "code", "name", "signatureCode", "EdDSA", "signatureAlgorithm", "PUBLIC_TAG_SIZE", "varint_exports", "SIZE", "parse", "did", "decode", "bytes", "algorithm", "Ed25519Verifier", "format", "principal", "encode", "key", "base58btc", "payload", "signature", "verify", "id", "withDID", "or", "other", "or", "left", "right", "Importer", "_Importer", "variants", "create", "other", "importers", "archive", "importWith", "name", "key", "id", "importer", "withDID", "signer", "verifier", "SignerWithDID", "payload", "signature", "keys", "code", "name", "signatureAlgorithm", "signatureCode", "PRIVATE_TAG_SIZE", "varint_exports", "PUBLIC_TAG_SIZE", "KEY_SIZE", "SIZE", "PUB_KEY_OFFSET", "generate", "derive", "utils", "secret", "publicKey", "getPublicKey", "signer", "Ed25519Signer", "from", "id", "keys", "key", "decode", "or", "other", "bytes", "keyCode", "encode", "format", "encoder", "base64pad", "parse", "principal", "decoder", "verifier", "withDID", "payload", "raw", "sign", "create", "signature", "EdDSA", "rsa_exports", "__export", "RSAVerifier", "code", "decode", "from", "generate", "name", "or", "signatureAlgorithm", "signatureCode", "_globalReference", "webcrypto", "tagWith", "code", "bytes", "offset", "varint_exports", "multiformat", "untagWith", "source", "byteOffset", "tag", "size", "encodingLength", "encodeTo", "decode", "encodeDERLength", "length", "octets", "readDERLength", "bytes", "offset", "numberBytes", "i", "skip", "input", "expectedTag", "position", "parsed", "into", "actualTag", "encodeBitString", "byteOffset", "encodeOctetString", "encodeSequence", "sequence", "byteLength", "item", "readSequence", "encodeInt", "extra", "enterSequence", "skipSequence", "skipInt", "readBitString", "tag", "readInt", "delta", "readOctetString", "readSequenceWith", "readers", "source", "results", "read", "chunk", "SPKI_PARAMS_ENCODED", "encode", "key", "encodeSequence", "encodeBitString", "decode", "info", "offset", "enterSequence", "keyOffset", "skipSequence", "readBitString", "PKSC8_HEADER", "decode", "info", "offset", "enterSequence", "skipInt", "skipSequence", "readOctetString", "encode", "key", "encodeSequence", "encodeOctetString", "encode", "n", "encodeSequence", "encodeInt", "VERSION", "decode", "source", "byteOffset", "v", "e", "d", "p", "q", "dp", "dq", "qi", "readSequenceWith", "readInt", "name", "code", "verifierCode", "signatureCode", "RS256", "signatureAlgorithm", "ALG", "HASH_ALG", "KEY_SIZE", "SALT_LENGTH", "IMPORT_PARAMS", "generate", "size", "extractable", "publicKey", "privateKey", "webcrypto", "spki", "publicBytes", "tagWith", "decode", "verifier", "RSAVerifier", "pkcs8", "bytes", "ExtractableRSASigner", "UnextractableRSASigner", "from", "id", "keys", "did", "key", "or", "other", "rsa", "untagWith", "encode", "_RSAVerifier", "withDID", "parse", "base58btc", "payload", "signature", "RSASigner", "privateKey", "verifier", "code", "signatureCode", "signatureAlgorithm", "payload", "signature", "buffer", "webcrypto", "ALG", "SALT_LENGTH", "create", "ExtractableRSASigner", "options", "id", "withDID", "UnextractableRSASigner", "Verifier", "verifier_exports", "RSAVerifier", "Signer", "or", "rsa_exports", "UCANLink", "schema_exports", "ucan", "capability", "equalWith", "revoke", "claim", "from", "and", "checkLink", "equal", "conclude", "ok", "attest", "blob", "capability", "SpaceDID", "equalWith", "content", "schema_exports", "add", "equalBlob", "remove", "claimed", "delegated", "fail", "equals", "ok", "list", "get", "blob", "capability", "SpaceDID", "equalWith", "allocate", "schema_exports", "content", "link_exports", "claim", "from", "and", "equalBlob", "checkLink", "equal", "ok", "accept", "Await", "put", "capability", "SpaceDID", "schema_exports", "content", "Await", "claim", "from", "and", "equalWith", "equalBody", "equal", "ok", "receipts_exports", "__export", "ReceiptMissing", "ReceiptNotFound", "poll", "ReceiptNotFound", "taskCid", "ReceiptMissing", "poll", "options", "pRetry", "res", "get", "AbortError", "url", "receiptsEndpoint", "workflowResponse", "agentMessageBytes", "receipt", "car_exports", "createUploadProgressHandler", "url", "handler", "total", "loaded", "lengthComputable", "getConcludeReceipt", "concludeFx", "receiptBlocks", "block", "receipt_exports", "parseBlobAddReceiptNext", "receipt", "forkInvocations", "allocateTask", "fork", "allocate", "concludefxs", "conclude", "putTask", "put", "acceptTask", "accept", "nextReceipts", "fx", "allocateReceipt", "putReceipt", "acceptReceipt", "createConcludeInvocation", "id", "serviceDid", "receiptCids", "concludeAllocatefx", "add", "issuer", "resource", "proofs", "audience", "digest", "data", "options", "bytes", "size", "conn", "connection", "result", "pRetry", "servicePrincipal", "SpaceDID", "input", "nextTasks", "address", "fetchWithUploadProgress", "fetchDidCallUploadProgressCb", "status", "res", "AbortError", "err", "blob", "httpPutReceipt", "derivedSigner", "ed25519_exports", "poll", "blocks", "delegation_exports", "ability", "get", "issuer", "resource", "proofs", "audience", "multihash", "options", "conn", "connection", "result", "servicePrincipal", "SpaceDID", "input", "ability", "digest", "list", "issuer", "resource", "proofs", "audience", "options", "conn", "connection", "result", "servicePrincipal", "SpaceDID", "input", "ability", "cursor", "size", "remove", "issuer", "resource", "proofs", "audience", "multihash", "options", "conn", "connection", "result", "servicePrincipal", "SpaceDID", "input", "ability", "digest", "index_exports", "__export", "add", "index", "capability", "SpaceDID", "equalWith", "add", "schema_exports", "car_exports", "claimed", "delegated", "and", "equal", "ok", "add", "issuer", "resource", "proofs", "audience", "index", "options", "conn", "connection", "result", "pRetry", "servicePrincipal", "SpaceDID", "input", "ability", "upload_exports", "__export", "add", "get", "list", "remove", "upload", "capability", "SpaceDID", "equalWith", "CARLink", "link_exports", "car_exports", "add", "schema_exports", "self", "from", "and", "equal", "ok", "get", "res", "remove", "list", "all", "add", "issuer", "resource", "proofs", "audience", "root", "shards", "options", "conn", "connection", "result", "pRetry", "servicePrincipal", "SpaceDID", "input", "ability", "get", "issuer", "resource", "proofs", "audience", "root", "options", "conn", "connection", "result", "pRetry", "servicePrincipal", "SpaceDID", "input", "ability", "list", "issuer", "resource", "proofs", "audience", "options", "conn", "connection", "result", "servicePrincipal", "SpaceDID", "input", "ability", "cursor", "size", "pre", "remove", "issuer", "resource", "proofs", "audience", "root", "options", "conn", "connection", "result", "servicePrincipal", "SpaceDID", "input", "ability", "unixfs_exports", "__export", "createDirectoryEncoderStream", "createFileEncoderStream", "encodeDirectory", "encodeFile", "codec_exports", "__export", "DEFAULT_DIRECTORY_MODE", "DEFAULT_FILE_MODE", "NodeType", "code", "createAdvancedFile", "createComplexFile", "createDirectoryShard", "createEmptyFile", "createFileChunk", "createFileShard", "createFlatDirectory", "createRaw", "createShardedDirectory", "createSimpleFile", "createSymlink", "cumulativeContentByteLength", "cumulativeDagByteLength", "decode", "decodeMetadata", "encode", "encodeAdvancedFile", "encodeComplexFile", "encodeDirectory", "encodeDirectoryMetadata", "encodeFile", "encodeFileChunk", "encodeFileShard", "encodeHAMTShard", "encodeLink", "encodeMetadata", "encodeMode", "encodeRaw", "encodeSimpleFile", "encodeSymlink", "filesize", "matchFile", "name", "textDecoder", "decodeVarint", "bytes", "offset", "v", "shift", "b", "decodeBytes", "byteLen", "postOffset", "decodeKey", "index", "wire", "decodeLink", "link", "l", "wireType", "fieldNum", "byts", "decodeNode", "links", "linksBeforeData", "data", "node", "textEncoder", "maxInt32", "maxUInt32", "encodeLink", "link", "bytes", "i", "encodeVarint", "nameBytes", "encodeNode", "node", "size", "sizeNode", "index", "sizeLink", "n", "l", "sov", "offset", "v", "base", "x", "len64", "len8tab", "pbNodeProperties", "pbLinkProperties", "textEncoder", "linkComparator", "a", "b", "abuf", "bbuf", "x", "y", "len", "hasOnlyProperties", "node", "properties", "p", "asLink", "link", "Hash", "CID", "pbl", "cid", "e", "prepare", "pbn", "validate", "i", "toByteView", "buf", "code", "encode", "node", "validate", "pbn", "l", "link", "encodeNode", "decode", "bytes", "buf", "toByteView", "decodeNode", "CID", "import_minimal", "$Reader", "$protobuf", "$Writer", "$util", "$root", "Data", "p", "ks", "i", "m", "w", "l", "c", "t", "c2", "d", "o", "n", "j", "valuesById", "values", "UnixTime", "Metadata", "NodeType", "Data", "EMPTY", "EMPTY_BUFFER", "BLANK", "DEFAULT_FILE_MODE", "DEFAULT_DIRECTORY_MODE", "code", "name", "encodePB", "data", "links", "encode", "prepare", "Data", "createRaw", "content", "NodeType", "createEmptyFile", "metadata", "createSimpleFile", "decodeMetadata", "createFileChunk", "createAdvancedFile", "parts", "createFileShard", "createComplexFile", "createFlatDirectory", "entries", "createShardedDirectory", "bitfield", "fanout", "hashType", "readFanout", "readInt", "createDirectoryShard", "encodeRaw", "encodeFile", "node", "ignoreMetadata", "encodeSimpleFile", "encodeAdvancedFile", "encodeComplexFile", "encodeFileChunk", "encodeFileShard", "contentByteLength", "cumulativeContentByteLength", "encodeLink", "encodeMetadata", "dag", "encodeDirectory", "encodeDirectoryMetadata", "encodeNamedLink", "encodeHAMTShard", "n", "createSymlink", "path", "metadata", "BLANK", "NodeType", "decodeMetadata", "encodeSymlink", "node", "ignoreMetadata", "encodePB", "encodeMetadata", "encode", "root", "encodeRaw", "encodeFile", "encodeDirectory", "encodeHAMTShard", "decode", "bytes", "pb", "message", "Data", "type", "data", "mtime", "mode", "blocksizes", "rest", "decodeMtime", "links", "createRaw", "SimpleFileView", "AdvancedFileView", "decodeFileLinks", "ComplexFileView", "createFlatDirectory", "decodeDirectoryLinks", "createShardedDirectory", "EMPTY_BUFFER", "decodeFileLinks", "blocksizes", "links", "parts", "length", "n", "decodeDirectoryLinks", "link", "cumulativeContentByteLength", "size", "cumulativeDagByteLength", "root", "contentByteLength", "encodeNamedLink", "name", "dagByteLength", "cid", "encodeDirectoryMetadata", "metadata", "encodeMetadata", "DEFAULT_DIRECTORY_MODE", "mode", "mtime", "defaultMode", "DEFAULT_FILE_MODE", "encodeMode", "encodeMTime", "decodeMetadata", "data", "BLANK", "decodeMode", "specifiedMode", "matchFile", "content", "EMPTY_BUFFER", "EMPTY", "rest", "SimpleFileView", "AdvancedFileView", "ComplexFileView", "NodeType", "encodeSimpleFile", "encodeAdvancedFile", "encodeComplexFile", "filesize", "node", "effect", "task", "message", "send", "current", "CURRENT", "suspend", "SUSPEND", "wait", "input", "task", "current", "isAsync", "failed", "output", "value", "enqueue", "error", "suspend", "main", "wake", "node", "send", "message", "listen", "source", "forks", "entry", "name", "effect", "NONE", "fork", "tag", "group", "effects", "tasks", "batch", "Tagger", "tags", "state", "SUSPEND", "CURRENT", "tagged", "withTag", "instruction", "none", "withTag", "tag", "value", "CURRENT", "SUSPEND", "Group", "_Group", "member", "MAIN", "group", "driver", "active", "idle", "stack", "Stack", "ID", "Main", "IDLE", "main", "task", "enqueue", "ACTIVE", "_message", "step", "resume", "state", "INIT", "loop", "instruction", "SUSPEND", "CURRENT", "fork", "task", "options", "Fork", "exit", "handle", "value", "conclude", "abort", "handle", "error", "conclude", "result", "task", "state", "SUSPEND", "idle", "Group", "enqueue", "group", "forks", "self", "current", "failure", "fork", "move", "step", "Stack", "suspend", "from", "active", "target", "index", "join", "IDLE", "Future", "handler", "promise", "succeed", "fail", "onresolve", "onreject", "onfinally", "Fork", "options", "BLANK", "INIT", "ID", "resume", "value", "exit", "ACTIVE", "FINISHED", "loop", "init", "next", "controller", "message", "CURRENT", "NONE", "MAIN", "Main", "Indexed", "target", "property", "receiver", "empty", "BufferView", "slice", "buffer", "startOffset", "endOffset", "segments", "start", "end", "empty", "byteLength", "offset", "segment", "nextOffset", "range", "BufferView", "push", "part", "get", "n", "copyTo", "target", "byteOffset", "iterate", "Indexed", "bytes", "panic", "reason", "unreachable", "template", "subject", "substitutions", "EMPTY_BUFFER", "EMPTY", "open", "config", "empty", "write", "state", "bytes", "split", "EMPTY", "close", "buffer", "end", "chunker", "chunks", "offset", "size", "chunk", "mutable", "EMPTY", "addNodes", "newNodes", "input", "queue", "patch", "node", "ready", "has", "wants", "collect", "assign", "addLink", "id", "link", "nodeID", "needs", "nodes", "links", "linked", "result", "original", "BLANK", "patchDict", "append", "EMPTY", "value", "keys", "delta", "key", "target", "entry", "append", "target", "items", "original", "item", "collect", "children", "source", "has", "wants", "ready", "child", "link", "EMPTY", "BLANK", "update", "message", "state", "write", "link", "none", "close", "unreachable", "init", "writer", "metadata", "config", "open", "mutable", "bytes", "chunks", "chunker", "nodes", "leaves", "layout", "linked", "nodeQueue", "addNodes", "tasks", "encodeLeaves", "encodeBranches", "listen", "effects", "panic", "id", "block", "addLink", "newState", "end", "writeBlock", "root", "isLeafNode", "fork", "suspend", "join", "leaf", "encodeLeaf", "hasher", "linker", "content", "encoder", "asUint8Array", "EMPTY_BUFFER", "hash", "wait", "cid", "node", "encodeBranch", "links", "NodeType", "cumulativeContentByteLength", "cumulativeDagByteLength", "buffer", "fixed_exports", "__export", "context", "cut", "name", "type", "withMaxChunkSize", "name", "context", "type", "withMaxChunkSize", "maxChunkSize", "cut", "byteLength", "end", "chunks", "lastChunkSize", "Node", "id", "children", "metadata", "withWidth", "width", "open", "write", "close", "defaults", "layout", "chunks", "EMPTY", "lastID", "head", "slices", "leafIndex", "leaves", "chunk", "leaf", "flush", "state", "nodes", "nodeIndex", "row", "grow", "node", "depth", "height", "top", "root", "index", "length", "defaults", "fixed_exports", "UnixFSLeaf", "codec_exports", "withWidth", "sha256", "CID", "configure", "config", "code", "name", "encodeFileChunk", "create", "writer", "metadata", "settings", "defaults", "FileWriterView", "init", "configure", "write", "view", "bytes", "perform", "send", "close", "releaseLock", "closeWriter", "state", "panic", "effect", "fork", "loop", "message", "update", "options", "defaults", "create", "writer", "settings", "metadata", "DirectoryWriter", "set", "view", "name", "link", "overwrite", "writable", "asWritable", "remove", "close", "closeWriter", "releaseLock", "entries", "links", "node", "createFlatDirectory", "bytes", "encodeDirectory", "digest", "cid", "code", "cumulativeDagByteLength", "state", "dagByteLength", "fork", "options", "Uint32_exports", "__export", "api_exports", "and", "bitCount", "empty", "from", "fromBytes", "get", "or", "popcount", "set", "size", "toBytes", "unset", "api_exports", "empty", "size", "from", "bits", "bitfield", "bit", "set", "_bitField", "mask", "bitField", "index", "offset", "popcount", "bitCount", "unset", "get", "n1", "n2", "and", "left", "right", "or", "toBytes", "fromBytes", "bytes", "import_murmurhash3js_revisited", "utf8", "hash32", "murmur", "configure", "bitWidth", "hash", "mask", "path", "depth", "key", "BitmapIndexedNode", "edit", "datamap", "nodemap", "children", "config", "create", "depth", "path", "key", "notFound", "lookup", "value", "addedLeaf", "associate", "removedLeaf", "dissociate", "fork", "entries", "keys", "values", "HashCollisionNode", "count", "_shift", "_path", "lookupCollision", "associateCollision", "dissociateCollision", "forkCollision", "node", "name", "n", "findHashCollisionNodeIndex", "index", "newNode", "hash", "offset", "canEdit", "create", "config", "edit", "BitmapIndexedNode", "get", "node", "key", "notFound", "lookup", "depth", "path", "datamap", "nodemap", "Path", "BitField", "offset", "index", "keyAt", "valueAt", "resolveNode", "set", "value", "addedLeaf", "associate", "found", "forkAndSet", "branch", "mergeTwoLeaves", "migrateLeafToBranch", "child", "newChild", "copyAndSetChild", "newNode", "keyPosition", "remove", "removedLeaf", "dissociate", "dissociate", "source", "edit", "depth", "path", "key", "removedLeaf", "datamap", "nodemap", "config", "BitField", "Path", "offset", "index", "keyAt", "node", "fork", "keyPosition", "resolveNode", "child", "hasSingleLeaf", "hasSingleNode", "inlineChild", "copyAndSetChild", "entries", "children", "count", "value", "canEdit", "BitmapIndexedNode", "keys", "values", "forkAndSet", "newNode", "valuePosition", "nodePosition", "migrateLeafToBranch", "branch", "oldId", "newId", "mergeTwoLeaves", "oldPath", "oldKey", "oldValue", "newPath", "newKey", "newValue", "HashCollisionNode", "oldOffset", "newOffset", "valueAt", "owner", "editor", "import_murmurhash3js_revisited", "fromNumberTo32BitBuf", "number", "bytes", "i", "murmur332", "from", "input", "mur", "murmur3128", "bytes_exports", "murmur364", "utf8", "hash64", "bytes", "murmur364", "configure", "bitWidth", "hash", "hashSize", "key", "path", "depth", "offset", "toInt", "count", "byteOffset", "bitOffset", "desired", "bits", "byte", "available", "taking", "bitsLeft", "value", "Uint8Array_exports", "__export", "api_exports", "and", "empty", "from", "fromBytes", "get", "or", "popcount", "set", "size", "toBytes", "unset", "empty", "size", "from", "bits", "bitfield", "index", "byte", "byteOffset", "bitOffset", "at", "setByte", "bytes", "result", "set", "unset", "get", "toBytes", "fromBytes", "popcount", "count", "offset", "bitCount", "or", "left", "right", "and", "NOT_FOUND", "configure", "bitWidth", "BitField", "Uint32_exports", "Uint8Array_exports", "Path", "from", "entries", "options", "node", "builder", "key", "value", "has", "hamt", "get", "NOT_FOUND", "notFound", "edit", "config", "HashMapBuilder", "create", "PersistentHashMap", "_PersistentHashMap", "count", "root", "addedLeaf", "set", "remove", "removedLeaf", "utf8", "hash64", "bytes", "murmur364", "configure", "bitWidth", "hash", "hashSize", "options", "path", "depth", "read", "key", "frameBitSize", "digest", "bitCount", "bitOffset", "frameOffset", "frame", "appendByte", "offset", "maxBits", "count", "toInt", "source", "byte", "bitWidth", "config", "configure", "tableSize", "hamt", "builder", "options", "config", "from", "entries", "bitField", "datamap", "nodemap", "BitField", "withoutLeadingZeros", "bytes", "offset", "iterate", "root", "bitfield", "size", "bitOffset", "dataCount", "prefix", "key", "keyAt", "valueAt", "resolveNode", "readonly", "enumerable", "configurable", "linksWithin", "path", "value", "index", "element", "elementPath", "cid", "CID", "links", "source", "base", "key", "treeWithin", "tree", "get", "node", "part", "Block", "bytes", "defaults", "create", "writer", "settings", "metadata", "HAMTDirectoryWriter", "HashMap", "asWritable", "close", "view", "closeWriter", "releaseLock", "entries", "hamt", "blocks", "iterateBlocks", "root", "block", "cumulativeDagByteLength", "node", "ent", "iterate", "shard", "createDirectoryShard", "bitField", "tableSize", "murmur364", "encodeHAMTShardBlock", "bytes", "encodeHAMTShard", "hash", "cid", "code", "Block", "fork", "state", "from", "name", "link", "options", "set", "remove", "builder", "key", "callbackfn", "thisArg", "k", "v", "get", "has", "value", "createWriter", "writable", "settings", "defaults", "FileSystemWriter", "close", "view", "releaseLock", "closeWriter", "writer", "configure", "metadata", "create", "options", "BLOCK_SIZE_LIMIT", "defaultCapacity", "withCapacity", "byteLength", "block", "SHARD_THRESHOLD", "queuingStrategy", "withCapacity", "defaultSettings", "configure", "raw_exports", "withMaxChunkSize", "withWidth", "encodeFile", "blob", "options", "readable", "createFileEncoderStream", "blocks", "collect", "writable", "settings", "unixfsWriter", "createWriter", "fileBuilder", "UnixFSFileBuilder", "_file", "name", "file", "__privateAdd", "__privateSet", "writer", "unixfsFileWriter", "create", "__privateGet", "chunk", "_options", "UnixFSDirectoryBuilder", "__publicField", "dirWriter", "entry", "link", "encodeDirectory", "files", "createDirectoryEncoderStream", "rootDir", "path", "dir", "i", "dirBuilder", "dirName", "collectable", "chunks", "car_exports", "__export", "BlockStream", "blockEncodingLength", "blockHeaderEncodingLength", "code", "encode", "headerEncodingLength", "init_empty", "readHeader", "reader", "strictVersion", "length", "decodeVarint", "header", "block", "decode", "CarV1HeaderOrV2Pragma", "v2Header", "decodeV2Header", "V2_HEADER_LENGTH", "v1Header", "readCid", "first", "CIDV0_BYTES", "bytes", "multihash", "CID", "version", "codec", "getMultihashLength", "readBlockHead", "start", "cid", "blockLength", "readBlock", "readBlockIndex", "offset", "index", "createDecoder", "headerPromise", "v1length", "limitReader", "bytesReader", "pos", "seek", "out", "chunkReader", "readChunk", "have", "currentChunk", "read", "bufa", "chunk", "p", "c", "off", "b", "asyncIterableReader", "asyncIterable", "iterator", "next", "byteLimit", "bytesRead", "CarIteratorBase", "version", "roots", "iterable", "CarBlockIterator", "_CarBlockIterator", "bytes", "iterator", "fromBytes", "asyncIterable", "fromIterable", "fromBytes", "bytes", "decodeIterator", "bytesReader", "fromIterable", "asyncIterable", "asyncIterableReader", "reader", "decoder", "createDecoder", "version", "roots", "import_varint", "CAR_V1_VERSION", "createHeader", "roots", "headerBytes", "encode", "varintBytes", "varint", "header", "createEncoder", "writer", "bytes", "block", "cid", "noop", "create", "chunkQueue", "drainer", "drainerResolver", "ended", "outWait", "outWaitResolver", "makeDrainer", "resolve", "writer", "chunk", "iterator", "CarWriter", "_CarWriter", "roots", "encoder", "block", "cid", "CID", "toRoots", "iterator", "encodeWriter", "writer", "out", "CarWriterOut", "bytes", "reader", "bytesReader", "readHeader", "newHeader", "createHeader", "iw", "create", "createEncoder", "_roots", "root", "_root", "import_varint", "code", "NO_ROOTS_HEADER_LENGTH", "headerEncodingLength", "root", "headerLength", "encode", "varint", "blockHeaderEncodingLength", "block", "payloadLength", "blockEncodingLength", "blocks", "writer", "out", "CarWriter", "error", "err", "chunks", "chunk", "roots", "BlockStream", "car", "blocksPromise", "getBlocksIterable", "CarBlockIterator", "toIterable", "iterator", "controller", "value", "done", "stream", "reader", "alloc", "size", "allocUnsafe", "compare", "a", "b", "i", "concat", "arrays", "length", "acc", "curr", "output", "allocUnsafe", "offset", "arr", "base10_exports", "__export", "base10", "base10", "baseX", "base16_exports", "__export", "base16", "base16upper", "base16", "rfc4648", "base16upper", "base2_exports", "__export", "base2", "base2", "rfc4648", "base256emoji_exports", "__export", "base256emoji", "alphabet", "alphabetBytesToChars", "p", "c", "i", "alphabetCharsToBytes", "codePoint", "encode", "data", "decode", "str", "byts", "char", "byt", "base256emoji", "from", "base8_exports", "__export", "base8", "base8", "rfc4648", "identity_exports", "__export", "identity", "identity", "from", "buf", "toString", "str", "fromString", "textEncoder", "textDecoder", "identity_exports", "__export", "identity", "code", "name", "encode", "coerce", "digest", "input", "create", "identity", "sha2_browser_exports", "__export", "sha256", "sha512", "sha", "name", "data", "sha256", "from", "sha512", "bases", "identity_exports", "base2_exports", "base8_exports", "base10_exports", "base16_exports", "base32_exports", "base36_exports", "base58_exports", "base64_exports", "base256emoji_exports", "hashes", "sha2_browser_exports", "createCodec", "name", "prefix", "encode", "decode", "string", "buf", "str", "ascii", "i", "allocUnsafe", "BASES", "bases", "cache", "toBase58String", "digest", "str", "base58btc", "_data", "DigestMap", "entries", "__privateAdd", "__privateSet", "k", "v", "__privateGet", "key", "mhstr", "callbackfn", "thisArg", "data", "value", "version", "ShardedDAGIndexSchema", "schema_exports", "MultihashSchema", "BlobIndexSchema", "_content", "_shards", "ShardedDAGIndex", "content", "__privateAdd", "__privateSet", "DigestMap", "__privateGet", "shard", "slice", "pos", "index", "archive", "create", "content", "ShardedDAGIndex", "archive", "model", "blocks", "shards", "b", "compare", "index", "s", "slices", "a", "e", "bytes", "encode", "digest", "sha256", "cid", "code", "version", "ok", "car_exports", "symbol", "findBufAndOffset", "bufs", "index", "offset", "buf", "bufEnd", "isUint8ArrayList", "value", "_a", "Uint8ArrayList", "_Uint8ArrayList", "data", "__publicField", "length", "res", "i", "bytes", "beginInclusive", "endExclusive", "concat", "list", "bufStart", "sliceStartInBuf", "sliceEndsInBuf", "start", "search", "needle", "M", "radix", "rightmostPositions", "c", "j", "right", "lastIndex", "lastPatIndex", "skip", "char", "byteOffset", "allocUnsafe", "littleEndian", "alloc", "other", "equals", "acc", "curr", "INT", "encode", "num", "out", "offset", "decode", "buf", "res", "shift", "counter", "b", "l", "State", "CIDV0_BYTES", "_headerPromise", "CARReaderStream", "writableStrategy", "readableStrategy", "buffer", "Uint8ArrayList", "offset", "prevOffset", "wanted", "state", "resolveHeader", "headerPromise", "resolve", "chunk", "controller", "length", "bytes", "decode", "header", "_offset", "cid", "multihash", "createLegacy", "version", "versionBytes", "codec", "codecBytes", "multihashBytes", "getMultihashLength", "create", "blockBytes", "__privateAdd", "__privateSet", "__privateGet", "codeBytes", "lengthBytes", "encodeHeader", "roots", "headerBytes", "encode", "varintBytes", "header", "encodeBlock", "block", "bytes", "CARWriterStream", "writableStrategy", "readableStrategy", "controller", "indexShardedDAG", "root", "shards", "shardIndexes", "index", "create", "i", "shard", "slices", "SHARD_SIZE", "ShardingStream", "options", "shardSize", "maxBlockLength", "headerEncodingLength", "blocks", "readyBlocks", "slices", "DigestMap", "readySlices", "currentLength", "block", "controller", "encodeCAR", "blockHeaderLength", "blockHeaderEncodingLength", "blockLength", "rootBlock", "rootCID", "headerLength", "overage", "overflowBlocks", "overflowCurrentLength", "blockEncodingLength", "overflowSlices", "overflowBlockHeaderLength", "diff", "slice", "defaultFileComparator", "a", "b", "getComparedValue", "file", "ascending", "ask", "bsk", "root", "encode", "uploadFile", "conf", "file", "options", "uploadBlockStream", "createFileEncoderStream", "uploadDirectory", "files", "customOrder", "entries", "defaultFileComparator", "createDirectoryEncoderStream", "uploadCAR", "car", "blocks", "BlockStream", "pieceHasher", "multihash_exports", "configure", "shardIndexes", "shards", "root", "ShardingStream", "controller", "bytes", "digest", "sha256", "ability", "input", "add", "cid", "create", "code", "piece", "multihashDigest", "content", "result", "storefront_exports", "version", "roots", "size", "slices", "meta", "indexBytes", "indexShardedDAG", "indexDigest", "indexLink", "blobAddConf", "indexAddConf", "uploadAddConf"]
}
